<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />        
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />        
  </a>&nbsp;&nbsp;

Если вам интересно мое резюме: https://github.com/DEBAGanov

# Spring
- [Spring](#spring)
   - [Что такое Spring?](#Что_такое_Spring)
   - [Какие преимущества Spring?](#Какие_преимущества_Spring)
   - [Расскажите про контейнер Spring?](#Расскажите_про_контейнер_Spring)
   - [Для чего необходим Spring BeanFactory?](#Для_чего_необходим_Spring_BeanFactory)
   - [Почему Spring Boot использует ApplicationContext, а не BeanFactory?](#Почему_Spring_Boot_использует_ApplicationContext_а_не_BeanFactory)
   - [Для чего необходим Spring ApplicationContext?](#Для_чего_необходим_Spring_ApplicationContext)
   - [Какие есть реализации ApplicationContext?](#Какие_есть_реализации_ApplicationContext)
   - [В чем отличие между ApplicationContext и BeanFactory?](#В_чем_отличие_между_ApplicationContext_и_BeanFactory)
   - [Расскажите про жизненый цикл Context?](#Расскажите_про_жизненый_цикл_Context)
   - [Расскажите про XML конфигурацию контекста?](#Расскажи_про_Xml_конфигурацию_контекста)
   - [Расскажите про Java конфигурацию контекста?](#Расскажи_про_Java_конфигурацию_контекста)
   - [Расскажите про Конфигурацию контекста при помощи аннотаций?](#Расскажи_про_Конфигурацию_контекста_при_помощи_аннотаций)
   - [Расскажите про AnnotationConfigApplicationContext](#Расскажите_про_AnnotationConfigApplicationContext)
   - [Для чего необходим BeanFactoryPostProcessor?](#Для_чего_необходим_BeanFactoryPostProcessor)
   - [Что такое BeanDefinition?](#Что_такое_BeanDefinition)
   - [Как завершить работу Контекста?](#Как_завершить_работу_Контекста)
   - [Расскажите про Bean?](#Расскажите_про_Bean)
   - [Какие есть scope у Bean?](#Какие_есть_scope_у_Bean)
   - [Для чего нам необходим Bean с scope Prototype?](#Для_чего_нам_необходим_Bean_с_scope_Prototype)
   - [Является ли Spring bean singleton потокобезопасным?](#Является_ли_Spring_bean_singleton_потокобезопасным)
   - [Расскажите про жизненый цикл Bean?](#Расскажите_про_жизненый_цикл_Bean)
   - [Как происходит настройка созданных Bean?](#Как_происходит_настройка_созданных_Bean)
   - [Расскажите про BeanDefinition и какие метаданные содержит?](#Расскажите_про_BeanDefinition_и_какие_метаданные_содержит)
   - [Как мы можем получить BeanDefinition?](#Как_мы_можем_получить_BeanDefinition)
   - [Для чего необходим BeanPostProcessor?](#Для_чего_необходим_BeanPostProcessor)
   - [Для чего необходим BeanDefinitionRegistryPostProcessor?](#Для_чего_необходим_BeanDefinitionRegistryPostProcessor)
   - [Расскажите про AnnotationBeanDefinitionRader и как он работает?](#Расскажите_про_AnnotatedBeanDefinitionReader_и_как_он_работает)
   - [Расскажите про ClassPathBeanDefinitionScanner и как он работает?](#Расскажите_про_ClassPathBeanDefinitionScanner_и_как_он_работает)
   - [Какая разница между AnnotationConfigApplicationContext и GenericApplicationContext](#Какая_разница_между_AnnotationConfigApplicationContext_и_GenericApplicationContext)
   - [Зачем нам нужные Proxy объекты в Spring?](#Что_такое_Proxy_объекты_и_зачем_они_вообще_нам)
   - [Как работает ProxyFactory в Spring](#Как_работает_ProxyFactory_в_Spring)
   - [Какие типы прокси есть у Spring?](#Какие_типы_прокси_есть_у_Spring)
   - [Что делает аннотация @PreDestroy?](#Что_делает_аннотация_PreDestroy)
   - [Что делает аннотация @PostConstruct?](#Что_делает_аннотация_PostConstruct)
   - [Как работает аннотация @ComponentScan?](#Как_работает_аннотация_ComponentScan)
   - [Расскажите про статический Bean и как он инициализируется?](#Расскажите_про_статический_Bean_и_как_он_инициализируется)
   - [Расскажите про Inversion of Control?](#Расскажите_про_Inversion_of_Control)
   - [Что такое IoC и в чем разница между Application Context](#Что_такое_IoC_и_в_чем_разница_между_Application_Context)
   - [Что такое Dependency Lookup (Поиск зависимости)?](#Что_такое_Dependency_Lookup_Поиск_зависимости)
   - [Что такое Dependency Injection (Внедрение зависимости) и как он реализуется?](#Что_такое_Dependency_Injection_Внедрение_зависимости)
   - [Расскажите про связывание а @Autowired?](#Расскажите_про_связывание_с_Autowired)
   - [Расскажите про Spring MVC?](#Расскажите_про_Spring_MVC)
   - [Что такое HadlerMapping?](#Что_такое_HandlerMapping)
   - [Что такое HadlerAdapter?](#Что_такое_HandlerAdapter)
   - [Что такое Controller?](#Что_такое_Controller)
   - [Что такое ViewResolver?](#Что_такое_ViewResolver)
   - [Что такое HandlerInterseptor?](#Что_такое_HandlerInterceptor)
   - [Что такое LocalResolver?](#Что_такое_LocalResolver)
   - [Что такое MultipartResolver?](#Что_такое_MultipartResolver)
   - [Расскажите про шаблон проектирования Front Controller?](#Расскажите_про_шаблон_проектирования_Front_Controller)
   - [Что такое DispatcherServlet и из каких частей состоит](#Что_такое_DispatcherServlet_и_из_каких_частей_состоит)
   - [Расскажите про WebApplicationConter и DispatcherServlet?](#Расскажите_про_WebApplicationContext_и_DispatcherServlet)
   - [В чем отличие между ContextLoaderListener и DispatcherServlet?](#В_чем_отличие_между_ContextLoaderListener_и_DispatcherServlet)
   - [Как работает Filters?](#Как_работает_Filters)
   - [Как работает Listeners?](#Как_работает_Listeners)
   - [Как работает Interceptors?](#Как_работает_Interceptors)
   - [Какая разница между Filter Listener Interceptors?](#Какая_разница_между_Filter_Listener_Interceptors)
   - [Что делает аннотация @ModelAttribute?](#Что_делает_аннотация_ModelAttribute)
   - [Расскажите про исключения в Spring MVC?](#Расскажите_про_исключения_в_Spring_MVC)
   - [Что делает аннотация @ExceptionHandler?](#Что_делает_аннотация_ExceptionHandler)
   - [Что делает аннотация @ControllerAdvice?](#Что_делает_аннотация_ControllerAdvice)
   - [Что делает HadlerExceptionResolver?](#Что_делает_HandlerExceptionResolver)
   - [Из каких частей состоит Spring MVC](#Из_каких_частей_состоит_Spring_MVC)
   - [Какие есть реализации Spring MVC](#Какие_реализации_IoC_существуют)
   - [За счет чего делается локализация в Spring MVC?](#За_счет_чего_делается_локализация_в_Spring_MVC)
   - [Расскажите про CommandLineRunner и ApplicationRunner?](#Расскажите_про_CommandLineRunner_и_ApplicationRunner)
   - [Какие паттерны применяются в Spring?](#Какие_паттерны_применяются_в_Spring)
   - [Расскажите про паттерн Chain of Responsibility?](#Расскажите_про_паттерн_Chain_of_Responsibility)
   - [Расскажите про паттерн Dependency Injection и Inversion of control?](#Расскажите_про_паттерн_Dependency_Injection_и_Inversion_of_control)
   - [Рассскажите про паттерн Observer-Observable (Наблюдатель)?](#Рассскажите_про_паттерн_Observer_Observable_Наблюдатель)
   - [Расскажите про паттерн Proxy (Заместитель)?](#Расскажите_про_паттерн_Proxy_Заместитель)
   - [Расскажите про AOP?](#Расскажите_про_AOP)
   - [В чем разница между Сквозной функциональностью и AOP?](#В_чем_разница_между_Сквозной_фукциональностью_и_АОП)
   - [Для чего необходим Аспект?](#Для_чего_необходим_Аспект)
   - [Для чего необходим Join point?](#Для_чего_необходим_Join_point)
   - [Для чего необходим Совет Advice?](#Для_чего_необходим_Совет_Advice)
   - [Для чего необходим Poincut (Срез)?](#Для_чего_необходим_Pointcut_Срез)
   - [В чем отличие Spring AOP и AspectJ?](#В_чем_отличие_Spring_AOP_и_AspectJ)
   - [Как создать аннотацию?](#Как_создать_аннотацию)
   - [Расскажите про частые аннотации Spring?](#Расскажите_про_частые_аннотации_Spring)
   - [Что делает аннотация @RequestMapping?](#Что_делает_аннотация_RequestMapping)
   - [Что делает аннотация @ResponseBody?](#Что_делает_аннотация_ResponseBody)
   - [Что делает аннотация @ResponseEntity?](#Что_делает_аннотация_ResponseEntity)
   - [Что делает аннотация @PathVaiable?](#Что_делает_аннотация_PathVariable)
   - [В чем различия @Controller и @RestController?](#В_чем_различия_между_аннотациями_Controller_и_RestController)
   - [Для чего необходима аннотация @Profile?](#Для_чего_необходима_аннотация_Profile)
   - [Для чего необходима аннотация @Lookup?](#Для_чего_необходима_аннотация_Lookup)
   - [Для чего необходима аннотация и какие свойства имеет @Target?](#Для_чего_необходима_аннотация_и_какие_свойства_имеет_Target)
   - [Для чего необходима аннотация и какие свойства имеет @Retention?](#Для_чего_необходима_аннотация_и_какие_свойства_имеет_Retention)
   - [Для чего необходима аннотация @Resource?](#Для_чего_необходима_аннотация_Resource)
   - [Для чего необходима аннотация @Inject?](#Для_чего_необходима_аннотация_Inject)
   - [Для чего необходима аннотация @Conditional?](#Для_чего_необходима_аннотация_Conditional)
   - [Какие типы Propagation есть в транзакциях](#Какие_типы_Propagation_есть_в_транзакциях)
   - [Как управлять транзакциями в Spring?](#Как_управлять_транзакциями_в_Spring)
   - [Расскажите все про транзакции?](#Все_про_транзакции)
   - [Для чего необходима аннотация @EnableTransactionManager?](#Для_чего_необходима_аннотация_EnableTransactionManager)
   - [Для чего необходима и как работает аннотация @Transaction?](#Для_чего_необходима_и_как_работает_аннотация_Transaction)
   - [Что такое TransactionInterceptor?](#Что_такое_TransactionInterceptor)
   - [Для чего необходим TransactionManager?](#Для_чего_необходим_TransactionManager)
   - [Что такое Аспект транзакций и какие есть функции?](#Что_такое_Аспект_транзакций_и_какие_есть_функции)
   - [Какие есть параметры изоляции у аннотации @Transaction?](#Какие_есть_параметры_изоляции_у_аннотации_Transaction)
   - [Что произойдет если один метод @Transaction вызовет другой метод @Transaction?](#Что_произойдет_если_один_метод_Transaction_вызовет_другой_метод_Transaction)
   - [Зачем необходим PreparedStatementCreator?](#Зачем_необходим_PreparedStatementCreator)
   - [В чем отличие между SOAP и REST?](#В_чем_отличие_между_SOAP_и_REST)
   - [Для чего необходима нам Spring Data?](#Для_чего_необходима_нам_Spring_Data)
   - [Что делает аннотация @EnableJpaRepository?](#Что_делает_аннотация_EnableJpaRepository)
   - [Что такое Spring Boot?](#Что_такое_Spring_Boot)
   - [Как происходит автоконфигурация Spring boot?](#Как_происходит_автоконфигурация_Spring_boot)
   - [Что такое внедрение зависимостей?](#Что_такое_внедрение_зависимостей)
   - [В чем разница внедрениячерез поля и через конструктор?](#В_чем_разница_внедрения_через_поля_и_через_конструктор)
   - [В чем отличие RestTemplate и JDBCTemplate?](#В_чем_отличие_RestTemplate_и_JDBCTemplate)
   - [Что такое Socket?](#Что_такое_Socket)
   - [Что такое RESTful и какие основные принципы?](#Что_такое_RESTful_какие_основные_принципы)
   - [Какая польза от аннотаций WebMvcTest в приложениях Spring MVC?](#Какая_польза_от_аннотации_WebMvcTest_в_приложениях_Spring_MVC)
   - [Какие существуют типы тестирования микросервисов?](#Какие_существуют_типы_тестирования_микросервисов)



## Что_такое_Spring

Spring — это мощный фреймворк для разработки Java-приложений, который строится на принципах IoC и DI, позволяя управлять
зависимостями автоматически. Он включает в себя множество модулей, таких как Spring MVC для веба, Spring Data для работы
с БД и Spring Security для защиты приложений.
Он состоит из:
1. основного контейнера который отвечает за конфигурацию и настройки компонентов
2. AOP отвечающего за аспектно-ориентированное программирование
3. Spring Data - для взаимодействия с базой данной
4. Spring MVC - для Web-приложений и реализации паттерна MVC

## Какие_преимущества_Spring

Позволяет писать независимые компоненты друг от друга, Spring IoC управляет жизненным циклом бинов, упрощает разработку, 
содержит модули которые под капотом выполняют рутинную работу

## Расскажите_про_контейнер_Spring

Контейнер Spring — это основа фреймворка, которая управляет бинами, их зависимостями и жизненным циклом.
Он реализует принцип Inversion of Control (IoC) через механизм Dependency Injection (DI).
IoC-контейнер инвертирует управление объектами: вместо того чтобы разработчик вручную создавал зависимости.
Типы контейнеров:
1. BeanFactory
- Простейшая реализация IoC.
- Ленивая инициализация (бины создаются только при запросе).
- Используется редко (в legacy-проектах).
2. ApplicationContext
- Наследует BeanFactory и добавляет дополнительные возможности:
  - Поддержку AOP, транзакций, международных сообщений.
  - Автоматическое сканирование компонентов (@ComponentScan).
  - Интеграцию с Spring Boot, Spring MVC.
- Инициализирует бины при старте

Контейнер Spring имеет 3 конфигурации:
1. XML
2. Annotation
3. Java
Бины создаются при помощи вызова метода getBean().

## Для_чего_необходим_Spring_BeanFactory

BeanFactory — это базовый IoC-контейнер в Spring, отвечающий за управление бинами (Java-объектами) и их зависимостями. 
Он создает и предоставляет bean-компоненты на основе BeanDefinition-ов и является ядром ApplicationContext.
Spring BeanFactory Container - простой контейнер который обеспечивает поддержку DI.
Хотя ApplicationContext более популярен, BeanFactory полезен в следующих сценариях:
1. Если нужно минимизировать потребление памяти
2. При разработке собственных фреймворков или расширений Spring можно использовать BeanFactory как основу.
3. В старых проектах с XML-конфигурацией BeanFactory может быть основным контейнером.

# Почему_Spring_Boot_использует_ApplicationContext_а_не_BeanFactory

ApplicationContext расширяет BeanFactory, добавляя:
1. Поддержку аннотаций (@Component, @Autowired).
2. Автоматическое сканирование компонентов (@ComponentScan).
3. Интеграцию с AOP, транзакциями, Spring MVC.
4. Event-механизмы (например, ContextRefreshedEvent).

## Для_чего_необходим_Spring_ApplicationContext

ApplicationContext — это расширенная версия BeanFactory, представляющая собой центральный интерфейс в Spring, 
который управляет бинами, их зависимостями, жизненным циклом и интеграцией с другими модулями фреймворка.
ApplicationContext — это "продвинутая" версия BeanFactory с полным набором функций для enterprise-разработки.

"Как Spring Boot использует ApplicationContext?"
→ Ответ:
Spring Boot создает AnnotationConfigApplicationContext через SpringApplication.run(), автоматически настраивая 
бины на основе @SpringBootApplication.

## Какие_есть_реализации_ApplicationContext

У ApplicationContext есть реализации:
1. XmlApplicationContext (Загрузка бинов из XML-файла в classpath)
2. AnnotationApplicationContext (Загрузка бинов через Java-классы с аннотациями)
3. JavaApplicationContext
4. FileSystemXmlApplicationContext (Загрузка бинов из XML-файла в файловой системе)
5. AnnotationConfigWebApplicationContext (Загрузка бинов через аннотации в веб-приложениях)

## В_чем_отличие_между_ApplicationContext_и_BeanFactory

1. ApplicationContext загружает все бины при запуске а BeanFactory - по требованию
2. ApplicationContext расширяет BeanFactory. Поддержка внедрения зависимостей основна на аннотации, простая интеграция 
   с AOP
3. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor
4. ApplicationContext поддерживает все типы scope bean а BeanFactory только два - Singleton, Prototype
5. В BeanFactory не будут работать транзакции и AOP.

## Расскажите_про_жизненый_цикл_Context

1. Контейнер создается при запуске приложения
2. Контейнер считывает конфигурационные данные (аннотации, XML, JavaConfig)
3. Из конфигурационных данных создается описание бинов (BeanDefinition) BeanDefinitionReader
4. BeanFactoryPostProcessor обрабатывает описание бинов
5. Контейнер создает бины и использует их описание
6. Бины инициализируются - значения свойств и зависимости внедряются в бин
7. BeanPostProcessor запускают методы обратного вызова(callback methods)
8. Приложение запущено и работает
9. Инициализируется закрытие приложение
10. Контейнер закрывается
11. Вызываются callback methods

## Расскажи_про_Xml_конфигурацию_контекста

Для Xml конфигурации используется класс XmlBeanDefinitionReader, который реализует интерфейс BeanDefinitionReader.
XmlBeanDefinitionReader получает InputStream и загружает документ через DefaultDocumentLoader. Далее обрабатывается 
каждый элемент документа и если он является бином то создается BeanDefinition.  Каждый BeanDefinition помещается в Map.
Map хранится в DefaultListableBeanFactory

## Расскажи_про_Java_конфигурацию_контекста

Создается класс конфигурации помеченный аннотацией @Configuration в котором идут методы помеченные аннотацией @Bean.
Для этого используется AnnotationConfigApplicationContext. В нем есть метод ClassPathBeanDefinitionScanner который 
сканирует аннотации, найденные классы парсируются и для них создаются BeanDefinition. BeanDefinition создаются при 
помощи AnnotatedBeanDefinitionReader который сначала сканирует все аннотации а затем регистрирует 
BeanFactoryPostProcessor а именно BeanDefinitionRegistryPostProcessor который при помощи класса ConfigurationClassParser 
парсирует JavaConfig и создает BeanDefinition. Дальше у нас есть Map с нашими BeanDefinition. Если мы хотим как-то 
повлиять на BeanDefinition то мы можем использовать BeanFactoryPostProcessor который по имени может достать нужный 
BeanDefinition. Дальше происходит создание бинов при помощи BeanFactory на основе BeanDefinition.

## Расскажи_про_Конфигурацию_контекста_при_помощи_аннотаций

Заключается в автоматическом обнаружении и регистрации бинов помеченных такими аннотациями как @Component, @Service, 
@Repository, @Controller. Для этого используется AnnotationConfigApplicationContext. В нем есть метод 
ClassPathBeanDefinitionScanner который сканирует аннотации, найденные классы парсируются и для них создаются 
BeanDefinition. BeanDefinition создаются при помощи AnnotatedBeanDefinitionReader который сначала сканирует все 
аннотации а затем регистрирует BeanFactoryPostProcessor а именно BeanDefinitionRegistryPostProcessor который при 
помощи класса ConfigurationClassParser парсирует JavaConfig и создает BeanDefinition. Дальше у нас есть Map с нашими 
BeanDefinition. Если мы хотим както повлиять на BeanDefinition то мы можем использовать BeanFactoryPostProcessor 
который по имени может достать нужный BeanDefinition. Дальше происходит создание бинов при помощи BeanFactory на 
основе BeanDefinition.

## Расскажите_про_AnnotationConfigApplicationContext

AnnotationConfigApplicationContext — это реализация ApplicationContext в Spring, которая позволяет конфигурировать 
Spring-приложение с помощью Java-классов и аннотаций, без использования XML.
Раньше Spring настраивался через ClassPathXmlApplicationContext, но AnnotationConfigApplicationContext позволяет полностью 
отказаться от XML в пользу аннотаций (@Configuration, @Bean, @ComponentScan).
Он используется в Xml и Annotation конфигурациях и содержит в себе два поля
1. private final AnnotatedBeanDefinitionReader reader;
2. private final ClassPathBeanDefinitionScanner scanner;

## Для_чего_необходим_BeanFactoryPostProcessor

Интерфейс который позволяет получить доступ к созданным BeanDefinition и можем их изменять или дополнять. Он содержит 
метод postProcessorBeanFactory который принимает в себя параметры ConfigurableListableBeanFactory. в котором есть метод
getBeanDefinitionNames через который можем получить все BeanDefinitionNames а уже по имени можем получить BeanDefinition.

BeanFactoryPostProcessor нужен для:
1. Модификации метаданных бинов перед их созданием
2. Программной регистрации дополнительных бинов
3. Кастомизации работы Spring-контейнера

Отличия от BeanPostProcessor:
1. Работает с BeanDefinition, а не с готовыми бинами
2. Выполняется на более ранней фазе инициализации контекста

## Что_такое_BeanDefinition

BeanDefinition -Это интерфейс который содержит метаданные о бине (имя бина, класс, зависимости, настройки 
жизненного цикла)
Spring предоставляет несколько реализаций:
1. RootBeanDefinition: Полное определение бина (используется для родительских бинов)
2. ChildBeanDefinition: Наследует свойства от родителя (устарело в новых версиях)
3. GenericBeanDefinition: Гибкая замена для Root/Child (современный стандарт)
4. AnnotatedBeanDefinition: Для бинов, определенных через аннотации (@Component)

Жизненный цикл BeanDefinition
1. Загрузка: Чтение из XML/аннотаций/Java Config
2. Модификация: BeanFactoryPostProcessor может изменить определения
3. Создание бина: На основе BeanDefinition создается экземпляр
4. Инициализация: Вызов @PostConstruct, InitializingBean и т.д.

## Расскажите_про_BeanDefinition_и_какие_метаданные_содержит

BeanDefinition содержит следующие метаданные:
1. Имя класса с указанием пакета
2. Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере.
3. Ссылки на другие bean-компоненты, которые необходимы для его работы. (зависимости)
4. Другие параметры конфигурации для установки во вновь созданном объекте, например ограничение размера пула или
   количество соединений.

## Как_мы_можем_получить_BeanDefinition

Для этого нам необходим BeanFactoryPostProcessor. В нем есть метод postProcessorBeanFactory который принимает параметры
ConfigurableListableBeanFactory а в нем есть метод getBeanDefinitionNames через который можем по имени получить все
BeanDefinition

## Как_завершить_работу_Контекста

Есть 2 способа:
1. Регистрация shutdown-hook с помощью вызова метода registerShutdownHook() он также реализован в классе 
   AbstractApplicationContext.
2. Можно вызывать метод close() из класса AbstractApplicationContext.

В Spring Boot приложении: Spring Boot самостоятельно зарегистрирует shutdown-hook за вас.

## Расскажите_про_Bean

Бин - это обычный объект java которым управляет контекст Spring. По умолчанию он задается как Singleton. 
Конфигурационный файл Spring определяет все бины которые будут инициализированы в Spring context.

## Какие_есть_scope_у_Bean

1. Singleton - один единственный бин на весь контейнер IoC.
2. Prototype - создается новый экземпляр бина на каждый запрос.
3. Request - создается один экземпляр бина на каждый HTTP запрос.
4. Session - создается экземпляр бина на каждую HTTP сессию.
5. Application - создается один экземпляр бина, похож на синглетон только ограничен областью приложения ServletContext.
6. Web socket - создается экземпляр бина для сокета.

## Для_чего_нам_необходим_Bean_с_scope_Prototype

Допустим нам нужны данные каждые для своего запроса допустим логин и пароль. Или допустим при многопоточке чтобы избежать
проблемы с состоянием, но в данном случае не вызывается PreDestroy бина т.к. он не сохраняется в контексте спринга и он о
нем нечего не знает.

## Является_ли_Spring_bean_singleton_потокобезопасным

нет т.к. спринг создает один экземпляр на все приложение и разные потоки могут изменить его состояние что будет не 
корректно

## Расскажите_про_жизненый_цикл_Bean

1. Загрузка описания бинов, создания графов зависимостей
2. Создание и запуск BeanFactoryPostProcessor
3. Создание бинов
4. Внедрение значений и зависимостей в свойства бина
5. Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод
6. Если бин реализует BeanFactoryAware то Spring устанавливает ссылку на bean factory через setBeanFactory()
7. Если бин реализует интерфейс ApplicationContextAware то Spring устанавливает ссылку на ApplicationContext через 
   setApplicationContext()
8. BeanPostProcessor это специальный интерфейс и Spring позволяет имплементировать его.
9. Если переопределены методы обратного вызова то Spring вызывает их. Это к примеру @PostConstruct или initMethod
10. Теперь бин готов к использованию и его можно получить с помощью метода ApplicationContext.getBean()
11. После того как контекст будет закрыт, бин уничтожится.
12. Если в бине есть метод аннотированный @PreDestroy то перед уничтожением вызовется этот метод.

## Как_происходит_настройка_созданных_Bean

Настройка происходит при помощи BeanPostProcessor. Он позволяет вклиниться в процесс настройки бинов до того как они 
попадут в контейнер и имеет два метода:
1. postProcessBeforeInitialization
2. postProcessAfterInitialization.
   Разница этих методов в том что первый вызывается до init метода а второй после init метода.

## Для_чего_необходим_BeanPostProcessor

Это интерфейс который позволяет выполнять кастомную логики до и после инициализации бина. Он содержит методы
postProcessBeforeInitialization и postProcessAfterInitialization. Разница этих методов в том что первый вызывается до 
init метода а второй после init метода.
Интерфейс BeanPostProcessor позволяют разработчику самому имплементировать некоторые методы бинов перед инициализацией и 
после уничтожения экземпляров бина. Имеется возможность настраивать несколько имплементаций BeanPostProcessor и 
определить порядок их выполнения. Данный интерфейс работает с экземплярами бинов, а это означает, что Spring IoC 
создаёт экземпляр бина, а затем BeanPostProcessor с ним работает. ApplicationContext автоматически обнаруживает любые 
бины, с реализацией BeanPostProcessor и помечает их как “post-processors” для того, чтобы создать их определённым 
способом.

## Для_чего_необходим_BeanDefinitionRegistryPostProcessor

BeanDefinitionRegistryPostProcessor — это расширенная версия BeanFactoryPostProcessor, которая позволяет динамически 
регистрировать, модифицировать или удалять BeanDefinition'ы на самой ранней стадии инициализации Spring-контекста.
Он расширяет интерфейс BeanFactoryPostProcessor.

BeanDefinitionRegistryPostProcessor нужен для:
1. Динамической регистрации бинов на ранней стадии
2. Глубокой кастомизации процесса загрузки конфигурации
3. Интеграции со сторонними системами (MyBatis, кастомные DSL)

Ключевые отличия от BeanFactoryPostProcessor:
1. Более ранняя фаза выполнения
2. Доступ к механизмам регистрации/удаления бинов
3. Используется для сложных сценариев инициализации

Где применяется в Spring:
1. Обработка @Configuration классов
2. Интеграции (MyBatis, JPA)
3. Сканирование компонентов

## Расскажите_про_AnnotatedBeanDefinitionReader_и_как_он_работает

AnnotatedBeanDefinitionReader — это важный компонент Spring, который отвечает за регистрацию бинов на основе 
аннотаций (например, @Component, @Service, @Configuration) напрямую, без сканирования классов. Это "ручной" 
способ добавления аннотированных классов в Spring-контейнер.

AnnotatedBeanDefinitionReader позволяет:
1. Регистрировать отдельные классы с аннотациями как бины в Spring-контексте
2. Обрабатывать аннотации без использования @ComponentScan
3. Настраивать дополнительные параметры (scope, lazy, primary) при регистрации

Как он работает?
1. Шаг 1: Анализ аннотаций класса
- При вызове register():
  - Проверяет наличие стандартных аннотаций:
    a) @Component (и ее производные: @Service, @Repository, @Controller)
    b) @Configuration
    c) @Scope
    d) @Lazy
    e) @Primary
  - Создает AnnotatedGenericBeanDefinition (специальный тип BeanDefinition для аннотированных классов)
2. Шаг 2: Обработка метаданных
- Извлекает информацию из аннотаций:
  - Имя бина (из @Component.value или генерирует по правилам)
  - Scope (по умолчанию singleton)
  - Lazy-инициализация
  - Primary-статус
3. Шаг 3: Регистрация в контейнере
   Добавляет BeanDefinition в BeanDefinitionRegistry контекста

## Расскажите_про_ClassPathBeanDefinitionScanner_и_как_он_работает

ClassPathBeanDefinitionScanner — это ключевой механизм Spring для сканирования классов на classpath и автоматической 
регистрации бинов на основе аннотаций. Это "движок", стоящий за @ComponentScan и автоматическим обнаружением компонентов.

Сканер решает три главные задачи:
1. Поиск классов с Spring-аннотациями (@Component, @Service, @Repository, @Controller) в указанных пакетах
2. Фильтрация найденных классов (включение/исключение по правилам)
3. Регистрация подходящих классов как BeanDefinition в контейнере

Как работает сканирование?
1. По указанному пакету определяется список файлов для сканирования. Все файлы попадают в директории.
2. Сканер проходит по каждому файлу, получает InputStream и сканирует при помощи класса ClassReader.class
3. На 3-ем этапе сканер проверяет, проходят ли найденные объекты по фильтрам аннотации AnnotationTypeFilter. 
   По умолчанию Spring ищет классы, которые помечены аннотацией Component либо любой другой аннотацией, 
   которая включает в себя Component.
4. Если проверка проходит успешно, создаются и регистрируются новые BeanDefinition.

## Какая_разница_между_AnnotationConfigApplicationContext_и_GenericApplicationContext

AnnotationConfigApplicationContext — это готовый ApplicationContext для аннотационной конфигурации (Java-based), 
поддерживающий @Configuration, @Bean и @ComponentScan.
GenericApplicationContext — более гибкий и универсальный контейнер, который можно настраивать вручную (например, 
через BeanDefinitionRegistry), но без автоматического сканирования компонентов.

AnnotationConfigApplicationContext:
Автоматически обрабатывает классы с @Configuration, @Bean, @ComponentScan.
Сам регистрирует BeanDefinition на основе аннотаций.

GenericApplicationContext:
Не поддерживает @ComponentScan "из коробки".
Позволяет регистрировать бины через:
- registerBean() (программно).
- BeanDefinitionRegistry (гибкое управление бинами до их создания).

Когда что использовать?
AnnotationConfigApplicationContext:
- Стандартные Spring-приложения с аннотациями.
- Когда нужна автоматическая регистрация бинов (@Service, @Repository).
GenericApplicationContext:
- Динамическое создание бинов (например, плагинная архитектура).
- Интеграция с не-Spring-кодом (регистрация бинов вручную).

## Что_такое_Proxy_объекты_и_зачем_они_вообще_нам

Proxy — это обертка над объектом, который перехватывает вызовы к реальному объекту, добавляя дополнительную логику 
(например, транзакции, ленивую загрузку, кэширование, безопасность) до/после вызова методов. 
Используется в Spring для AOP, в Hibernate для ленивой загрузки, в RPC для удаленных вызовов. Бывают статические, 
динамические (JDK) и CGLIB-прокси.

Зачем нужны Proxy?
- Добавление функциональности без изменения исходного кода (AOP, транзакции, логирование).
- Ленивая инициализация (например, в Hibernate — загрузка данных только при обращении).
- Контроль доступа (например, проверка прав перед вызовом метода).
- Упрощение работы с дорогостоящими ресурсами (например, соединения с БД).

Типы Proxy в Java
1. Статические прокси (Static Proxy) Создаются вручную: интерфейс + реализация + прокси-класс.
2. Динамические прокси (Dynamic Proxy) Создаются в runtime через java.lang.reflect.Proxy. Работают только с интерфейсами.
3. Прокси через CGLIB (для классов без интерфейсов) Используется в Spring, когда у класса нет интерфейса. Создает 
   наследника класса и переопределяет методы.

Где применяются Proxy?
- Spring AOP @Transactional, @Cacheable, @Secured — все это работает через прокси. Например, вызов метода с 
  @Transactional оборачивается в управление транзакцией.
- Hibernate (Lazy Loading) Прокси-объекты для @ManyToOne, @OneToMany подгружают данные только при обращении.
- RPC (Remote Procedure Call) Клиентский прокси имитирует вызов метода на удаленном сервере (например, gRPC, REST).

## Как_работает_ProxyFactory_в_Spring

ProxyFactory в Spring — это гибкий механизм для создания AOP-прокси программным способом. Он:
1. Поддерживает оба типа прокси (JDK Dynamic Proxy и CGLIB)
2. Позволяет добавлять Advice (логирование, транзакции, безопасность)
3. Работает через Advisor (Pointcut + Advice)
4. Используется внутри Spring для реализации @Transactional, @Cacheable

`ProxyFactory factory = new ProxyFactory(targetObject);
factory.addAdvice(new MyMethodInterceptor());
MyInterface proxy = (MyInterface) factory.getProxy();`

## Какие_типы_прокси_есть_у_Spring

1. CGLIB Proxy (на основе наследования классов)
2. JDK Dynamic Proxy (на основе интерфейсов)

Как Spring выбирает тип прокси?
По умолчанию Spring использует JDK Dynamic Proxy, если класс реализует интерфейс.
Если интерфейсов нет — автоматически применяется CGLIB.
Можно форсировать CGLIB (даже для интерфейсов) через @EnableAspectJAutoProxy(proxyTargetClass = true)

Зачем они нужны?
- Для AOP (@Transactional, @Cacheable).
- Для ленивой загрузки в JPA.
- Для добавления логики без изменения исходного кода.

## Что_делает_аннотация_PreDestroy

Метод запускается один раз перед тем как данный бин будет удален и Spring ApplicationContext
Цель метода освобождения ресурсов или закрытия connect перед удалением бина.

## Что_делает_аннотация_PostConstruct

@PostConstruct — это аннотация которую Spring (и другие DI-фреймворки) используют для пометки метода, который 
должен быть выполнен после создания бина и инъекции зависимостей, но до того как бин будет готов к использованию.
Альтернатива в современных версиях Spring — @EventListener(ContextRefreshedEvent)

Когда именно вызывается?
1. После BeanPostProcessor.postProcessBeforeInitialization()
2. Перед BeanPostProcessor.postProcessAfterInitialization()

@PostConstruct нужен для:
1. Инициализации бина после инъекции зависимостей
2. Валидации конфигурации
3. Предварительных вычислений/кэширования

Ограничения
1. Метод не должен быть static
2. Может не иметь параметров
3. Может возвращать void или любое значение (оно игнорируется)
4. Не должен выбрасывать checked exceptions (только unchecked)

Spring использует CommonAnnotationBeanPostProcessor для обработки @PostConstruct. Это происходит:
1. При создании контекста (ApplicationContext)
2. Для каждого бина после инъекции зависимостей
3. Через рефлексию (если метод приватный — все равно вызовется)

## Как_работает_аннотация_ComponentScan

@ComponentScan — это аннотация Spring, которая автоматически обнаруживает и регистрирует бины в контейнере IoC. 
Она сканирует указанные пакеты и подпакеты, находя классы, помеченные стереотипными аннотациями 
(@Component, @Service, @Repository, @Controller), и добавляет их в ApplicationContext.
По умолчанию сканирует текущий пакет и его подпакеты, если не указан явно.
Если два сканера находят один класс — побеждает последний зарегистрированный.

Классы, участвующие в процессе
- ComponentScanAnnotationParser: Парсит аннотацию
- ClassPathBeanDefinitionScanner: Выполняет сканирование classpath
- BeanDefinitionRegistry: Хранит зарегистрированные бины

## Расскажите_про_статический_Bean_и_как_он_инициализируется

Если в классе будет статический метод то при инициализации впервую очередь создается статический метод а потом уже Bean 
который навешивается на статический метод. При этом Spring не позволяет внедрять бины напрямую в статические поля. 
Нужно создать нестатический сеттер-метод.

## Расскажите_про_Inversion_of_Control

IoC - позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, 
фреймворк берет это на себя посредством контейнера. Контейнер отвечает за управление жизненным циклом бинов, созданием, 
инициализации и конфигурирования бинов.
Inversion of Control в Spring — это:
- Принцип, при котором контейнер управляет созданием и связыванием объектов.
- Реализуется через Dependency Injection (внедрение зависимостей).
- Позволяет писать гибкий, тестируемый и слабосвязанный код.

Как работает:
- Объекты (бины) регистрируются в контейнере (@Component, @Bean).
- Зависимости внедряются автоматически (@Autowired).

Жизненный цикл контролируется Spring (@PostConstruct, @PreDestroy).

## Что_такое_IoC_и_в_чем_разница_между_Application_Context

IoC (Inversion of Control) — это принцип передачи управления созданием объектов контейнеру.
ApplicationContext — реализация IoC в Spring с расширенными функциями (AOP, события, i18n)., который:
1. Создает бины.
2. Внедряет зависимости.
3. Управляет их жизненным циклом.

Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами 
Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством 
контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и 
конфигурирование объектов путём связывания их между собой. Объекты, создаваемые контейнером, также называются 
управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций 
(начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов 
и предоставляющие информацию, необходимую для создания bean’ов.

Плюсы такого подхода:
1. отделение выполнения задачи от ее реализации;
2. легкое переключение между различными реализациями;
3. большая модульность программы;
4. более легкое тестирование программы путем изоляции компонента или проверки его зависимостей и обеспечения 
   взаимодействия компонентов через контракты.

Объекты могут быть получены одним из двух способов:
1. Dependency Lookup Поиск зависимости — шаблон проектирования, в котором вызывающий объект запрашивает у 
   объекта-контейнера экземпляр объекта с определённым именем или определённого типа.
2. Dependency Injection Внедрение зависимости — шаблон проектирования, в котором контейнер передает экземпляры объектов 
   по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

ApplicationContext — это расширенная версия BeanFactory, которая представляет собой IoC-контейнер Spring. Он не только 
управляет бинами и их зависимостями, но и предоставляет дополнительные функции:
1. Поддержка AOP (аспектно-ориентированного программирования).
2. Международализация (i18n).
3. Публикация и обработка событий (ApplicationEvent).
4. Интеграция с Spring Expression Language (SpEL).
5. Автоматическая регистрация BeanPostProcessor и BeanFactoryPostProcessor

## Что_такое_Dependency_Lookup_Поиск_зависимости

Dependency Lookup (поиск зависимостей) — это подход, при котором компонент явно запрашивает зависимости из контейнера, 
в отличие от Dependency Injection (где зависимости предоставляются автоматически). Это "ручной" способ получения 
бинов в Spring.

Способы реализации в Spring:
1. Через ApplicationContext
2. Через JNDI (в Java EE)
3. Через ServiceLocator (паттерн)

Проблемы подхода:
- Жесткая связь с контейнером
- Сложность тестирования (нужен реальный контекст)
- Нарушение принципа инверсии управления

## Что_такое_Dependency_Injection_Внедрение_зависимости

Шаблон проектирования в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора,
свойства или фабричного метода.

Dependency Inversion - инверсия зависимостей, тоесть попытки не делать жестких связей между вашими модулями\классами, 
где один класс зависит от другого, когда мы не сами создаем объект а берем его из Context Spring в котором он хранится.

Под DI понимают то Dependency Inversion (инверсию зависимостей, то есть попытки не делать жестких связей между вашими 
модулями/классами, где один класс напрямую завязан на другой)

Внедрение зависимости (Dependency injection, DI) — процесс, когда один объект реализует свой функционал через другой. 
Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению 
зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему 
зависимостей внешнему, специально предназначенному для этого общему механизму.

Реализация DI в Spring основана на двух ключевых концепциях Java — компонентах JavaBean и интерфейсах.

К типам реализации внедрения зависимостей в Spring относят:
1. Constructor Dependency Injection — это тип внедрения зависимостей, при котором зависимости компонента предоставляются 
   ему в его конструкторе(или конструкторах). Рекомендуется как основной способ, т.к. даже без спринга внедрение 
   зависимостей будет работать корректно.
2. Setter Dependency Injection — контейнер IoC внедряет зависимости компонента в компонент через методы установки в 
   стиле JavaBean. В основном через сеттеры. При модификации не создает новые экземпляры, в отличии от конструктора. 
   Он при каждой модификации создаёт новый экземпляр.

## Расскажите_про_связывание_с_Autowired

Аннотация служит для связывания бинов. Может использоваться над конструктором, полем, сеттер методом.
@Autowired(required=false) - означает что внедрение зависимости не обязательна.

## Расскажите_про_Spring_MVC

Spring MVC — это Фреймворк для веб-приложений по паттерну MVC. Основан на DispatcherServlet и аннотациях 
(@Controller, @RequestMapping). Поддерживает HTML (Thymeleaf) и REST (JSON/XML)

Жизненный цикл запроса:
1. Запрос приходит на DispatcherServlet
2. HandlerMapping определяет подходящий Controller
3. Controller обрабатывает запрос, возвращает ModelAndView
4. ViewResolver выбирает представление (JSP, Thymeleaf и т.д.)
5. View рендерится с данными из Model

Ответ отправляется клиенту

## Что_такое_HandlerMapping

HandlerMapping — это интерфейс в Spring MVC, который определяет какой Controller (или метод контроллера) 
должен обработать входящий HTTP-запрос на основе его URL, заголовков и других параметров. Это "маршрутизатор" 
запросов внутри фреймворка.

Основная задача HandlerMapping
Преобразует входящий запрос (HttpServletRequest) в соответствующий обработчик (Handler), которым может быть:
1. Метод @Controller с аннотацией @RequestMapping
2. Реализация интерфейса Controller (старый способ)
3. Другой HTTP-обработчик (например, для WebSocket)

Как работает RequestMappingHandlerMapping?
1. Сканирует все бины с @Controller и @RequestMapping
2. Строит таблицу соответствий:
3. URL → метод контроллера
4. HTTP-метод (GET/POST) → метод
5. Заголовки → метод
6. Параметры → метод
7. Выбирает наиболее точное совпадение при запросе

## Что_такое_HandlerAdapter

HandlerAdapter — это интерфейс в Spring MVC, который адаптирует различные типы обработчиков запросов к единому 
интерфейсу выполнения. Он действует как "переводчик" между DispatcherServlet и конкретными реализациями контроллеров.

Основная задача HandlerAdapter - Обеспечивает унифицированный способ вызова:
1. Аннотированных контроллеров (@Controller с @RequestMapping)
2. Старых реализаций интерфейса Controller (из Spring 1.x)
3. HTTP-сервлетов
4. Кастомных обработчиков

Как работает цепочка обработки?
1. DispatcherServlet получает запрос
2. HandlerMapping находит подходящий обработчик (Controller)
3. HandlerAdapter выбирается по принципу: forEach
4. Вызывается метод контроллера через подходящий адаптер

## Что_такое_Controller

Включен между моделью и представлением. Управляет процессом преобразования входящих запросов в ответы. 
Класс DispatcherServlet является главным контроллером который получает все запросы и распределяет их. 
@RequestMapping указывает какие именно запросы будут обработаны в конкретном контроллере. Каждый DispatcherServlet имеет 
собственную конфигурацию WebApplicationContext которая определяет характеристики уровня сервлета, отображение 
обработчиков, интернационализация, преобразование типов.
ContextLoaderListener - слушатель при старт и завершении корневого класса WebApplicationContext. Основным назначением 
является связывание жизненного цикла ApplicationContext и ServletContext, а так же автоматического создания 
ApplicationContext.

## Что_такое_ViewResolver

ViewResolver — это интерфейс в Spring MVC, который преобразует логические имена представлений (возвращаемые контроллерами)
в конкретные реализации View (JSP, Thymeleaf, JSON и др.). Это последний шаг в обработке запроса перед отправкой 
ответа клиенту.

Как работает ViewResolver?
1. Контроллер возвращает строку (логическое имя view) или ModelAndView
2. DispatcherServlet запрашивает у всех ViewResolver'ов
3. Первый подходящий ViewResolver создает объект View
4. View рендерит результат (HTML/JSON/PDF) в HttpServletResponse

## Что_такое_HandlerInterceptor

HandlerInterceptor — это механизм в Spring MVC для перехвата HTTP-запросов на разных этапах обработки. 
Он позволяет внедрять сквозную логику (cross-cutting concerns) без модификации контроллеров.
Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion.
1. preHandle — метод используется для обработки запросов, которые еще не были переданы в методы обработчика контроллера. 
   Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим 
   обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и 
   пересылать ошибки к представлению.
2. postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может 
   использоваться для добавления параметров в объект ModelAndView.
3. afterCompletion — вызывается после отрисовки представления.

Можно использовать для:
1. Аутентификация и авторизация
2. Логирование
3. Добавление общих атрибутов модели

Отличие от @Aspect:
- Интерцепторы работают на уровне HTTP-запросов
- Срезы (Aspect) — на уровне вызовов методов Java

Для создания обработчика необходимо расширить абстрактный класс HandlerInterceptorAdapter или реализовать интерфейс 
HandlerInterceptor. Так же нужно указать перехватчики в конфигурационном файле Spring.

## Что_такое_LocalResolver

LocaleResolver — это стратегия в Spring MVC, которая определяет текущую локаль (язык и регион) пользователя для 
поддержки интернационализации (i18n). Это ключевой компонент для многоязычных приложений.

Основное назначение:
1. Определяет локаль на основе запроса (Accept-Language, cookies, сессии и т.д.)
2. Позволяет показывать контент на разных языках
3. Интегрируется с механизмом сообщений (MessageSource)

Как работает выбор локали?
- Получение запроса от пользователя
- LocaleResolver определяет локаль:
- Из cookie (CookieLocaleResolver)
- Из сессии (SessionLocaleResolver)
- Из заголовка (AcceptHeaderLocaleResolver)

Spring использует локаль для:
- Форматирования дат/чисел
- Выбора файлов сообщений (messages_ru.properties)
- Локализации представлений (Thymeleaf, JSP)

## Что_такое_MultipartResolver

MultipartResolver — это интерфейс в Spring MVC, который обрабатывает HTTP-запросы с файлами (multipart/form-data). 
Это ключевой компонент для функциональности загрузки файлов в веб-приложениях.
Обеспечивает Upload — загрузку на сервер локальных файлов клиента. По умолчанию этот интерфейс не включается в 
приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться 
этому интерфейсу.

Основное назначение
- Преобразует multipart/form-data запросы в удобный для работы формат:
- Разбирает входящий запрос на части (файлы + обычные поля формы)
- Предоставляет доступ к файлам через MultipartFile
- Управляет временным хранением загруженных файлов

## Расскажите_про_шаблон_проектирования_Front_Controller

Паттерн обеспечивает единую точку входа всех входящих запросов. Все запросы обрабатываются и делегируются другим объектам 
приложения. Он так же может выступать как интерфейс для общего поведения, такого как безопасность, интернационализация, 
передача определенных данных определенным пользователям.
В Spring в качестве Front Controller выступает DispatcherServlet. Каждый DispatcherServlet имеет свой дочерний контекст 
приложения. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб приложение может иметь 
несколько DispatcherServlet каждый из которых будет в своем пространстве имен с собственным WebApplicationContext. 

Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet по сути является сервлетом
(он расширяет HttpServlet), основной целью которого является обработка входящих веб запросов, соответствующих 
настроенному шаблону URL. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб-приложение 
может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве 
имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д. Например, когда нам 
нужно в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST-контроллеры.

WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет 
дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у.

ContextLoaderListener создает корневой контекст приложения (на рисунке - Root WebApplicationContext) и будет 
использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet. Напомню, что корневой контекст 
приложения будет общим и может быть только один. Root WebApplicationContext содержит компоненты, которые видны всем 
дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д.

## Что_такое_DispatcherServlet_и_из_каких_частей_состоит

Класс DispatcherServlet является главным контроллером, которые получает запросы и распределяет их между другими 
контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может 
быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского 
интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext, 
которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение 
обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование 
типов и форматирование и т.п.

ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным 
назначением является связывание жизненного цикла ApplicationContext и ServletContext, а так же автоматического создания 
ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов Spring. 
Настраивается в web.xml

1. Сопоставление обработчиков. То есть обработчик запросов.
2. Контроллер.
3. View resolver - принимает и отображает модели из контроллера.

## Расскажите_про_WebApplicationContext_и_DispatcherServlet

Каждый DispatcherServlet имеет свой дочерний контекст приложения. Он принимает входящий URI и находит правильную 
комбинацию контроллера и вида. Веб приложение может иметь несколько DispatcherServlet каждый из которых будет в своем 
пространстве имен с собственным WebApplicationContext. WebApplicationContext расширяет ApplicationContext 
(создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), 
через который у него есть возможность получать доступ к ServletContext-у. ContextLoaderListener создает корневой 
контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.

## В_чем_отличие_между_ContextLoaderListener_и_DispatcherServlet

1. ContextLoaderListener создает корневой контекст приложения.
2. Каждый DispatcherServlet создаёт себе один дочерний контекст.
3. Дочерние контексты могут обращаться к бинам, определенным в корневом контексте.
4. Бины в корневом контексте не могут получить доступ к бинам в дочерних контекстах (напрямую).
5. Все контексты добавляются в ServletContext.
6. Мы можем получить доступ к корневому контексту, используя класс WebApplicationContextUtils.

## Как_работает_Filters

Задача фильтров это перехватывать запросы либо к сервлету либо ответы от сервлета. Фильтрация происходит в методе 
doFilter(). Каждый фильтр имеет доступ к объекту FilterConfig из которого он получает параметры инициализации и ссылку 
на ServletContext, который может использовать например загрузки ресурсов или других параметров для задачи фильтрации. 
Фильтров может быть несколько создавая цепочку фильтров и сервер выбирает какой фильтр выбрать в зависимости от 
порядке регистрации. Когда вызывается метод 
`doFilter(ServletRequest request, ServletResponse response, FilterChain chain)` 
то веб сервер создает объект FilterChain предоставляя ему цепочку фильтров.

## Как_работает_Listeners

Listeners (Слушатели) в Spring MVC — это компоненты, которые реагируют на события жизненного цикла приложения 
и HTTP-сессий. Они реализуют паттерн наблюдателя и позволяют выполнять код в ответ на ключевые события фреймворка и 
сервлет-контейнера.
Класс который реализует ServletContextListener. Он инициализируется один раз при запуске веб приложения. Он отрабатывает 
только тогда когда происходит заданное условие, перехватывает данный запрос и запускает свою логику. Чтобы его создать 
необходимо указать аннотацию @WebListener

Основные типы:
- ServletContextListener — старт/остановка приложения
- HttpSessionListener — управление сессиями
- ApplicationListener — кастомные события Spring

Регистрируются через:
- web.xml (для Servlet API)
- Аннотации @Component + @EventListener (в Spring Boot)

## Как_работает_Interceptors

Это интерфейс предназначенный для аспектно ориентированного программирования. Перед тем как запрос попадает в контроллер 
он может пройти через перехватчики Interceptor. Его можно использовать для записи в лог или обновления конфигурации. 
Interceptors основан на механизме Reflection. Они так же могут обращаться к объектам в контейнере Spring.
Перехватить можно в трех местах preHandle, postHandle и afterCompletion.
1. preHandle - метод используется для обработки запросов которые еще не были переданы в метод обработки контроллера. 
   Передает дальше в handler method
2. postHandle - вызывается после handler method но до обработки DispatcherServlet для передачи представлению.
3. afterCompletion - вызывается после отрисовки представления.

## Какая_разница_между_Filter_Listener_Interceptors

1. Filter - Это интерфейс из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути 
   запроса к ресурсу(сервлету, либо по статическому контенту), либо по пути ответа от ресурса, либо в обоих направлениях. 
   Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он 
   может получить параметры инициализации, и ссылку на ServletContext, который он может использовать, например, для 
   загрузки ресурсов, необходимых для задач фильтрации. Фильтры настраиваются в дескрипторе развертывания веб-приложения. 
   В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает,
   какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров. Когда вызывается метод 
   doFilter(ServletRequest request, ServletResponse response, FilterChain chain) первого фильтра, веб-сервер создает 
   объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.

2. Listener (Слушатель) - это класс, который реализует интерфейс javax.servlet.ServletContextListener. Он 
   инициализируется только один раз при запуске веб приложения и уничтожается при остановке веб-приложения. Слушатель 
   сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. 
   Например, мы хотим инициализировать пул соединений с базой данных до запуска веб-приложения. ServletContextListener - 
   это то, что нам нужно, он будет запускать наш код до запуска веб-приложения.

Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в 
веб-приложении. Все ServletContextListeners уведомляются об уничтожении контекста после того, как все сервлеты и 
фильтры уничтожены. Чтобы создать свой Listener нам достаточно создать класс, имплементирующий интерфейс 
ServletContextListener и поставить над ним аннотацию @WebListener

3. Interceptor - Это интерфейс из пакета org.aopalliance.intercept, предназначенный для аспектно-ориентированного 
   программирования. В Spring, когда запрос отправляется в Controller, перед тем как он в него попадёт, он может пройти 
   через перехватчики Interceptor (0 или более). Это одна из реализаций АОП в Spring. Вы можете использовать Interceptor
   для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос 
   обработается Controller-ом. Стек перехватчиков: он предназначен для связывания перехватчиков в цепочку в 
   определенном порядке. При доступе к перехваченному методу или полю перехватчик в цепочке перехватчиков вызывается 
   в том порядке, в котором он был определен. Следует знать, что HandlerInterceptor связан с бином 
   DefaultAnnotationHandlerMapping, который отвечает за применение перехватчиков к любому классу, помеченному аннотацией 
   @Controller.

Filter vs. Interceptor:
1. Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции.
2. Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него.
3. Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми 
   запросами (например, js, .css и т.д.).
4. Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный 
   функционал.

## Что_делает_аннотация_ModelAttribute

@ModelAttribute — это аннотация Spring MVC, которая связывает параметры HTTP-запроса (формы, query-параметры) с 
объектами модели для использования в контроллерах и представлениях. Это ключевой инструмент для работы с данными форм 
в Spring.

Используется для:
- Обработки HTML-форм
- Предзаполнения модели
- Валидации данных

## Расскажите_про_исключения_в_Spring_MVC

В Spring MVC интерфейс HandlerExceptionResolver (из пакета org.springframework.web.servlet) предназначен для работы с 
непредвиденными исключениями, возникающими во время выполнения обработчиков. По умолчанию DispatcherServlet регистрирует 
класс DefaultHandlerExceptionResolver(из пакета org.springframework.web.servlet.mvc.support). Этот распознаватель 
обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также 
реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации @ExceptionHandler и 
передав ей в качестве атрибута тип исключения.

В общем случае обработку исключений можно описать таким образом:
1. @ExceptionHandler - указать методы для обработки исключения в классе контроллере. Принимает в себя имя класса 
   обрабатываемого исключения (можно несколько).
2. @ControllerAdvice - для глобальной обработки ошибок в приложении Spring MVC. Ставится над классом-контроллером, 
   отлавливает все исключения с методов. Он также имеет полный контроль над телом ответа и кодом состояния.
3. HandlerExceptionResolver implementation – позволяет задать глобального обработчика исключений. Реализацию этого 
   интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.

## Что_делает_аннотация_ExceptionHandler

@ExceptionHandler - указать методы для обработки исключения в классе контроллера. Принимает в себя имя класса 
обрабатываемого исключения

## Что_делает_аннотация_ControllerAdvice

@ControllerAdvice — это аннотация Spring, которая позволяет централизованно обрабатывать исключения, добавлять 
глобальные атрибуты модели или выполнять пред-/постобработку запросов для всех контроллеров в приложении.

@ControllerAdvice используется для:
1. Глобальной обработки исключений – через @ExceptionHandler
2. Добавления общих атрибутов модели – через @ModelAttribute.

## Что_делает_HandlerExceptionResolver

HandlerExceptionResolver - позволяет задать глобального обработчика исключений. Реализация этого интерфейса можно 
использовать для создания собственных глобальных обработчиков исключений

Когда использовать?
- HandlerExceptionResolver: если нужен полный контроль над обработкой (например, кастомные HTTP-заголовки, 
  интеграция со старым кодом).
- @ControllerAdvice: для стандартных REST-приложений, где удобство важнее тонкой настройки.

## Из_каких_частей_состоит_Spring_MVC

1. DispatcherServlet - управляет всеми http запросами.
2. WebApplicationContext- расширение ApplicationContext.
3. Controller - Компонент в составке DispatcherServlet

## Какие_реализации_IoC_существуют

Основные реализации в Java:
- Spring IoC (наиболее популярный, на основе ApplicationContext и аннотаций)
- Google Guice (легковесный, основан на Java-конфигурациях)
- CDI (Contexts and Dependency Injection) (стандарт Java EE/Jakarta EE, например, в WildFly, Payara)
- Hand-made IoC (самописные контейнеры, например, через Factory или Service Locator)

## За_счет_чего_делается_локализация_в_Spring_MVC

Локализация осуществляется за счет:
1. Создается файл resource bundle в котором указаны варианты локализированной информации.
2. Определяется messageSource в конфигурации Spring используя классы ResourceBundleMessageSource или 
   ResourceBundleMessageSource
3. Определить localeResolver класса CookieLocaleResolve для включения возможности переключения локали.
4. С помощью элемента spring:message DispatcherServlet будут определяться в каком месте необходимо вставлять 
   локализированное сообщение в ответе.

## Расскажите_про_CommandLineRunner_и_ApplicationRunner

Интерфейсы используются для запуски логики при запуске приложения после создания контекста Spring. Отличие между ними 
состоит в том что CommandLineRunner.run() принимает String array[], тогда как ApplicationRunner.run() принимает 
ApplicationArguments в качестве аргумента. Можно запускать несколько CommandLineRunner одновременно, например чтобы 
распаралелить сложную логику. Управлять их порядком через @Order. Каждый Runner может иметь свои собственные зависимости

## Какие_паттерны_применяются_в_Spring

1. Chain of Responsibility - это поведенческий паттерн проектирования, который позволяет передавать запросы 
   последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и 
   стоит ли передавать запрос дальше по цепи. Ему Spring Security
2. Model View Controller - Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами.
   Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя 
   представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при 
   различных вариантах представления.
3. Front Controller - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен 
   вашим контроллерам. Паттерн Front Controller используется для обеспечения централизованного механизма обработки 
   запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, 
   авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.
   View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.
4. Dependency injection и Inversion of control - IoC-контейнер в Spring, отвечает за создание объекта,
   связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного 
   уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления 
   компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).
5. Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость 
   "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и 
   обновлялись автоматически.
6. Proxy (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты 
   перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
7. Factory (Фабрика) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять 
   тип создаваемых объектов.

## Расскажите_про_паттерн_Chain_of_Responsibility

Chain of Responsibility — это поведенческий паттерн, который позволяет передавать запрос по цепочке обработчиков, 
пока один из них не обработает его. Основная идея — избежать жесткой привязки отправителя запроса к получателю, 
давая нескольким объектам шанс обработать запрос.

Структура паттерна:
1. Handler (Интерфейс/Абстрактный класс)
   - Определяет метод для обработки запроса (например, handleRequest()).
   - Может содержать ссылку на следующий обработчик (nextHandler).
2. ConcreteHandler (Конкретные обработчики)
   - Реализуют логику обработки. Если не могут обработать — передают дальше.
3. Client (Клиент)
   - Формирует цепочку и запускает запрос с первого обработчика.

Что спросят дальше:
1. Как избежать "потери" запроса?
   Добавить обработчик по умолчанию в конец цепочки.
2. Можно ли сделать двунаправленную цепочку?
   Да, но это усложнит код (паттерн обычно однонаправленный).

## Расскажите_про_паттерн_Dependency_Injection_и_Inversion_of_control

IoC — это принцип, при котором управление созданием и связыванием объектов передается внешнему контейнеру 
(фреймворку), а не реализуется внутри класса.

DI — это частный случай IoC, при котором зависимости объекта (сервисы, репозитории)не создаются внутри класса, 
а внедряются извне (через конструктор, сеттер или поле).

- Как IoC/DI реализованы в Spring?
IoC-контейнер Spring управляет бинами (объектами) через ApplicationContext.

- DI реализуется через аннотации:
@Component, @Service, @Repository — помечают класс как бин.
@Autowired — внедряет зависимость.

## Рассскажите_про_паттерн_Observer_Observable_Наблюдатель

Observer — это поведенческий паттерн, который позволяет объектам (наблюдателям) подписываться на события другого объекта 
(субъекта) и автоматически получать уведомления об изменениях его состояния.

Что спросят дальше?
Как избежать утечек памяти?
Всегда удалять наблюдателей через removeObserver().

Как сделать асинхронные уведомления?
Использовать ExecutorService или реактивные стримы.

Чем заменить Observable в новых проектах?
Spring Events, PropertyChangeSupport, или кастомная реализация.

## Расскажите_про_паттерн_Proxy_Заместитель

Позволяет подставлять вместо реальных объектов его proxy. Эти объекты перехватывают вызовы к оригинальному объекту 
позволяя вносить доп.функциональность до вызова метода.

Виды Proxy (примеры в Java):
1. Виртуальный прокси (Virtual Proxy) – откладывает создание объекта до момента его использования (например, 
   загрузка тяжёлого изображения).
2. Защищающий прокси (Protection Proxy) – проверяет права доступа перед вызовом реального объекта.
3. Удалённый прокси (Remote Proxy) – обеспечивает взаимодействие с объектом в другом адресном пространстве 
   (например, через сеть).
4. Кеширующий прокси (Cache Proxy) – сохраняет результаты запросов для ускорения работы.

## Расскажите_про_AOP

Это парадигма программирования позволяя реализовывать модульность. АОП позволяет отделять сложную реализацию на модули 
и вклинивать в необходимы места кода данную функциональность. Тоесть обеспечивая сквозную логику. Подход заключается 
в создании динамических прокси для целевых объектов и привязывания объектов к конфигурированному совету для выполнения 
сквозной логики. AOP - взаимодополняющие технологии, которые позволяют решать сложные проблемы путем разделения 
функционала на отдельные модули. АОП предоставляет возможность реализации сквозной логики - т.е. логики, которая 
применяется к множеству частей приложения - в одном месте и обеспечения автоматического применения этой логики по всему 
приложению. Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" 
объектов к конфигурированному совету для выполнения сквозной логики. С помощью АОП мы можем прописать, например, что 
будет выполняться до или после какого-то действия. Прописываем это один раз и этот функционал будет работать везде.
Например нам нужно сделать логирование во всех методах @Service, с ООП нам бы пришлось прописывать этот функционал в 
каждом методе для всех @Service. А с АОП мы можем в конфигах прописать для @Service что будет происходить с каждым 
вызовом его методов, - в нашем случае писать логи. Элементы АОП такие как аспекты также используются в транзакциях 
спринга.

## В_чем_разница_между_Сквозной_фукциональностью_и_АОП

Сквозная функциональность это функционал который необходим нам на разных уровнях, это может быть как логирование 
безопасность и т.д. а АОП - один из подходов реализации данного функционала

Application context - это реализация IoC. которая управляет бинами и зависимостями.

## Для_чего_необходим_Аспект

Аспект в AOP нужен для выноса сквозной функциональности (вроде логирования или транзакций) в отдельный модуль. 
Это устраняет дублирование кода и упрощает поддержку. Например, в Spring мы можем создать аспект с аннотацией @Aspect, 
где совет @Before будет логировать вызовы методов сервиса. Таким образом, бизнес-код остаётся чистым, а 
вся вспомогательная логика управляется централизованно.

Pointcut определяет "где" (какие методы перехватывать).
Advice определяет "что делать" в этих точках.
Aspect — это модуль, объединяющий Advice и Pointcut.

Аспект решает 3 основные проблемы:
1. Устранение дублирования кода
2. Разделение ответственности
3. Гибкость и удобство поддержки

Примеры сквозной функциональности:
1. Логирования (@Loggable)
2. Транзакций (@Transactional)
3. Кеширования (@Cacheable)
4. Безопасности (@Secured, @PreAuthorize)
5. Метрики и мониторинг (замер времени выполнения методов)

## Для_чего_необходим_Join_point

Join Point в AOP — это точка в выполнении программы, где может быть применён аспект, например, вызов метода или 
обработка исключения. Он нужен, чтобы точно указать, в каких местах должна срабатывать дополнительная логика 
(логирование, транзакции и т.д.). В Spring AOP чаще всего работают с Join Point'ами, связанными с выполнением методов.
Для выбора нужных точек используется Pointcut — выражение, которое фильтрует Join Point'ы 
(например, execution(* com.example.service.*.*(..))). Без Join Point'ов AOP не знал бы, куда 'вплетать' аспекты, 
поэтому это ключевая концепция.

Без Join Point'ов AOP не сможет определить, где применять логику.
Грамотное использование Pointcut'ов позволяет избежать "лишних" срабатываний аспектов.

Join Point — это конкретное событие в программе (например, вызов метода userService.save()).
Pointcut — это выражение, которое выбирает нужные Join Point'ы (например, "все публичные методы в пакете service").

## Для_чего_необходим_Совет_Advice

Advice — это код, который выполняется в определенных точках (join points) программы для добавления сквозной 
функциональности (cross-cutting concerns), такой как логирование, транзакции, безопасность и кэширование.

Pointcut определяет "где" (какие методы перехватывать).
Advice определяет "что делать" в этих точках.
Aspect — это модуль, объединяющий Advice и Pointcut.

## Для_чего_необходим_Pointcut_Срез

Срезом называется несколько объединенных точек (Join point) в которых должен быть выполнен совет (Advice)

Pointcut определяет "где" (какие методы перехватывать).
Advice определяет "что делать" в этих точках.
Aspect — это модуль, объединяющий Advice и Pointcut.

## В_чем_отличие_Spring_AOP_и_AspectJ

AspectJ является стандартом реализации AOP.
Отличия:
1. Spring AOP немного проще, т.к. нет необходимости следить за процессом связывания.
2. Spring AOP поддерживает аннотации AspectJ.
3. Недостатком Spring AOP является работа только со своими бинами, которые существуют в Spring Context.

Spring AOP – если нужны простые аспекты (логирование, транзакции) и проект уже на Spring.
AspectJ – если требуется высокая производительность или сложные pointcuts (например, перехват приватных методов).

## Как_создать_аннотацию

Чтобы создать кастомную аннотацию в Spring, нужно:
1. Объявить аннотацию с помощью @interface.
`
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomLog {
    String value() default "";
}
`
2. Обработка аннотации
   - Вариант 1: Через Spring AOP (рекомендуется для логирования, транзакций и т.д.)
   - Вариант 2: Через BeanPostProcessor (если нужно кастомизировать создание бинов)
3. Использование аннотации

@Target(ElementType....) 
 - TYPE — для классов, интерфейсов, enum'ов и записей (records)
 - FIELD — для полей класса
 - METHOD — для методов
 - PARAMETER — для параметров метода
 - ANNOTATION_TYPE — для создания мета-аннотаций

Как сделать аннотацию, которую можно ставить и на класс, и на метод?
→ @Target({ElementType.TYPE, ElementType.METHOD})

@Retention(RetentionPolicy......)
 - RetentionPolicy.SOURCE
   - Аннотация сохраняется только в исходном коде и не попадает в скомпилированный .class файл.
   - Используется для инструментов обработки исходного кода (например, @Override, @SuppressWarnings).
 - RetentionPolicy.CLASS
   - Аннотация сохраняется в .class файле, но не загружается в JVM во время выполнения.
   - Используется для инструментов байт-кода (например, Lombok).
 - RetentionPolicy.RUNTIME
   - Аннотация сохраняется в .class файле и доступна во время выполнения через Reflection.
   - Используется для аннотаций, которые должны обрабатываться в рантайме (например, @Entity, @Test).

SOURCE → Только для анализа кода (например, @Override).
CLASS → Для обработки байт-кода (например, Lombok).
RUNTIME → Для Reflection и обработки в рантайме (например, Spring, JUnit).

## Расскажите_про_частые_аннотации_Spring

1. @Requred - применяется к методам-сеттерам и означает, что значение метода должно быть установлено в XML-файле. 
   Если этого не будет сделано, то мы получим BeanInitializationException.
2. @RequestMapping - используется для мапинга (связывания) с URL для всего класса или для конкретного метода обработчика.
3. @ResponseBody - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.
4. @ResponseEntity - используется для формирования ответа HTTP с пользовательскими параметрами 
   (заголовки, http-код и т.д.). ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему 
   статус ответа. Во всех остальных случаях будем использовать @ResponseBody.
5. @PathVariable - задает динамический маппинг значений из URI внутри аргументов метода обработчика, т.е. позволяет 
   вводить в URI переменную пути в качестве параметра.

## Что_делает_аннотация_RequestMapping

@RequestMapping связывает HTTP-запросы с методами Java-класса, определяя URL, метод запроса и другие параметры.
Основные атрибуты: "Можно задавать path, method, consumes/produces, headers."
Пример: "Например, @RequestMapping(value="/users", method=GET) обрабатывает GET-запросы по пути /users

## Что_делает_аннотация_ResponseBody

@ResponseBody - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.

## Что_делает_аннотация_ResponseEntity

@ResponseEntity - используется для формирования ответа HTTP с пользовательскими параметрами (заголовки, http-код и т.д.). 
ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных 
случаях будем использовать @ResponseBody.

## Что_делает_аннотация_PathVariable

@PathVariable - задает динамический маппинг значений из URI внутри аргументов метода обработчика, т.е. позволяет вводить 
в URI переменную пути в качестве параметра

## В_чем_различия_между_аннотациями_Controller_и_RestController

@Controller - Классический контроллер в Spring MVC, который возвращает имя представления (View) для отрисовки 
HTML-страницы.
@RestController - Специализированная версия @Controller, предназначенная для REST API. Все методы по умолчанию 
возвращают данные в формате JSON/XML, а не имя представления.
@RestController = @Controller + @ResponseBody

@Controller → Если приложение рендерит HTML (например, интернет-магазин с фронтом на Thymeleaf).
@RestController → Если backend отдаёт только данные (REST API для SPA, мобильных приложений).

## Для_чего_необходима_аннотация_Profile

Аннотация позволяет сопоставить bean-компонент с конкретным профилем. Тоесть мы можем задать профиль dev и потом 
настроить чтобы данный бин был доступен только в контейнере dev
Используя аннотацию @Profile - мы сопоставляем bean-компонент с этим конкретным профилем; аннотация просто берет имена 
одного (или нескольких) профилей. Отвечает за то - какие бины буду создаваться, в зависимости от профайла. 
Фактически реализована с помощью гораздо более гибкой аннотации @Conditional. Рассмотрим базовый сценарий - у нас есть 
компонент, который должен быть активным только во время разработки, но не должен использоваться в производстве. Мы 
аннотируем этот компонент с профилем «dev», и он будет присутствовать в контейнере только во время разработки - в 
производственном процессе dev просто не будет активен. Или можно задать @Profile("postgres") и @Profile("mysql"), а 
в application.properties указать, бин с каким профилем использовать = spring.profiles.active = mysql

## Для_чего_необходима_аннотация_Lookup

Позволяет в синглетон бин внедрить прототип бин. Тоесть позволяет в синглетон бин внедрить зависимость на бин который 
будет прототипом тоесть при обращении каждый раз будет создаваться новый бин прототип в одном единственном синглетоне.
к примеру пассажир в машине. машина одна пассажиров много

## Для_чего_необходима_аннотация_и_какие_свойства_имеет_Target

@Target - указывается, какой элемент программы будет использоваться аннотацией
Свойства:
1. PACKAGE - назначением является целый пакет (package);
2. TYPE - класс, интерфейс, enum или другая аннотация:
3. METHOD - метод класса, но не конструктор (для конструкторов есть отдельный тип CONSTRUCTOR);
4. PARAMETER - параметр метода;
5. CONSTRUCTOR - конструктор;
6. FIELD - поля-свойства класса;

## Для_чего_необходима_аннотация_и_какие_свойства_имеет_Retention

@Retention - указываем, в какой момент жизни программного кода будет доступна аннотация
Свойства:
1. SOURCE - аннотация доступна только в исходном коде и сбрасывается во время создания .class файла;
2. CLASS - аннотация хранится в .class файле, но недоступна во время выполнения программы;
3. RUNTIME - аннотация хранится в .class файле и доступна во время выполнения программы.

## Для_чего_необходима_аннотация_Resource

@Resource (java) пытается получить зависимость: по имени, по типу, затем по описанию. Имя извлекается из имени 
аннотируемого сеттера или поля, либо берется из параметра name.
Java-аннотация @Resource может применяться к классам, полям и методам.
Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным 
именем, и в контейнере должен быть бин с таким именем:
`@Resource(name="namedFile")
private File defaultFile;`
Разница с @Autowired:
1. Ищет бин сначала по имени, а потом по типу;
2. Не нужна дополнительная аннотация для указания имени конкретного бина;
3. @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);
4. При замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно

## Для_чего_необходима_аннотация_Inject

Размещается над полями, методами, и конструкторами с аргументами. @Inject как и @Autowired в первую очередь пытается 
подключить зависимость по типу, затем по описанию и только потом по имени.  Это означает, что даже если имя переменной 
ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена:
`
@Inject
private ArbitraryDependency fieldInjectDependency;
//fieldInjectDependency - отличается от имени компонента, настроенного в контексте приложения:

@Bean
public ArbitraryDependency injectDependency() {
ArbitraryDependency injectDependency = new ArbitraryDependency();
return injectDependency;
}
`

## Для_чего_необходима_аннотация_Conditional

Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия 
соответствуют. Условия проверяются непосредственно перед тем, как должно быть зарегистрировано BeanDefinition компонента
Условия мы определяем в специально создаваемых нами классах, которые должны имплементировать функциональный интерфейс 
Condition с одним единственным методом, возвращающим true или false
`boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)`
Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan,
связанные с этим классом, также будут распространяться указанные условия.

## Какие_типы_Propagation_есть_в_транзакциях

1. REQUIRED (по умолчанию) — если есть транзакция, используется она, иначе создаётся новая.
2. REQUIRES_NEW — всегда создаёт новую транзакцию, приостанавливая текущую.
3. SUPPORTS — работает в транзакции, если она есть, но не создаёт новую.
4. NOT_SUPPORTED — приостанавливает текущую транзакцию, если она есть.
5. MANDATORY — требует активной транзакции, иначе — исключение.
6. NEVER — запрещает транзакцию, иначе — исключение.
7. NESTED — вложенная транзакция (поддерживается не всеми БД, например, работает в MySQL с InnoDB).

## Как_управлять_транзакциями_в_Spring

Spring поддерживает два типа управления транзакциями:
1. Программное управление транзакциями: Транзакции управляются с помощью программирования. 
   Используется TransactionTemplate, либо через реализацию PlatformTransactionManager напрямую. Используется, если нужно 
   работать с небольшим количеством транзакций.
2. Декларативное управление транзакциями: Вы отделяете управление транзакциями от бизнес-логики. Вы используете только 
   аннотации @Transactional и конфигурацией на основе XML для управления транзакциями. Наиболее предпочтительный способ.

## Все_про_транзакции

Аннотация сама по себе определяет область действия одной транзакции БД. Транзакция БД происходит внутри области действий 
persistence context. Persistence контекстом в JPA является EntityManager, который использует внутри класс Session 
ORM-фреймворка Hibernate(при использовании Hibernate как persistence провайдера). Persistence контекст это 
объект-синхронайзер, который отслеживает состояния ограниченного набора Java объектов и синхронизирует изменения 
состояний этих объектов с состоянием соответствующих записей в БД.

Один объект Entity Manager не всегда соответствует одной транзакции БД. Один объект Entity Manager может быть использован 
несколькими транзакциями БД. Самый частый случай такого использования - когда приложение использует шаблон 
«Open Session in View» для предотвращения исключений «ленивой» инициализации. В этом случае запросы, которые могли быть 
выполнены одной транзакцией при вызове из слоя сервиса, выполняются в отдельных транзакциях в слое View, но они 
совершаются через один и тот же Entity Manager.

При этом @PersistenceContext не может внедрить entity manager напрямую. Entity Manager это интерфейс, и то что внедряется
в бин не является самим по себе entity менеджером, это context aware proxy, который будет делегировать к конкретному 
entity менеджеру в рантайме.

Но прокси persistence контекста, которое имлементирует EntityManager не является достаточным набором компонентов для 
осуществления декларативного управления транзакциями. На самом деле нужно три компонента:
1. Прокси Entity менеджера
2. Аспект транзакций
3. Менеджер транзакций

Аспект транзакций — «around» аспект, который вызывается и до и после выполнения аннотированного бизнес метода. 
Конкретный класс для имплементации этого аспекта это TransactionInterceptor.

Аспект транзакций имеет две главные функции:
1. В момент «до» аспект определяет выполнить ли выполняемый метод в пределах уже сущестувующей транзакции БД или должна 
   стартовать новая отдельная транзакция. В момент «до» аспект сам не содержит логики по принятию решения, решение 
   начать новую транзакцию, если это нужно, делегируется Transaction менеджеру.
2. В момент «после» аспект решает что делать с транзакцией, делать коммит, откат или оставить незакрытой.

Transaction менеджер Менеджер транзакций должен предоствить ответ на два вопроса: Должен ли создаться новый 
Entity Manager? Должна ли стартовать новая транзакция БД?

Ответы необходимы предоставить в момент когда вызывается логика аспекта транзакций в момент «до». Менеджер транзакций 
принимает решение, основываясь на следующих фактах: выполняется ли хоть одна транзакция в текущий момент; нет ли 
атрибута «propagation» у метода, аннотированного @Transactional (для примера, REQUIRES_NEW всегда стартует новую 
транзакцию).

Если менеджер решил создать новую транзакцию, тогда: Создается новый entity менеджер
«Привязка» entity менеджера к текущему потоку (Thread)
«Взятие» соединения из пула соединений БД
«Привязка» соединения к текущему потоку

И entity менеджер и это соединение привязываются к текущему потоку, используя переменные ThreadLocal. Они хранятся в 
потоке, пока выполняется транзакция, и затем передаются менеджеру транзакций для очистки, когда они уже будут не нужны. 
Любая часть программы, которой нужен текущий entity manager или соединение, может заполучить их из потока. Этим 
компонентом программы, который делает именно так является Entity Manager Proxy.

EntityManager proxy ПКогда бизнес метод делает вызов, например, entityManager.persist(), этот вызов не вызывается 
напрямую у entity менеджера. Вместо этого бизнес метод вызывает прокси, который достает текущий entity менеджер из 
потока, в который его положил менеджер транзакций.

Как использовать:
1. В файле конфигурации нужно определить менеджер транзакций transactionManager для DataSource.
`<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource">
</property></bean>`
2. Включить поддержку аннотаций, добавив запись в контекстном xml файле вашего spring-приложения ИЛИ добавьте 
   @EnableTransactionManagement в ваш конфигурационный файл
3. Добавить аннотацию @Transactional в класс (метод класса) или интерфейс (метод интерфейса).

У @Transactional есть ряд параметров:
1. @Transactional (isolation=Isolation.READ_COMMITTED) - уровень изоляции.
2. @Transactional(timeout=60) - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной 
   системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение 
   об откате не отвечающих транзакций.
3. @Transactional(propagation=Propagation.REQUIRED_NEW) - (Если не указано, распространяющееся поведение по умолчанию — 
   REQUIRED.)

Когда вызывается метод с @Transactional происходит особая уличная магия: proxy, который создал Spring, создаёт 
persistence context(или соединение с базой), открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения 
(натурально, в ThreadLocal). По мере надобности всё сохранённое достаётся и внедряется в бины. Привязка транзакций к 
нитям (threads) позволяет использовать семантику серверов приложений J2EE, в которой гарантируется, что каждый запрос 
получает свою собственную нить.

Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, 
которые будут взаимодействовать друг с другом согласно уровням изоляции. Но что произойдёт, если один метод с 
@Transactional вызовет другой метод с @Transactional? В Spring можно задать несколько вариантов поведения, которые 
называются правилами распространения.

1. REQUIRES - При входе в @Transactional метод будет использована уже существующая транзакция или создана новая 
   транзакция, если никакой ещё нет
2. REQUIRES_NEW - Транзакция всегда создаётся при входе метод с Propagation.REQUIRES_NEW, ранее созданные транзакции 
   приостанавливаются до момента возврата из метода.
3. NESTED — корректно работает только с базами данных, которые умеют savepoints (Postgres в том числе). Savepoints — 
   транзакции внутри транзакций. Savepoint позволяет сохранить какое-либо состояние внутри транзакции и, при 
   необходимости, откатиться к нему, не откатывая всю транзакцию. При входе в метод в уже существующей транзакции 
   создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, 
   внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. Если текущей транзакции не существует, 
   будет создана новая.
4. MANDATORY - обратный по отношению к REQUIRES_NEW: всегда используется существующая транзакция и кидается исключение, 
   если текущей транзакции нет.
5. SUPPORTS - метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без 
   транзакции, если её нет. Методы, которые извлекают данные, являются лучшими кандидатами для этой опции.
6. NOT_SUPPORTED - При входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться 
   без транзакции. В основном те методы, которые выполняются в транзакции, но выполняют операции с оперативной памятью, 
   являются лучшими кандидатами для этой опции.
7. NEVER - явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, 
   будет выброшено исключение. Этот вариант в большинстве случаев не используется в проектах.

1. @Transactional (rollbackFor=Exception.class) - Значение по умолчанию: rollbackFor=RunTimeException.class В Spring все 
   классы API бросают RuntimeException, это означает, что если какой-либо метод не выполняется, контейнер всегда 
   откатывает текущую транзакцию. Проблема заключается только в проверенных исключениях - при них транзакция пройдет в 
   БД даже при ошибке. С этим параметром проверяемые исключения тоже будут откатываться при ошибке
2. @Transactional (noRollbackFor=IllegalStateException.class) - Указывает, что откат не должен происходить, если целевой 
   метод вызывает это исключение. Если внутри метода с @Transactional есть другой метод с аннотацией @Transactional 
   (вложенная транзакция), то отработает только первая (в которую вложенна). Из-за особенностей создания proxy. Но у 
   аннотации @Transactional можно указать параметры.

Куда же ставить @Transactional? Классическое приложение обычно имеет многослойную архитектуру:
контроллеры > слой логики > слой доступа к данным > слой ORM

Где здесь место для @Transactional? Слой ORM обычно никто не пишет сам и использует какое-либо стандартное решение, в 
которое аннотации не вставишь.

Слой доступа к данным обычно представляет собой набор классов, методы которых реализуют тот или иной запрос. Получается, 
что если каждый метод аннотировать @Transactional, то, с одной стороны, работать это конечно будет, а с другой стороны 
теряется смысл транзакций, как логического объединения нескольких запросов в одну единицу работы. Ведь в таком случае у 
каждого метода, то есть у каждого запроса, будет своя, собственная, транзакция.

Слой логики представляется идеальным местом для @Transactional: именно здесь набор запросов к базе оформляется в единую 
осмысленную операцию в приложении. Зная, что делает ваше приложение, вы можете четко разграничить логические единицы 
работы в нём и расставить границы транзакций.

Слой контроллеров тоже может быть неплохим местом для @Transactional, но у него есть два недостатка, по сравнению со 
слоем логики. Во первых он взаимодействует с пользователем, напрямую или через сеть, что может делать транзакции 
длиннее: метод будет ждать отправки данных или реакции пользователя и в этом время продолжать удерживать транзакцию и 
связанные с ней блокировки. Во вторых это нарушает принцип разделения ответственности: код, который должен быть 
ответственен за интерфейс с внешним миром, становится ответственен и за часть управления логикой приложения.

И последнее — никогда не аннотируйте интерфейсы. Аннотации не наследуются и поэтому, в зависимости от настроек Spring, 
вы можете внезапно оказаться фактически без своих @Transactional

## Для_чего_необходима_аннотация_EnableTransactionManager

Аннотация @EnableTransactionManagement означает, что классы, помеченные @Transactional, должны быть обернуты аспектом 
транзакций. @EnableTransactionManagement отвечает за регистрацию необходимых компонентов Spring, таких как 
TransactionInterceptor и советы прокси(proxy advices- набор инструкций, выполняемых на точках среза - Pointcut). 
Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional.
Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой 
аннотацией). Прокси-объекты позволяют Spring Framework вводить транзакционную логику до и после вызываемого метода -
главным образом для запуска и коммита/отката транзакции.

Если мы разместим аннотацию @Transactional над классом @Service, то все его методы станут транзакционными. Так, при 
вызове, например, метода save() произойдет примерно следующее:
Вначале мы имеем:
1. класс TransactionInterceptor, у которого основной метод invoke(...), внутри которого вызывается метод класса-родителя 
   TransactionAspectSupport:invokeWithinTransaction(...), в рамках которого происходит магия транзакций.
2. TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.
3. EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является 
   реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю 
   EntityManager и делегировать 
4. выполнение конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом 
   SharedEntityManagerInvocationHandler.

Transaction Interceptor
В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в 
пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция. TransactionInterceptor сам не 
содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager. 
Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после

## Для_чего_необходима_и_как_работает_аннотация_Transaction

Механизм работы
1. Проксирование:
   - Spring создает прокси-объект вокруг класса, помеченного @Transactional (или его методов)
   - Когда вызывается метод, вызов сначала перехватывается прокси
2. Управление транзакцией:
   - Перед выполнением метода прокси:
     - Получает/создает транзакцию через PlatformTransactionManager
     - Устанавливает уровень изоляции, таймаут и другие параметры
   - После выполнения метода:
     - Если метод завершился успешно - коммитит транзакцию
     - Если было исключение - откатывает транзакцию

Основные участники:
1. TransactionInterceptor: перехватывает вызовы методов
2. TransactionAspectSupport: основная логика управления транзакциями
3. PlatformTransactionManager: абстракция для работы с конкретными менеджерами транзакций

## Что_такое_TransactionInterceptor

В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() 
в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция. TransactionInterceptor сам 
не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager.
Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после:

## Для_чего_необходим_TransactionManager

TransactionManager в Spring - это центральная абстракция для управления транзакциями, которая обеспечивает:
- Единый интерфейс для работы с различными системами транзакций (JDBC, JPA, JTA и др.)
- Согласованное поведение транзакций across different transaction APIs
- Поддержку декларативного управления транзакциями через @Transactional

## Что_такое_Аспект_транзакций_и_какие_есть_функции

Аспект транзакций — «around» аспект, который вызывается и до и после выполнения аннотированного бизнес метода. 
Конкретный класс для имплементации этого аспекта это TransactionInterceptor.

Аспект транзакций имеет две главные функции:
1. В момент «до» аспект определяет выполнить ли выполняемый метод в пределах уже сущестувующей транзакции БД или должна 
   стартовать новая отдельная транзакция. В момент «до» аспект сам не содержит логики по принятию решения, решение 
   начать новую транзакцию, если это нужно, делегируется Transaction менеджеру.
2. В момент «после» аспект решает что делать с транзакцией, делать коммит, откат или оставить незакрытой.

## Какие_есть_параметры_изоляции_у_аннотации_Transaction

1. Isolation.DEFAULT
   - Использует уровень изоляции по умолчанию для СУБД
   - Когда использовать: когда хотите полагаться на настройки БД
2. Isolation.READ_UNCOMMITTED
   - Самый низкий уровень изоляции
   - Позволяет читать "грязные" данные (незакоммиченные изменения)
   - Проблемы: dirty reads, non-repeatable reads, phantom reads
   - Когда использовать: крайне редко, для операций где важна только скорость
3. Isolation.READ_COMMITTED (наиболее распространенный)
   - Гарантирует, что читаются только закоммиченные данные
   - Проблемы: non-repeatable reads, phantom reads
   - Когда использовать: по умолчанию для большинства операций
4. Isolation.REPEATABLE_READ
   - Гарантирует, что повторные чтения в одной транзакции возвращают одинаковые данные
   - Проблемы: phantom reads
   - Когда использовать: когда важна согласованность данных при повторных чтениях
5. Isolation.SERIALIZABLE
   - Самый строгий уровень
   - Полная изоляция, как если бы транзакции выполнялись последовательно
   - Проблемы: снижение производительности
   - Когда использовать: для критически важных операций

Влияние на блокировки:
SERIALIZABLE обычно использует range locks
READ_COMMITTED часто использует shared locks

## Что_произойдет_если_один_метод_Transaction_вызовет_другой_метод_Transaction

Проблема самовызовов (self-invocation)
Суть проблемы:
"В Spring транзакции (и другие аспекты AOP) работают через прокси-объекты. Когда метод класса вызывает другой 
метод того же класса напрямую, минуя прокси, аннотации @Transactional (и другие AOP-аспекты) не применяются."
Способы решения
1. Вынос метода в отдельный сервис
2. Использование самовнедрения (self-injection)
   @Autowired
   private MyService self;
3. Использование ApplicationContext

Решения проблемы
1. Использование AopContext.currentProxy()
`  @Service
   public class OrderService {

    public void placeOrder(Order order) {
      // Получаем текущий прокси-объект
      OrderService proxy = (OrderService) AopContext.currentProxy();
      proxy.validateOrder(order); // Теперь транзакция работает
    }

    @Transactional
    public void validateOrder(Order order) {
      // проверка заказа
    }
   }
`

## Зачем_необходим_PreparedStatementCreator

PreparedStatement - нужен для защиты от SQL-инъекций в запросах, а PreparedStatementCreator - для создания возврата 
PreparedStatement из connection. При этом он автоматически обрабатывает все исключения (кроме SQLExeption).
PreparedStatementCreator - это callback-интерфейс в Spring JDBC, который позволяет:
- Получить полный контроль над созданием PreparedStatement
- Установить параметры запроса перед выполнением
- Работать с особенностями конкретных JDBC-драйверов"


## В_чем_отличие_между_SOAP_и_REST

SOAP – это целое семейство протоколов и стандартов, для обмена структурированными сообщениями. Это более тяжеловесный и 
сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.
REST - это не протокол и не стандарт, а архитектурный стиль. У этого стиля есть свои принципы:

## Для_чего_необходима_нам_Spring_Data

Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, 
извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без
имплементации. Для работы с Spring Data JPA нам надо создать два beans-компонента: EntityManagerFactory и 
JpaTransactionManager. Поэтому создадим другой конфигурационный класс JpaConfig:
`
@Configuration
@EnableJpaRepositories(basePackages = {"net.codejava.customer"})
@EnableTransactionManagement
public class JpaConfig {

    @Bean
    public LocalEntityManagerFactoryBean entityManagerFactory() {
      LocalEntityManagerFactoryBean factoryBean = new LocalEntityManagerFactoryBean();
      factoryBean.setPersistenceUnitName("SalesDB");
      return factoryBean;
    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);

        return transactionManager;
    }
}
`
@EnableJpaRepositories: сообщает Spring Data JPA, что нужно искать классы репозитория в указанном пакете (net.codejava) 
для внедрения соответсвующего кода во время выполнения.
@EnableTransactionManagement: сообщает Spring Data JPA, чтобы тот генерировал код для управления транзакциями во время 
выполнения.

## Что_делает_аннотация_EnableJpaRepository

@EnableJpaRepositories: сообщает Spring Data JPA, что нужно искать классы репозитория в указанном пакете (net.codejava) 
для внедрения соответствующего кода во время выполнения.

Параметры настройки:
- basePackages - пакеты для сканирования репозиториев
- entityManagerFactoryRef - кастомный EntityManagerFactory
- transactionManagerRef - специфичный TransactionManager
- repositoryBaseClass - базовая реализация для кастомных репозиториев

## Что_такое_Spring_Boot

По сути, Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же их 
можно создать руками, просто Boot это автоматизирует. При этом помогая решить проблему конфликтов разных версий
компонентов. Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние 
зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых 
starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)
Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. 
Это позволит получить универсальное решение для всех, связанных со Spring технологий, избавляя программиста от лишнего 
поиска примеров кода и загрузки из них требуемых дескрипторов зависимостей. Например, если вы хотите начать использовать 
Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa и 
все будет готово (вам не придется искать совместимые драйверы баз данных и библиотеки Hibernate)

В основе "магии" Spring Boot нет ничего магического, он использует совершенно базовые понятия из Spring Framework. 
В кратком виде процесс можно описать так:
1. Аннотация @SpringBootApplication включает сканирование компонентов и авто-конфигурацию через аннотацию
   @EnableAutoConfiguration
2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector
3. EnableAutoConfigurationImportSelector загружает список конфигураций из файла META-INF/spring.factories
4. Каждая конфигурация пытается сконфигурить различные аспекты приложения (web, JPA, AMQP etc), регистрируя нужные бины 
   и используя различные условия (наличие / отсутствие бина, настройки, класса и т.п.)
5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска 
   embedded servlet container
6. Servlet container запускается, приложение готово к работе!

Важное понятие Spring Boot это автоконфигурация. По сути, это просто набор конфигурационных классов, которые создают и 
регистрируют определенные бины в приложении. По большому счету, даже сам Embedded Servlet Container — это просто еще 
один бин, который можно сконфигурировать! 

Пара важных моментов, которые важно знать об автоконфигурации:
1. Включается аннотацией @EnableAutoConfiguration
2. Работает в последнюю очередь, после регистрации пользовательских бинов
3. Принимает решения о конфигурации на основании доступных в classpath классов, свойств в application.properties и т.п.
4. Можно включать и выключать разные аспекты автоконфигурации, и применять ее частично (например, только MySQL + JPA, 
   но не веб)
5. Всегда отдает приоритет пользовательским бинам. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация 
   не будет его перекрывать

## Как_происходит_автоконфигурация_Spring_boot

Как происходит автоконфигурация в Spring Boot:
1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе:@SpringBootConfiguration, 
   @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование 
   компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это 
   Spring Boot приложение.
2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, 
   а использует так называемые фабрики.
3. Класс EnableAutoConfigurationImportSelector смотрит в файл META-INF/spring.factories и загружает оттуда список 
   значений, которые являются именами классов (авто)конфигураций, которые Spring Boot импортирует. Т.е. аннотация 
   @EnableAutoConfiguration просто импортирует ВСЕ (более 150) перечисленные в spring.factories конфигурации, 
   чтобы предоставить нужные бины в контекст приложения.
4. Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения(web, JPA, AMQP и т.д.), 
   регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, 
   чтобы бин создавался при наличии класса в classpath(@ConditionalOnClass), наличии существующего бина 
   (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, 
   что бин будет создан, и в большинстве случаев конфигурация ничего делать и создавать не будет.
5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска 
   embedded servlet container.
6. Servlet container запускается, приложение готово к работе!

## Что_такое_внедрение_зависимостей

Это подход в котором объекты получают извне свои зависимости. Реализуется через Application Context который отвечает 
за создание и внедрение зависимостей.

## В_чем_разница_внедрения_через_поля_и_через_конструктор

Внедрение через поле может привести к циклической зависимости и поля не могут быть final.

## В_чем_отличие_RestTemplate_и_JDBCTemplate

Класс RestTemplate является центральным инструментом для выполнения клиентских HTTP-операций в Spring. Он предоставляет 
несколько утилитных методов для создания HTTP-запросов и обработки ответов.

JdbcTemplate - базовый класс, который управляет обработкой всех событий и связями с БД посредством sql запросов. При 
этом все пишется программистом, не автоматизированно.

## Что_такое_Socket

Класс для двунаправленное соединением между клиентом и сервером. Например пользователь чатится с другим пользователем, 
сокет обрабатывает эти сообщения. Отвечает за создание соединения и пересылку данных.

## Что_такое_RESTful_какие_основные_принципы

REST (Representational State Transfer) - это архитектурный стиль, который используется для разработки распределенных систем. 
RESTful - это подход к проектированию веб-сервисов, который следует принципам REST.

RESTful веб-сервисы основаны на протоколе HTTP и используют его методы (GET, POST, PUT, DELETE) для взаимодействия с 
ресурсами. Они также используют уникальные идентификаторы ресурсов (URL) для доступа к ним.

Основные принципы REST / RESTful:

1. Client-Server (Клиент-Сервер): Взаимодействие между клиентом и сервером осуществляется через стандартизированный интерфейс.
2. Stateless (Без сохранения состояния): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для 
   его обработки. Сервер не должен сохранять состояние между запросами.
3. Cacheable (Кэшируемость): Ответы сервера могут быть кэшированы на стороне клиента для повторного использования.
4. Uniform Interface (Единый интерфейс): Интерфейс взаимодействия должен быть однородным и простым для понимания.
5. Layered System (Слоистая система): Серверы могут быть разделены на слои, чтобы обеспечить масштабируемость и безопасность.

Отличие REST от RPC и SOAP:
1 REST – использует HTTP-методы и ресурсы.
2. RPC (например, gRPC) – вызывает удалённые процедуры.
3. SOAP – основан на XML и строгих контрактах (WSDL).

## Какая_польза_от_аннотации_WebMvcTest_в_приложениях_Spring_MVC

WebMvcTest - это аннотация в Spring MVC, которая предназначена для тестирования контроллеров веб-приложений. Она позволяет 
создавать юнит-тесты для контроллеров, без необходимости запуска всего веб-приложения. Аннотация WebMvcTest автоматически 
настраивает только необходимые компоненты, связанные с веб-слоем, такие как контроллеры, обработчики и представления.

Польза от аннотаций WebMvcTest в приложениях Spring MVC заключается в следующем:
1. Ускорение тестирования: Использование аннотации WebMvcTest позволяет проводить тестирование контроллеров без 
   необходимости запуска всего веб-приложения. Это значительно сокращает время выполнения тестов и ускоряет процесс 
   разработки.
2. Изоляция тестов: Аннотация WebMvcTest автоматически настраивает только необходимые компоненты, связанные с веб-слоем. 
   Это позволяет изолировать тесты контроллеров от других компонентов приложения, таких как сервисы или база данных. 
   Такая изоляция облегчает обнаружение и исправление ошибок.
3. Удобство настройки: Аннотация WebMvcTest автоматически настраивает необходимые зависимости и бины для тестирования 
   контроллеров. Это упрощает процесс настройки тестов и позволяет сосредоточиться на проверке функциональности контроллеров.
4. Повышение надежности: Тестирование контроллеров с использованием аннотации WebMvcTest помогает обнаруживать ошибки и 
   проблемы взаимодействия между компонентами веб-слоя. Это позволяет повысить надежность приложения и улучшить качество кода.

## Какие_существуют_типы_тестирования_микросервисов

1. Юнит-тестирование: это тестирование, которое проверяет отдельные компоненты микросервисов, такие как функции или классы. 
   Оно позволяет проверить, что каждая часть работает правильно в изоляции.
2. Интеграционное тестирование: этот тип тестирования проверяет взаимодействие между различными микросервисами. Он позволяет 
   убедиться, что микросервисы взаимодействуют друг с другом корректно и передают правильные данные.
3. Тестирование производительности: это тестирование, которое проверяет, как микросервисы работают под нагрузкой. Оно 
   позволяет оценить производительность системы и выявить возможные узкие места.
4. Тестирование безопасности: этот тип тестирования направлен на проверку безопасности микросервисов. Оно помогает выявить 
   уязвимости и обеспечить защиту от возможных атак.
5. Тестирование восстановления после сбоев: это тестирование, которое проверяет, как микросервисы восстанавливаются после 
   сбоев или ошибок. Оно позволяет убедиться, что система может быстро восстановиться и продолжать работать без проблем
