-[JRE_JVM_JDK](#JRE_JVM_JDK) <br/>
-[ООП](#ООП)
-[JPA_ORM](#JPA_ORM)
-[Транзакции](#Транзакции)
-[Entity](#Entity)
-[AOP](#AOP)
-[Паттерны](#Паттерны)
-[Параметры_для_аннотаций](#Параметры_для_аннотаций)
-[Виды_функциональных_интерфейсов](#Виды_функциональных_интерфейсов)
-[Коллекции_скорость](#Коллекции_скорость)
-[Коллекции_виды](#Коллекции_виды)
-[Docker](#Docker)
-[CAP](#CAP)
-[Kubernetes](#Kubernetes)
-[Reddis](#Reddis)

## ООП
1. Инкапсуляция - позволяет скрыть детали реализации объекта (данные и методы) в классе от пользователя предоставив только то
   что необходимо при использовании. Тоесть пользователь не должен вникать во внутреннюю реализацию класса а лишь использовать
   те классы которые открыты или описаны в интерфейсе.
2. Наследование - позволяет создавать новые классы на основе уже существующих, добавляя при необходимости новые свойства и
   методы.(допустим есть телефон который умеет звонить а от него наследуются разные операторы которые добавляют к логике
   звонить еще свою)
3. Полиморфизм - позволяет объектам с одинаковым интерфейсом иметь различную реализацию.
   (к примеру метод который имеет printLn а уже каждый класс определяет что необходимо напечатать) (динамический,статический)
4. Абстракция

Ассоциация - объекты двух классов могут ссылаться один на другой, имея связь друг с другом.
(Типы: один к одному, Многие ко многим)
агрегация - ассоциация со слабой связью. односторонняя связь с одноправленным отношением. (Пример: двигатель и автомобиль)
композиция - это ассоциация с сильной связью. Когда класс владеет объектом и несет ответственность за его время жизни.
(сотрудник и роль)

## JRE_JVM_JDK
JRE,JVM,JDK
1. JRE - пакет для запуска Java (включает в себя JVM, библиотеки классов)
2. JVM - выполняет Java-байткод
3. JDK - включает в себя всё необходимое для разработки (javac,библиотеки)

## JPA_ORM
JPA - это стандартный Java-интерфейс для ORM, который описывает, как объекты Java должны сохраняться в реляционной
базе данных. Это не реализация, а спецификация.
ORM — это технология для работы с БД через объекты в Java. Я чаще всего использую Hibernate,
так как он реализует JPA и снижает объем шаблонного кода.
EntityManager – это легковесный объект, который выполняет CRUD-операции с Entity и управляет их жизненным циклом.
Criteria - Используется для создания и выполнения объекто-ориентированных запроса на получение объектов.
PersistenceContext — это контейнер (или "кэш первого уровня"), который управляет жизненным циклом сущностей (Entity)
в рамках одной транзакции или сессии.
Триггер (Trigger) — это специальная хранимая процедура в базе данных, которая автоматически выполняется при наступлении
определенного события

## Entity
Методы операций над Entity:
1. persist (добавление Entity под управление JPA)
2. merge (обновление)
3. remove (удаления)
4. refresh (обновление данных)
5. detach (удаление из управление JPA)
6. lock (блокирование Enity от изменений в других thread).

Жизненный цикл Entity:
1. new - объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
2. managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи.
3. detached — объект был создан, но не управляется (или больше не управляется) JPA.
4. removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.

## Транзакции
У @Transactional есть ряд параметров:
1. @Transactional (isolation=Isolation.READ_COMMITTED) - уровень изоляции.
2. @Transactional(timeout=60) - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной
   системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение
   об откате не отвечающих транзакций.
3. @Transactional(propagation=Propagation.REQUIRED_NEW) - (Если не указано, распространяющееся поведение по умолчанию —
   REQUIRED.)

2 типа управления транзакции:
1. програмное - Используется TransactionTemplate, либо через реализацию PlatformTransactionManager напрямую.
2. декларативное - Отделяется управление транзакциями от бизнес-логики. Мы используем только
   аннотации @Transactional и конфигурацией на основе XML для управления транзакциями

Типы Propagation (пропагнации) в транзакциях:
1. REQUIRED (по умолчанию) — если есть транзакция, используется она, иначе создаётся новая.
2. REQUIRES_NEW — всегда создаёт новую транзакцию, приостанавливая текущую.
3. SUPPORTS — работает в транзакции, если она есть, но не создаёт новую.
4. NOT_SUPPORTED — приостанавливает текущую транзакцию, если она есть.
5. MANDATORY — требует активной транзакции, иначе — исключение.
6. NEVER — запрещает транзакцию, иначе — исключение.
7. NESTED — вложенная транзакция (поддерживается не всеми БД, например, работает в MySQL с InnoDB).

Уровни изоляции транзакций:
1. TRANSACTION_NONE – драйвер не поддерживает транзакции;
2. TRANSACTION_READ_UNCOMMITTED – транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены.
   не спасает не от чего.
3. TRANSACTION_READ_COMMITTED – транзакция может читать только те изменения в других параллельных транзакциях,
   которые уже были закоммичены.
   Это нас спасает от грязного чтения но не спасает от неповторяющегося чтения и от фантомного чтения.
4. TRANSACTION_REPEATABLE_READ – пока транзакция не завершится, никто параллельно не может изменять или удалять строки,
   которые транзакция уже прочитала.
   Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения.
5. TRANSACTION_SERIALIZABLE – блокирует любые действия, пока запущена транзакция.

Грязное чтение - когда данные, которые я прочитал, кто-то может откатить ещё до того, как я завершу свою транзакцию.
Неповторяющееся чтение - я могу дважды прочитать одни и те же строки в одной транзакции в разное время и получить разный результат.
Фантомное чтение - Данные которые я прочитал и когда в итоге я хочу закомитить свою транзакцию то кол-во строк данных отличается.

## AOP
Join Point — это точка в выполнении программы, где может быть применён аспект, например, вызов метода или
обработка исключения.
Advice — это код, который выполняется в определенных точках (join points) программы для добавления сквозной
функциональности.
Pointcut определяет "где" (какие методы перехватывать).
Advice определяет "что делать" в этих точках.
Aspect — это модуль, объединяющий Advice и Pointcut.

## Паттерны
L - Принцип подстановки Барбары Лисков - класс который наследовался от родителя не должен
ломать интерфейс. Допустим если мы наследовались от класс который не бросает Exception а я бросаю Exception то
родительский класс может этого не знать и у него будет не объяснимое поведение.
D - Принцип инверсии зависимостей - класс должен зависеть не от реализации а от абстракций. Тоесть класс должен быть написан 
так чтобы он зависел не от конкретной реализации а от интерфейса.(SQLDatabase)
Например, класс, который использует базу данных, должен зависеть от абстрактного интерфейса базы данных, а не от конкретной
реализации базы данных.

1. Порождающие - абстрагируют процесс создание экземпляра. Они позволяют сделать систему
   независимой от способа создания, композиции и представления объектов.
2. Структурные - определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его
   реализацию, позволяя облегчить разработку и оптимизировать программу.
3. Поведения - определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

Порождающие:
1. Абстрактная фабрика - представляет собой интерфейс для создания других классов.
2. Строитель (Builder) - представляет собой интерфейс для создания сложного объекта
3. Фабричный метод (Factory method) - Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой
   класс инстанцировать
4. Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через
   конструктор.
5. Одиночка (Singleton)

Структурные:
1. Адаптер - Позволяет несовместимым интерфейсам работать вместе.
2. Мост (Bridge) - позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. Есть интерфейс с методом, 
   мы его через конструктор можем передать в абстрактный класс без реализации методов а потом уже в классе в котором будем 
   реализовывать абстрактный класс
3. Компоновщик (Composite) - Объединяет объекты в древовидные структуры.
4. Декоратор (Decorator) - Динамически добавляет новую функциональность объекту. (когда класс реализует интерфейс, имплементит 
   его метод и добавляет дополнительные методы)
5. Фасад (Facade) - Предоставляет упрощенный интерфейс к сложной системе. (тоесть это реализован метод в котором находятся 
   множество взаимодействий с дочерними классами их вызов и логика)
6. Приспособленец (Flyweight) - Тоесть в классе есть метод который служит как фабрикой для создания классов.
7. Заместитель (Proxy)

Поведения:
1. Цепочка обязанностей (Chain of responsibility)
2. Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта
3. Наблюдатель (Observer) - Позволяет объектам уведомлять подписчиков об изменениях.
4. Стратегия (Strategy) - Инкапсулирует алгоритмы в отдельные классы, делая их взаимозаменяемыми. Тоесть Мы отделяем процедуру 
   выбора алгоритма от его конкретных реализаций.

Конкуренция — это способ одновременного решения множества задач.
Параллелизм — это способ выполнения разных частей одной задачи.
Процесс — экземпляр программы во время выполнения, независимый объект. Каждый процесс выполняется в отдельном адресном пространстве
Поток(thread) — способ выполнения процесса, определяющий последовательность исполнения кода в процессе.
Потоки всегда создаются в контексте какого-либо процесса

## Параметры_для_аннотаций
Аннотации:
@Target - указывается, какой элемент программы будет использоваться аннотацией
Свойства:
1. PACKAGE - назначением является целый пакет (package);
2. TYPE - класс, интерфейс, enum или другая аннотация:
3. METHOD - метод класса, но не конструктор (для конструкторов есть отдельный тип CONSTRUCTOR);
4. PARAMETER - параметр метода;
5. CONSTRUCTOR - конструктор;
6. FIELD - поля-свойства класса;

@Retention - указываем, в какой момент жизни программного кода будет доступна аннотация
Свойства:
1. SOURCE - аннотация доступна только в исходном коде и сбрасывается во время создания .class файла;
2. CLASS - аннотация хранится в .class файле, но недоступна во время выполнения программы;
3. RUNTIME - аннотация хранится в .class файле и доступна во время выполнения программы.

## Виды_функциональных_интерфейсов
Виды функциональных интерфейсов:
1. Function - принимает 1 аргумент и возвращает аргумент
2. Predicate - принимает 1 аргумент и возвращает true\false
3. Consumer - принимает 1 аргумент нечего не возвращает (void)
4. Supplier - нечего не принимает и возвращает аргумент

## Коллекции_скорость
       Скорость работы коллекций
List реализации
Коллекция	           Получение (get)	Добавление (add)	  Удаление (remove)	    Поиск (contains)
ArrayList	             O(1)	           O(1)* / O(n)	        O(n)	                 O(n)
LinkedList	           O(n)	           O(1)	                O(1)	                 O(n)
CopyOnWriteArrayList	 O(1)	           O(n)	                O(n)	                 O(n)
Set реализации
Коллекция	                            Добавление (add)	  Удаление (remove)	    Поиск (contains)
HashSet	                                O(1)	              O(1)	                 O(1)
LinkedHashSet	                          O(1)	              O(1)	                 O(1)
TreeSet	                                O(log n)	          O(log n)	             O(log n)
CopyOnWriteArraySet	                    O(n)	              O(n)	                 O(n)
Map реализации
Коллекция	           Получение (get)  Вставка (put)	  	   Удаление (remove)	  Поиск (containsKey)
HashMap	               O(1)	            O(1)	              O(1)                   O(1)
LinkedHashMap	         O(1)	            O(1)	              O(1)                   O(1)
TreeMap	               O(log n)	        O(log n)	          O(log n)	             O(log n)
ConcurrentHashMap	     O(1)	            O(1)	              O(1)                   O(1)
Hashtable	             O(1)	            O(1)	              O(1)                   O(1)
Queue/Deque реализации
Коллекция	                             Добавление (offer)	 Удаление (poll)	    Просмотр (peek)
ArrayDeque	                            O(1)	              O(1)	                 O(1)
PriorityQueue	                          O(log n)	          O(log n)	             O(1)
ConcurrentLinkedQueue	                  O(1)	              O(1)	                 O(1)

## Docker
Docker Image - Образ докера это как снимок экземпляра приложения который в себе содержит все необходимое для запуска.
Слой - это изменение файловой системы, которое возникает при выполнении каждой инструкции в Dockerfile.
Docker container - запущенный экземпляр образа.
Dockerfile — это текстовый файл с инструкциями для сборки Docker-образа.
Docker Machine — это утилита для автоматического развертывания Docker-хостов на различных платформах.
Docker Swarm — это встроенная в Docker система оркестрации контейнеров.

Dockerfile — это 'сборка' (как Maven для образа)
Compose — это 'оркестрация' (как дирижер для контейнеров)

Виртуализация — это абстрактная версия физической машины (Позволяет разработчикам запускать и размещать несколько ОС на
оборудовании одного физического сервера)

контейнеризация — это абстрактная версия приложения. (Помогает разработчикам развернуть несколько приложений с использованием
одной и той же операционной системы)

Пример минимального Dockerfile для Java:
FROM eclipse-temurin:17-jdk //Базовый образ с JDK
COPY target/my-app.jar /app.jar  //Добавление JAR-файла
CMD ["java", "-jar", "/app.jar"]  //Команда запуска

CNM (Container Network Model)
Внутри Docker Desktop есть несколько DNS-серверов.
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов.

docker system prune - Эта команда очищает неиспользуемые ресурсы Docker.
FROM - Задаёт базовый (родительский) образ.
ENV - Создаёт переменную окружения
COPY - Копирует файл с основной системы в контейнер (обеспечивает только базовую поддержку копирования локальных файлов в контейнер)
ADD - Копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или url
RUN - это 'сборка' (аналог фазы Maven package). Выполняет команду и создаёт слой образа
CMD - Задает аргументы по умолчанию для ENTRYPOINT
ARG - позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки.
ENTRYPOINT - это 'запуск' Определяет исполняемую команду (аналог main() в java)

## CAP
CAP теорема
CAP-теорема - это теорема, которая утверждает, что в распределенных компьютерных системах невозможно одновременно
обеспечить следующие три свойства (CAP): согласованность данных (Consistency), доступность системы (Availability)
и устойчивость к разделению сети (Partition tolerance).

Теорема утверждает, что в любой распределённой системе можно одновременно гарантировать только два из трёх свойств:
1. Consistency (Согласованность) - все узлы видят одни и те же данные в одно и то же время
2. Availability (Доступность) - система всегда возвращает ответ, даже если некоторые узлы недоступны
3. Partition tolerance (Устойчивость к разделению) - система продолжает работать при разрыве связи между узлами

В микросервисной архитектуре каждый сервис должен явно выбирать между:
- CP-системы (согласованность и устойчивость к разделению): например, сервисы обработки финансовых транзакций
- AP-системы (доступность и устойчивость к разделению): например, сервисы кеширования или каталогов товаров

## Kubernetes

1. Master-нода (Control Plane)
   Master — это "мозг" кластера Kubernetes. Он управляет всем кластером, принимает решения о развертывании,
   масштабировании и обеспечивает отказоустойчивость.
   Основные компоненты Master-ноды:
1. kube-apiserver
   - Что делает? Главный интерфейс для управления кластером.
   - Как работает? Принимает REST-запросы от пользователей (kubectl), валидирует их и обновляет состояние в etcd.
   - Пример: Когда ты запускаешь kubectl create deployment, запрос идёт именно сюда.
2. etcd
   - Что делает? Распределённое key-value хранилище, где хранится все состояние кластера (конфиги, секреты, метаданные).
   - Как работает? Работает по алгоритму консенсуса Raft (как в Consul). Если etcd падает — кластер становится неуправляемым.
3. kube-scheduler
   - Что делает? Решает, на какой Worker-ноде запускать под (Pod).
   - Как работает? Анализирует:
  - Достаточно ли на ноде CPU/RAM?
  - Есть ли ограничения (tolerations, node affinity)?
  - Какая нода менее загружена?
4. kube-controller-manager
   - Что делает? Следит за тем, чтобы текущее состояние кластера соответствовало желаемому (declarative approach).
   - Какие контроллеры внутри?
  - Deployment Controller – следит за репликами подов.
  - Node Controller – реагирует на отвалившиеся ноды.
  - Endpoint Controller – связывает сервисы и поды.

2. Worker-ноды
   Worker — это рабочие серверы, на которых фактически запускаются контейнеры.
   Основные компоненты Worker-ноды
1. kubelet
   - Что делает? "Агент" на Worker-ноде, который запускает и контролирует поды.
   - Как работает?
  - Получает команды от Master-ноды ("запусти под с таким-то образом").
  - Следит, чтобы контейнеры в подах были живы.
  - Отчитывается Master-ноде о состоянии ноды.
2. kube-proxy
   - Что делает? Обеспечивает сетевую коммуникацию между сервисами.
   - Как работает?
  - Настраивает правила iptables/IPVS для балансировки нагрузки.
  - Позволяет подам внутри кластера находить друг друга по DNS или ClusterIP.
3. Container Runtime
   - Что делает? Запускает контейнеры (например, Docker, containerd, CRI-O).
   - Как работает?
  - Получает от kubelet команду: "Запусти контейнер из образа nginx:latest".
  - Скачивает образ и запускает контейнер.

Как Master и Worker взаимодействуют?
- Ты отправляешь команду через kubectl → она попадает в kube-apiserver.
- kube-scheduler решает, на какой Worker-ноде запустить под.
- kubelet на Worker-ноде получает задание и запускает контейнер через Container Runtime.
- kube-proxy настраивает сетевые правила, чтобы под был доступен.
- Controller Manager следит, чтобы всё работало как задумано.

Sidecar — это архитектурный паттерн, при котором вспомогательный контейнер (sidecar) работает вместе с основным
контейнером в одном Pod, расширяя его функциональность без изменения кода основного приложения.

## Коллекции_виды
    Коллекции
PriorityQueue - это очередь с приоритетами, которая хранит элементы в отсортированном порядке. Основана на
двоичной мин-куче— это дерево, где каждый родитель меньше своих потомков.
- При вставке/удалении происходит перебалансировка кучи
- Элементы хранятся не в порядке добавления а по приоритету (по умолчанию — натуральный порядок или компаратор)
- Использует Comparator или естественный порядок (Comparable).

WeakHashMap - map, использует слабые ссылки (Weak References) для ключей
- Это позволяет сборщику мусора (GC) автоматически удалять записи, когда на ключи больше нет сильных ссылок

IdentityHashSet - Set, которая использует сравнение объектов по ссылке (==)

CopyOnWriteArrayList - это потокобезопасная реализация List

SortedMap — это интерфейс в Java, расширяющий Map, который гарантирует хранение элементов в отсортированном
порядке по ключам. Автоматическая сортировка ключей (по natural ordering или через Comparator)
Главное преимущество — сортировка и работа с диапазонами. Недостаток — производительность

TreeMap - реализована как красно-чёрное дерево, которая хранит элементы в отсортированном порядке по ключам,
что позволяет эффективно работать с диапазонами.
Она не использует хеширование, а организует данные в красно-чёрном дереве.
Сортировка ключей: по естественному порядку (Comparable) или через Comparator
Порядок итерации: элементы возвращаются в отсортированном порядке
- Новый элемент добавляется в дерево, как если бы TreeMap была обычным бинарным деревом поиска.
- Затем производится перебалансировка дерева с помощью поворотов и изменения цвета узлов.
- TreeMap автоматически упорядочивает элементы в соответствии с естественным порядком или с помощью компаратора

TreeSet - хранит элементы в отсортированном порядке с использованием красно-чёрного дерева.
Сортировка элементов: по natural order (Comparable) или через Comparator
Поддерживает элементы в отсортированном порядке
Главные ограничения — запрет null (без Comparator) и требование к элементам быть Comparable.

LinkedHashSet - Она сохраняет уникальность элементов как HashSet, но при этом поддерживает порядок вставки элементов
Это идеальный выбор, когда вам нужна высокая производительность HashSet с сохранением порядка вставки элементов.
Нужен для Удаление дубликатов без потери порядка

LinkedHashMap - сочетает возможности HashMap и LinkedList, сохраняя порядок элементов
Это идеальный выбор, когда вам нужен словарь с предсказуемым порядком итерации и быстрым доступом к элементам
Может работать в двух режимах: порядок вставки (по умолчанию) или порядок доступа (LRU), который делает последний
использованный элемент 'самым молодым'.

## Reddis

Типы данных reddis:
1. базовые - встроенные, нативные типы(они очень быстрые т.к. реализованы на языке C без внешних зависимостей)
   String, List, Set, Sorted Set, Hash, Stream, Bitmap, Bitfield, Geospatial, HyperLogLog.
2. модульные
   JSON, Time Series, Bloom Filter,Cuckoo Filter

Стратегии кэширования:
1. Cache-Aside(Lazy-loading)
2. Read-Through
3. Write-Through
4. Write-Behind
5. Full Page/Fragment Cache

Инвалидация кэша:
1. Time-based(TTL)
2. Explicit Invalidate
3. Versioning
4. Event-based
5. Write through/Write-behind
6. Cache Buster/Soft Invalidate
