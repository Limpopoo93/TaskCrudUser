-[3_принципа_ООП](#3_принципа_ООП) <br>
-[JRE_JVM_JDK](#JRE_JVM_JDK) <br>
-[Какие_типы_загрузчиков_класса_бывают](#Какие_типы_загрузчиков_класса_бывают) <br>
-[Мусор_JVM](#Мусор_JVM) <br>
-[Что_такое_ковариантность_типов](#Что_такое_ковариантность_типов) <br>
-[Условия_переопределения_equals](#Условия_переопределения_equals) <br>
-[Generics](#Generics) <br>
-[Что_такое_лямбда](#Что_такое_лямбда) <br>
-[Виды_функциональных_интерфейсов](#Виды_функциональных_интерфейсов) <br>
-[Коллекции_скорость](#Коллекции_скорость) <br>
-[Разница_Процесса_и_потока](#Разница_Процесса_и_потока) <br>
-[DeadLock_LiveLock_Starvation](#DeadLock_LiveLock_Starvation) <br>
-[Что_такое_happens_before_в_Java_Memory_Model](#Что_такое_happens_before_в_Java_Memory_Model) <br>
-[Разница_между_CountDownLatch_CyclicBarrier_Semaphore](#Разница_между_CountDownLatch_CyclicBarrier_Semaphore) <br>
-[Entity](#Entity) <br>
-[Транзакции](#Транзакции) <br>
-[AOP](#AOP) <br>
-[Параметры_для_аннотаций](#Параметры_для_аннотаций) <br>
-[Docker](#Docker) <br>
-[CAP](#CAP) <br>
-[Kubernetes](#Kubernetes) <br>
-[Reddis](#Reddis) <br>
-[GET_POST_PUT](#GET_POST_PUT) <br>
-[Кода_ошибок](#Кода_ошибок) <br>
-[Сертификат](#Сертификат) <br>
-[Протоколы](#Протоколы) <br>
-[Микросервисы](#Микросервисы) <br>
-[Паттерны](#Паттерны) <br>
-[Алгоритмы](#Алгоритмы) <br>

## 3_принципа_ООП

1. **Инкапсуляция** - позволяет скрыть детали реализации объекта (данные и методы) в классе от пользователя предоставив только то
   что необходимо при использовании. Тоесть пользователь не должен вникать во внутреннюю реализацию класса а лишь использовать
   те классы которые открыты или описаны в интерфейсе.
2. **Наследование** - позволяет создавать новые классы на основе уже существующих, добавляя при необходимости новые свойства и
   методы.(допустим есть телефон который умеет звонить а от него наследуются разные операторы которые добавляют к логике
   звонить еще свою)
3. **Полиморфизм** - позволяет объектам с одинаковым интерфейсом иметь различную реализацию.
   (к примеру метод который имеет printLn а уже каждый класс определяет что необходимо напечатать) (динамический,статический)

**Ассоциация** - объекты двух классов могут ссылаться один на другой, имея связь друг с другом.
(Типы: один к одному, Многие ко многим) <br>
**агрегация** - ассоциация со слабой связью. односторонняя связь с одноправленным отношением. (Пример: двигатель и автомобиль) <br>
**композиция** - это ассоциация с сильной связью. Когда класс владеет объектом и несет ответственность за его время жизни.
(сотрудник и роль)

**Интерфейс** — описывает что класс должен делать. <br>
**абстрактный класс** — как он это делает, частично реализуя логику. <br>
Интерфейс не может иметь реализации, поля только (public, static), можно реализовать много интерфейсов, есть дефолтные методы, нету конструктора. <br>
Абстрактный класс может содержать реализацию, можно создавать конструктор, любые поля, класс может только один абстрактный класс наследовать

## JRE_JVM_JDK
JRE,JVM,JDK
1. **JRE** - пакет для запуска Java (включает в себя JVM, библиотеки классов)
2. **JVM** - выполняет Java-байткод
3. **JDK** - включает в себя всё необходимое для разработки (javac,библиотеки)
   Отличие абстрактного класса от интерфейса

## Какие_типы_загрузчиков_класса_бывают

Когда JVM запускается, она создает три встроенных загрузчика классов:
1. **Bootstrap Classloader** - загружает стандартные библиотечные классы из папки JRE/lib.
2. **Extension Classloader** - загружает расширения Java из папки JRE/lib/ext.
3. **System Classloader** - загружает классы из переменной окружения CLASSPATH. Кроме того, в Java можно создавать
   пользовательские загрузчики классов, которые могут загружать классы из любых других источников, например, из базы
   данных или из сети.

## Мусор_JVM
Типы сборщиков мусора:
1. **Serial** - Использует один поток.
2. **Parallel** - Использует несколько потоков. (Работа со средними и большими наборами данных.)
3. **G1** - Выполняет некоторую тяжелую работу параллельно с работой приложения. (Куча делится на регионы одинакового размера,
   и эти регионы могут принадлежать либо молодому поколению, либо старому.)
4. **Z1** - Выполняет всю тяжелую работу параллельно с работой приложения. Низкая задержка. Управляемая задержка через параметр.
5. **ZGC** - новое решение в котором минимальная задержка (ZGC использует так называемые load barriers - Это высоко оптимизированный
   код, так что потоки приложения на Java будут работать практически незаметно, получая доступ к объекту)

## Существует_два_подхода_к_обнаружению_мусора

1. Reference Counting (подсчёт ссылок)
2. Tracing Garbage Collection (Tracing-подход)

## Что_такое_ковариантность_типов

**Ковариантность** — это сохранение иерархии наследования исходных типов в производных типах в том же порядке.
**ковариация** — это если бы мы могли переменной типа List<Animal> задать объект типа ArrayList<Dog>

**Контравариантность** — это обращение иерархии исходных типов на противоположную в производных типах.
Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>.

**Инвариантность** — ситуация, когда наследование исходных типов не переносится на производные.

## Условия_переопределения_equals
Условия переопределения equals:
1. Рефлексивность - a.equals(a) должно вернуть true. То есть объект всегда равен самому себе.
2. Симметричность - если a.equals(b) вернуло true, то и b.equals(a) должно вернуть true.
3. Транзитивность - если a.equals(b) и b.equals(c) вернули true, то и a.equals(c) должно вернуть true.
4. Консистентность - повторные вызовы метода equals() для одного объекта должны возвращать одинаковый результат

## Generics
**Generics** — это механизм параметризации типов, который позволяет создавать обобщённые классы, методы, интерфейсы <br>
Generics в Java реализованы через стирание типов (Type Erasure). <br> На этапе компиляции информация о generics удаляется,
и в байт-коде остаются только сырые типы <br>
Из-за этого в runtime нельзя: <br>
❌ Создать new T() (нет информации о T). <br>
❌ Проверить instanceof List<String> (можно только instanceof List). <br>
❌ Использовать примитивы (List<int> → нужно Integer).

## Что_такое_лямбда

**Лямбда-выражения** — это анонимные функции, которые позволяют кратко и удобно реализовывать методы интерфейсов
с одним абстрактным методом (функциональных интерфейсов).

## Виды_функциональных_интерфейсов
Виды функциональных интерфейсов:
1. **Function** - принимает 1 аргумент и возвращает аргумент
2. **Predicate** - принимает 1 аргумент и возвращает true\false
3. **Consumer** - принимает 1 аргумент нечего не возвращает (void)
4. **Supplier** - нечего не принимает и возвращает аргумент

**Comparable** — это интерфейс для естественного порядка сортировки (compareTo()) <br>
**Comparator** — это интерфейс для кастомной сортировки (compare())

## Коллекции_скорость
       Скорость работы коллекций
List реализации
Коллекция	           Получение (get)	Добавление (add)	  Удаление (remove)	    Поиск (contains)
ArrayList	             O(1)	           O(1)* / O(n)	        O(n)	                 O(n)
LinkedList	           O(n)	           O(1)	                O(1)	                 O(n)
CopyOnWriteArrayList	 O(1)	           O(n)	                O(n)	                 O(n)
Set реализации
Коллекция	                            Добавление (add)	  Удаление (remove)	    Поиск (contains)
HashSet	                                O(1)	              O(1)	                 O(1)
LinkedHashSet	                          O(1)	              O(1)	                 O(1)
TreeSet	                                O(log n)	          O(log n)	             O(log n)
CopyOnWriteArraySet	                    O(n)	              O(n)	                 O(n)
Map реализации
Коллекция	           Получение (get)  Вставка (put)	  	   Удаление (remove)	  Поиск (containsKey)
HashMap	               O(1)	            O(1)	              O(1)                   O(1)
LinkedHashMap	         O(1)	            O(1)	              O(1)                   O(1)
TreeMap	               O(log n)	        O(log n)	          O(log n)	             O(log n)
ConcurrentHashMap	     O(1)	            O(1)	              O(1)                   O(1)
Hashtable	             O(1)	            O(1)	              O(1)                   O(1)
Queue/Deque реализации
Коллекция	                             Добавление (offer)	 Удаление (poll)	    Просмотр (peek)
ArrayDeque	                            O(1)	              O(1)	                 O(1)
PriorityQueue	                          O(log n)	          O(log n)	             O(1)
ConcurrentLinkedQueue	                  O(1)	              O(1)	                 O(1)

## Коллекции_виды

**Коллекции**: Iterable -> Collection -> (List,Queue, Set) <br>
**List**: ArrayList, LinkedList, Vector -> Stack <br>
**Set**: HashSet, LinkedHashSet, SortedSet -> TreeSet, (IdentityHashSet - доп) <br>
**Queue**: PriorityQueue, Deque, LinkedList, ArrayDeque <br>

**Map**: HashMap, LinkedHashMap, SortedMap -> TreeMap, (WeakHashMap - доп) <br>

**Многопоточка**: CopyOnWriteArrayList, ConcurrentHashMap <br>

1. **ArrayList**
2. **LinkedList**
3. **Vector**: Старая коллекция. динамический массив типа ArrayList но синхронизирован и медленный.
4. **Stack**: LIFO. Структура данных стек, является подклассом Vector. Принцип работы LIFO. Потокобезопасен.<br>
   **методы:** push(добавляет), <br>
      pop(удаляети возвращает вершину), <br>
      peek(возвращает вершину), <br>
      empty(проверка), <br>
      search(поиск позиции элем.) <br>
   **используется:** Парсинг выражений (проверка скобок, HTML). Обратный порядок выполнения.

1. **HashSet**: уникальные элементы без гарантии порядка.<br>
    add в среднем O(1), в худшем при коллизиях 0(n).<br>
    remove\contain\size: O(1).<br>
2. **LinkedHashSet**: Хранит уникальные элементы с порядком их добавления. Высокопроизводительная. Удаление дубликатов без потери порядка.<br>
   add в среднем O(1), в худшем при коллизиях 0(n).<br>
   remove\contain\size: O(1).<br>
3. **SortedSet**: Реализацией является TreeSet. Элементы отсортированы. Предоставляет сортировку по естественном порядку (Comparable) или с помощью Comporator.<br>
  add/remove/contains: O(log n)<br>
  first/last: O(1)<br>
  методы: first/last/headSet(E elem) возвр.подмножество элем.строго меньше elem/tailSet(E elem) возвр.подмножество элем.больше или равно elem/subSet(E fromE, toE)возвр.подмножество в диапазоне/comparator<br>
4. **TreeSet**: Элементы отсортированы с использованием самобалансирующего красно-черного дерева. Используется для элементов в отсорт. порядке согласно естественном порядку comparable или компоратору,<br>
   Коллекция используется когда нужны диапазоны значений(headSet, tailSet), часто требуется first, last элем. <br>Запрет на null значения.<br>
  add/remove/contains O(log n)<br>
  first/last/size/isEmpty O(1)<br>
5. **IdentityHashSet**: сравнение элементов по == а не по equals(). порядок не гарантируется. Производительность как и у hashmap.

1. **PriorityQueue**: это очередь с приоритетами, которая хранит элементы в отсортированном порядке(по умолчанию — натуральный порядок или компаратор)а не в порядке добавления.<br>
   null элементы запрещены.<br> Использует Comparator или естественный порядок (Comparable).<br> Основана на двоичной мин-куче— это дерево, где каждый родитель меньше своих потомков.<br>
   PriorityQueue<Integer> pq = new PriorityQueue<>();<br>
   PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder()) - через Comparator<br>
   PriorityQueue<String> lengthQueue = new PriorityQueue<>((a, b) -> a.length() - b.length()); - С кастомным Comparator<br>
   offer/add/poll - O(log n)<br>
   remove/contains - O(n) (contains (поиск) - Поиск в куче требует полного обхода, так как нет гарантии порядка элементов (кроме корня))<br>
   peek/size - O(1)<br>
   методы: offer(E e)(добавляет элемент), poll(удаляет и возвращает голову), element(возвращает голову или exception), peek(возвращает голову или null)<br>
2. **Deque**: Добавление/удаление с обоих концов (головы и хвоста). Разрешены Null элементы.<br>
   Deque расширяет Queue и добавляет возможность вставки/удаления с обоих концов. Queue — только FIFO.<br>
   методы: addFirst, offerFirst(добавляет в начало или false), removeFirst, pollFirst(удаляет первый), getFirst(получает первый или exception), peekFirst(получает первый или null)<br>
   все операции: О(1)<br>
3. **ArrayDeque**: реализация Deque на основе массива. <br>Автоматическое расширение, может работать как стек и очередь одновременно.<br> Не поддерживает null.<br>
   addFirst\addLast\removeFirst\removeLast\peekFirst\size - O(1)<br>
   contains\iterator - O(n)<br>
   методы: addFirst/addLast. removeFirst\removeLast. peekFirst\peekLast. size\contains<br>

1. **HashMap**:<br>
  Добавление: О(1)<br>
  получение\удаление: в зависимости распределения хэш-функций(присутствуют ли коллизии). В идеале О(1), но может быть и О(n)<br>
2. **LinkedHashMap**: упорядоченная по добавлению хэш-таблица. Сохраняет порядок элементов. <br>Поддержка null значений.<br>
   put\get\remove\containsKey - O(1)<br>
3. **TreeMap**: реализована как красно-чёрное дерево, которая хранит элементы в отсортированном порядке сс использованием красно-черного дерева, что позволяет эффективно работать с диапазонами.<br>
  put\get\remove\containsKey -O(log n)<br>
  firstKey\lastKey - O(1)<br>
  Сортировка ключей: по естественному порядку (Comparable) или через Comparator<br>
  Порядок итерации: элементы возвращаются в отсортированном порядке<br>
  Новый элемент добавляется в дерево, как если бы TreeMap была обычным бинарным деревом поиска.<br>
  Затем производится перебалансировка дерева с помощью поворотов и изменения цвета узлов.<br>
  TreeMap автоматически упорядочивает элементы в соответствии с естественным порядком или с помощью компаратора <br>
4. **WeekHashMap**:

Set<T> t = new HashSet(); <br>
Set<T> t = new LinkedHashSet(); <br>
SortedSet<T> t = new TreeSet(); <br>
Set<T> t = new TreeSet(); <br>
Queue<T> t = new PriorityQueue(); <br>
Deque<T> t = new ArrayDeque(); <br>
Map<T,T> t = new TreeMap(); <br>
Map<T,T> t = new LinkedHashMap(); <br>

## Разница_Процесса_и_потока

**Процесс** - экземпляр выполняемой программы, а так же текущее значения команд, переменных. Для каждого процесса ОС выделяет свою
stack и heap память. Внутри которой работают потоки. <br>
**Поток** - основная единица которой операционная система выделяет время процессора. Тоесть внутри процесса у нас есть потоки.

## DeadLock_LiveLock_Starvation

**DeadLock** - ситуация когда 2 и более потока ждут бесконечно ресурс который занял другой поток. <br>
процесс1 захватил ресурс1 и ждет ресурс2 <br>
процесс2 захватил ресурс2 и ждет ресурс1 <br>
**Livelock** - система занимается бесполезной работой (не в режиме блокировки) состояние системы постоянно меняется но тем не менее она зациклилась и не производит полезную работу. <br>
процесс1 приходит к общему ресурс и спрашивает процесс2 работает? если да то он говорит я подожду пока процесс2 не зайдет в этот блок <br>
процесс2 так же приходит к общему ресурсу только спрашивает процесс1 доступен и если да то тоже уступает ему место в итоге два потока ждут выполнения друг друга <br>
**Starvation(голодание потока)** - результат процесса который не может получить регулярный доступ к ресурсам необходимым для выполнения задачи, и соответственно не может добиться какого либо прогресса.

## Что_такое_happens_before_в_Java_Memory_Model

**Happens-before** — это формальное отношение между операциями в многопоточной среде, которое гарантирует,
что одна операция видит результаты другой операции.
Если операция A happens-before операция B, то всё, что сделано в A, будет видно в B.

## Разница_между_CountDownLatch_CyclicBarrier_Semaphore.
1. **CountDownLatch** - Позволяет одному или нескольким потокам ждать, пока другие потоки не завершат определенные операции
   Одноразовый — после обнуления счетчика нельзя использовать повторно.
   Инициализируется числом (count), которое уменьшается методом countDown().
   Потоки, вызывающие await(), блокируются, пока счетчик не станет 0
2. **CyclicBarrier** - Заставляет набор потоков ждать друг друга в определенной точке (барьере), прежде чем продолжить выполнение.
   Многоразовый — после срабатывания барьера счетчик сбрасывается.
   Можно задать действие (Runnable), которое выполнится при достижении барьера.
   Если поток "ломает" барьер (например, из-за исключения), все остальные получают BrokenBarrierException.
3. **Semaphore** - Ограничивает количество потоков, которые могут одновременно работать с ресурсом
   Поддерживает "разрешения" (permits), которые потоки захватывают (acquire()) и освобождают (release()).
   Может быть "честным" (fair), чтобы избежать голодания потоков.
   Полезен для пулов ресурсов (например, подключений к БД).


## Entity
Методы операций над Entity:
1. **persist** (добавление Entity под управление JPA)
2. **merge** (обновление)
3. **remove** (удаления)
4. **refresh** (обновление данных)
5. **detach** (удаление из управление JPA)
6. **lock** (блокирование Enity от изменений в других thread).

Жизненный цикл Entity:
1. **new** - объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
2. **managed** — объект создан, управляется JPA, имеет сгенерированные первичные ключи.
3. **detached** — объект был создан, но не управляется (или больше не управляется) JPA.
4. **removed** — объект создан, управляется JPA, но будет удален после commit'a транзакции.

## Транзакции
У @Transactional есть ряд параметров:
1. **@Transactional (isolation=Isolation.READ_COMMITTED)** - уровень изоляции.
2. **@Transactional(timeout=60)** - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной
   системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение
   об откате не отвечающих транзакций.
3. **@Transactional(propagation=Propagation.REQUIRED_NEW)** - (Если не указано, распространяющееся поведение по умолчанию —
   REQUIRED.)

2 типа управления транзакции:
1. **програмное** - Используется TransactionTemplate, либо через реализацию PlatformTransactionManager напрямую.
2. **декларативное** - Отделяется управление транзакциями от бизнес-логики. Мы используем только
   аннотации @Transactional и конфигурацией на основе XML для управления транзакциями

Типы Propagation (пропагнации) в транзакциях:
1. **REQUIRED** (по умолчанию) — если есть транзакция, используется она, иначе создаётся новая.
2. **REQUIRES_NEW** — всегда создаёт новую транзакцию, приостанавливая текущую.
3. **SUPPORTS** — работает в транзакции, если она есть, но не создаёт новую.
4. **NOT_SUPPORTED** — приостанавливает текущую транзакцию, если она есть.
5. **MANDATORY** — требует активной транзакции, иначе — исключение.
6. **NEVER** — запрещает транзакцию, иначе — исключение.
7. **NESTED** — вложенная транзакция (поддерживается не всеми БД, например, работает в MySQL с InnoDB).

Уровни изоляции транзакций:
1. **TRANSACTION_NONE** – драйвер не поддерживает транзакции;
2. **TRANSACTION_READ_UNCOMMITTED** – транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены.
   не спасает не от чего.
3. **TRANSACTION_READ_COMMITTED** – транзакция может читать только те изменения в других параллельных транзакциях,
   которые уже были закоммичены.
   Это нас спасает только грязного чтения.
4. **TRANSACTION_REPEATABLE_READ** – пока транзакция не завершится, никто параллельно не может изменять или удалять строки,
   которые транзакция уже прочитала.
   Это спасает от всего кроме фантомного чтения.
5. **TRANSACTION_SERIALIZABLE** – блокирует любые действия, пока запущена транзакция.

1. **Потерянное обновление** — когда две транзакции записывают разные значения в одну и ту же ячейку, одно из изменений теряется
2. **Грязное чтение** - когда данные, которые я прочитал, кто-то может откатить ещё до того, как я завершу свою транзакцию.
3. **Неповторяющееся чтение** - я могу дважды прочитать одни и те же строки в одной транзакции в разное время и получить разный результат.
4. **Фантомное чтение** - Данные которые я прочитал и когда в итоге я хочу закомитить свою транзакцию то кол-во строк данных отличается.

## AOP
**Join Point** — это точка в выполнении программы, где может быть применён аспект, например, вызов метода или
обработка исключения. <br>
**Advice** — это код, который выполняется в определенных точках (join points) программы для добавления сквозной
функциональности. <br>
**Pointcut** определяет "где" (какие методы перехватывать). <br>
**Advice** определяет "что делать" в этих точках. <br>
**Aspect** — это модуль, объединяющий Advice и Pointcut. <br>

**Конкуренция** — это способ одновременного решения множества задач. <br>
**Параллелизм** — это способ выполнения разных частей одной задачи. <br>
**Процесс** — экземпляр программы во время выполнения, независимый объект. Каждый процесс выполняется в отдельном адресном пространстве <br>
**Поток(thread)** — способ выполнения процесса, определяющий последовательность исполнения кода в процессе. <br>
Потоки всегда создаются в контексте какого-либо процесса


## Параметры_для_аннотаций
Аннотации:
@Target - указывается, какой элемент программы будет использоваться аннотацией
Свойства:
1. **PACKAGE** - назначением является целый пакет (package);
2. **TYPE** - класс, интерфейс, enum или другая аннотация:
3. **METHOD** - метод класса, но не конструктор (для конструкторов есть отдельный тип CONSTRUCTOR);
4. **PARAMETER** - параметр метода;
5. **CONSTRUCTOR** - конструктор;
6. **FIELD** - поля-свойства класса;

@Retention - указываем, в какой момент жизни программного кода будет доступна аннотация
Свойства:
1. **SOURCE** - аннотация доступна только в исходном коде и сбрасывается во время создания .class файла;
2. **CLASS** - аннотация хранится в .class файле, но недоступна во время выполнения программы;
3. **RUNTIME** - аннотация хранится в .class файле и доступна во время выполнения программы.


## Docker
**Docker Image** - Образ докера это как снимок экземпляра приложения который в себе содержит все необходимое для запуска. <br>
**Слой** - это изменение файловой системы, которое возникает при выполнении каждой инструкции в Dockerfile. <br>
**Docker container** - запущенный экземпляр образа. <br>
**Dockerfile** — это текстовый файл с инструкциями для сборки Docker-образа. <br>
**Docker Machine** — это утилита для автоматического развертывания Docker-хостов на различных платформах. <br>
**Docker Swarm** — это встроенная в Docker система оркестрации контейнеров. <br>

**Dockerfile** — это 'сборка' (как Maven для образа) <br>
**Compose** — это 'оркестрация' (как дирижер для контейнеров) <br>

**Виртуализация** — это абстрактная версия физической машины (Позволяет разработчикам запускать и размещать несколько ОС на
оборудовании одного физического сервера)

**контейнеризация** — это абстрактная версия приложения. (Помогает разработчикам развернуть несколько приложений с использованием
одной и той же операционной системы)

Пример минимального Dockerfile для Java: <br>
FROM eclipse-temurin:17-jdk //Базовый образ с JDK <br>
COPY target/my-app.jar /app.jar  //Добавление JAR-файла <br>
CMD ["java", "-jar", "/app.jar"]  //Команда запуска <br>

CNM (Container Network Model) <br>
Внутри Docker Desktop есть несколько DNS-серверов. <br>
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов.

**docker system prune** - Эта команда очищает неиспользуемые ресурсы Docker. <br>
**FROM** - Задаёт базовый (родительский) образ. <br>
**ENV** - Создаёт переменную окружения <br>
**COPY** - Копирует файл с основной системы в контейнер (обеспечивает только базовую поддержку копирования локальных файлов в контейнер) <br>
**ADD** - Копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или url <br>
**RUN** - это 'сборка' (аналог фазы Maven package). Выполняет команду и создаёт слой образа <br>
**ENTRYPOINT** - это 'запуск' Определяет исполняемую команду (аналог main() в java) <br>
**CMD** - Задает аргументы по умолчанию для ENTRYPOINT <br>
**ARG** - позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. <br>

Основные команды:
1. **Запуск:** `docker run -d --name my_container nginx`
2. **Просмотр запущенных контейнеров:** `docker ps` и включая остановленные`docker ps -a`
3. **Остановка контейнера** `docker stop <контейнер_ID_или_имя>`
4. **Удаление контейнера** `docker rm <контейнер_ID_или_имя>`
5. **Просмотр логов контейнера** `docker logs <контейнер_ID_или_имя>`
6. **Вход в запущенный контейнер** `docker exec -it <контейнер_ID_или_имя> /bin/bash`
7. **Запуск остановленного контейнера** `docker start <контейнер_ID_или_имя>`
8. **Перезапуск контейнера** `docker restart <контейнер_ID_или_имя>`
9. **Поиск образа** `docker search <название_образа>`
10. **Скачивание образа** `docker pull <образ>:<тег>`
11. **Сборка образа из Dockerfile** `docker build -t <имя_образа> .`
12. **Просмотр списка сетей** `docker network ls`
13. **Подключение контейнера к сети** `docker network connect <сеть> <контейнер>`
14. **Просмотр списка томов** `docker volume ls`
15. **Просмотр использования ресурсов** `docker stats`
16. **Детальная информация о контейнере** `docker inspect <контейнер_ID_или_имя> | grep -i "cpu\|memory"`

## CAP
CAP теорема
CAP-теорема - это теорема, которая утверждает, что в распределенных компьютерных системах невозможно одновременно
обеспечить следующие три свойства (CAP): согласованность данных (Consistency), доступность системы (Availability)
и устойчивость к разделению сети (Partition tolerance).

Теорема утверждает, что в любой распределённой системе можно одновременно гарантировать только два из трёх свойств:
1. **Consistency (Согласованность)** - все узлы видят одни и те же данные в одно и то же время
2. **Availability (Доступность)** - система всегда возвращает ответ, даже если некоторые узлы недоступны
3. **Partition tolerance (Устойчивость к разделению)** - система продолжает работать при разрыве связи между узлами

В микросервисной архитектуре каждый сервис должен явно выбирать между:
- **CP-системы** (согласованность и устойчивость к разделению): например, сервисы обработки финансовых транзакций
- **AP-системы** (доступность и устойчивость к разделению): например, сервисы кеширования или каталогов товаров

## Kubernetes

1. **Master-нода (Control Plane)**
   Master — это "мозг" кластера Kubernetes. Он управляет всем кластером, принимает решения о развертывании,
   масштабировании и обеспечивает отказоустойчивость.
   Основные компоненты Master-ноды:
1. **kube-apiserver**
  - Что делает? Главный интерфейс для управления кластером.
  - Как работает? Принимает REST-запросы от пользователей (kubectl), валидирует их и обновляет состояние в etcd.
  - Пример: Когда ты запускаешь kubectl create deployment, запрос идёт именно сюда.
2. **etcd**
  - Что делает? Распределённое key-value хранилище, где хранится все состояние кластера (конфиги, секреты, метаданные).
  - Как работает? Работает по алгоритму консенсуса Raft (как в Consul). Если etcd падает — кластер становится неуправляемым.
3. **kube-scheduler**
  - Что делает? Решает, на какой Worker-ноде запускать под (Pod).
  - Как работает? Анализирует:
- Достаточно ли на ноде CPU/RAM?
- Есть ли ограничения (tolerations, node affinity)?
- Какая нода менее загружена?
4. **kube-controller-manager**
  - Что делает? Следит за тем, чтобы текущее состояние кластера соответствовало желаемому (declarative approach).
  - Какие контроллеры внутри?
- Deployment Controller – следит за репликами подов.
- Node Controller – реагирует на отвалившиеся ноды.
- Endpoint Controller – связывает сервисы и поды.

2. **Worker-ноды**
   Worker — это рабочие серверы, на которых фактически запускаются контейнеры.
   Основные компоненты Worker-ноды
1. **kubelet**
  - Что делает? "Агент" на Worker-ноде, который запускает и контролирует поды.
  - Как работает?
- Получает команды от Master-ноды ("запусти под с таким-то образом").
- Следит, чтобы контейнеры в подах были живы.
- Отчитывается Master-ноде о состоянии ноды.
2. **kube-proxy**
  - Что делает? Обеспечивает сетевую коммуникацию между сервисами.
  - Как работает?
- Настраивает правила iptables/IPVS для балансировки нагрузки.
- Позволяет подам внутри кластера находить друг друга по DNS или ClusterIP.
3. **Container Runtime**
  - Что делает? Запускает контейнеры (например, Docker, containerd, CRI-O).
  - Как работает?
- Получает от kubelet команду: "Запусти контейнер из образа nginx:latest".
- Скачивает образ и запускает контейнер.

Как Master и Worker взаимодействуют?
- Ты отправляешь команду через kubectl → она попадает в kube-apiserver.
- kube-scheduler решает, на какой Worker-ноде запустить под.
- kubelet на Worker-ноде получает задание и запускает контейнер через Container Runtime.
- kube-proxy настраивает сетевые правила, чтобы под был доступен.
- Controller Manager следит, чтобы всё работало как задумано.

**Sidecar** — это архитектурный паттерн, при котором вспомогательный контейнер (sidecar) работает вместе с основным
контейнером в одном Pod, расширяя его функциональность без изменения кода основного приложения.

**etcd** — это распределённое key-value хранилище, используемое Kubernetes как основная база данных для хранения всего состояния кластера.
Это критически важный компонент Control Plane, без которого кластер не сможет функционировать.

**kube-proxy** — это компонент Kubernetes, который работает на каждой ноде кластера и отвечает за маршрутизацию трафика к
сервисам (Services). Он обеспечивает, чтобы запросы к сервису (например, по ClusterIP, NodePort или LoadBalancer) корректно
перенаправлялись на подходящие Pod'ы.

## Reddis

Типы данных reddis:
1. **базовые** - встроенные, нативные типы(они очень быстрые т.к. реализованы на языке C без внешних зависимостей)
   String, List, Set, Sorted Set, Hash, Stream, Bitmap, Bitfield, Geospatial, HyperLogLog.
2. **модульные**
   JSON, Time Series, Bloom Filter,Cuckoo Filter

Стратегии кэширования:
1. Cache-Aside(Lazy-loading)
2. Read-Through
3. Write-Through
4. Write-Behind
5. Full Page/Fragment Cache

Инвалидация кэша:
1. Time-based(TTL)
2. Explicit Invalidate
3. Versioning
4. Event-based
5. Write through/Write-behind
6. Cache Buster/Soft Invalidate

## GET_POST_PUT

1. **GET** - Получение данных <br>
   Кешируется: Да <br>
   Параметры передаются в URL (?query=value) <br>
   Ограничение длины URL (до ~2048 символов) <br>
2. **POST** - Создание ресурса или вызов операции <br>
   Идемпотентность: Нет (повторный запрос создаст новый ресурс) <br>
   Тело запроса (body) может быть любого формата (JSON, XML, бинарные данные) <br>
3. **DELETE** - Удаление ресурса <br>
   Идемпотентность: Да (повторный запрос вернёт 404) <br>
   Некоторые API позволяют передавать тело запроса (например, параметры удаления) <br>
4. **PUT** - Полное обновление или создание ресурса (если известен ID) <br>
   Идемпотентность: Да (повторный запрос не изменит результат) <br>
   Если ресурс существует — заменяет его полностью. <br>
   Если ресурса нет — может создать его <br>
5. **PATCH** - Частичное обновление ресурса. <br>
   Идемпотентность: Зависит от реализации (обычно — нет) <br>
   Обновляет только указанные поля. <br>
   Если поле не передано — остаётся без изменений <br>

## Кода_ошибок

Клиентские 400 <br>
Серверные 500 <br>

400 - bar request сервер не принимает запрос из за синтаксиса <br>
401 - требуется аутенфикация <br>
403 - доступ запрещен <br>
404 - ресурс не найден <br>
408 - сервер не дождался запроса от клиента <br>
429 - превышен лимит запросов <br>

500 - общая ошибка сервера (сбой в коде) <br>
501 - не поддерживает функциональность запроса <br>
502 - bad gateway - прокси-сервер получил не допустимы ответ от сервера. <br>
503 - сервер временно не доступен <br>
504 - сервер не дождался ответа <br>
505 - сервер не поддерживает версию http запроса. <br>

## Сертификат

1. Клиент → Серверу: ClientHello
2. Сервер → Клиенту
- ServerHello (выбранный шифр).
- Сертификат сервера
3. Сервер запрашивает сертификат клиента (CertificateRequest)
4. Клиент проверяет сертификат сервера
5. Клиент генерирует pre-master key, шифрует его публичным ключом сервера и отправляет серверу.
6. Клиент отправляет свой сертификат
7. Сервер расшифровывает pre-master key своим приватным ключом.
8. Сервер проверяет сертификат клиента (так же, как клиент проверял серверный).
9. Обе стороны вычисляют общий сессионный ключ (для симметричного шифрования).
10. Далее – обмен ключами как в обычном TLS.
    Как проверяется сертификат?
1. Проверка подписи CA
- Клиент проверяет, что сертификат подписан доверенным УЦ (CA).
- Проверяется цепочка сертификатов (Root CA → Intermediate CA → Серверный сертификат).
2. Проверка срока действия
3. Проверка имени (SAN/CN)

## Протоколы
Протоколы
1. Транспортные протоколы
- **TCP** - обеспечивает гарантированную доставку данных между приложениями. Перед передачей данных клиент и сервер выполняют
  "рукопожатие" (HTTP, БД, файловые передачи)
  Данные разбиваются на сегменты.
  Каждый сегмент нумеруется (Seq), получатель подтверждает (ACK) получение.
  Если ACK не пришел за время таймаута, данные пересылаются.
- **UDP** - обеспечивает быструю передачу данных без установки соединения (Стриминг, игры)
2. Сетевые протоколы
- **IPv4 / IPv6** - отвечает за маршрутизацию и доставку пакетов между устройствами в сети. IP не гарантирует, что пакет дойдет до
  получателя
  - Каждый роутер содержит таблицу маршрутизации, которая определяет, куда отправить пакет.
  - Если IP-адрес получателя в локальной сети – пакет отправляется напрямую (через ARP).
  - Если нет – пакет пересылается на шлюз (gateway) по умолчанию.
3. Прикладные протоколы
- **HTTP**
  - Протокол для передачи данных между клиентом (браузером) и сервером.
  - Работает на порту 80.
  - Данные передаются в открытом виде
  - Данные передаются в текстовом формате → их можно перехватить
- **HTTPS**
  - Защищённая версия HTTP с шифрованием.
  - Работает на порту 443.
  - Использует SSL/TLS для шифрования данных.
    Как работает?
    - "Рукопожатие" (Handshake)
    - Браузер и сервер согласовывают параметры шифрования.
    - Сервер отправляет SSL-сертификат для проверки подлинности.
    - Обмен ключами
    - Создаётся сеансовый ключ для шифрования данных.
- **WebSocket**
- **REST**
- **gRPC** - это пакетная технология передачи данных
- **GraphQL**
4. Электронная почта
- **SMTP**

## Микросервисы

1. **`Circuit Breaker`** - Это механизм, который предотвращает распространение сбоев в системе. Он обеспечивает отказоустойчивость, переключая
   запросы на альтернативные сервисы или возвращая значения по умолчанию, если сервис недоступен.
   Состояния Circuit Breaker:
  - Closed (Закрыто) — запросы проходят нормально.
    В закрытом состоянии Circuit Breaker позволяет запросам проходить к защищаемому сервису. Это нормальное рабочее состояние.
  - Open (Разомкнуто) — все запросы мгновенно отклоняются.
    В открытом состоянии Circuit Breaker блокирует все попытки выполнить запрос к защищаемому сервису. Это профилактическая мера, предотвращающая дальнейшее распространение ошибок.
  - Half-Open (Полуоткрыто) — пробует пропустить несколько запросов для проверки восстановления сервиса.
    Полуоткрытое состояние - это переходное состояние, в котором Circuit Breaker начинает частично разрешать запросы к сервису для тестирования его доступности и надежности.
2. **`Apigateway`** - это сервер, который выступает в роли единой точки входа для клиентов
   Основные задачи API Gateway:
  - Маршрутизация запросов
  - Агрегация данных (Объединяет ответы от нескольких сервисов в один (например, данные пользователя + его заказы).)
  - Аутентификация и авторизация
  - Лимитирование запросов (Rate Limiting)
  - Кэширование
  - Обработка ошибок и Circuit Breaker
    Популярные API Gateway:
  1. NGINX
  2. Spring Cloud Gateway
3. **`Saga`** - Паттерн Saga сосредотачивается на достижении атомарности каждого шага транзакции в микросервисной архитектуре.
4. **`CQRS`** - это подход, разделяющий модели для чтения (Query) и записи (Command) данных. Вместо единой модели, как в классическом CRUD.
5. **`SOA`** - это набор архитектурных принципов в котором объекты независимы и слабо связаны. Тоесть мы разбиваем все на сервисы (платежи, логирование) которые разрабатываются и работают независимо друг от друга.
6. **`DDD_Domain_Driven_Design`** - это подход который фокусируется на бизнес-логике и доменной модели. Необходим где надо четке разделение бизнес-логики.
7. **`РАСТ`** - это инструмент для тестирования и контрактного тестирования между поставщиком и потребителем в микросервисной архитектуре.
   цель PACT в микросервисной архитектуре заключается в обеспечении согласованности и надежности взаимодействия между сервисами путем создания контрактов и автоматического тестирования.
8. **`Retry_pattern`** - представляет собой подход, который позволяет обрабатывать временные сбои
   при попытке подключения к сервису или сетевому ресурсу. Этот шаблон позволяет приложению автоматически повторять запросы, которые
   не удалось выполнить из-за временных проблем, таких как сетевые задержки, ошибки сервера или перегрузка ресурсов.
9. **`Explain_Sidecar`** - это архитектурный шаблон, который используется в микросервисной архитектуре для добавления дополнительной
   функциональности к основному сервису без изменения его кода.
10. **`Explain_Outbox`** - Он используется для обеспечения надежной и атомарной доставки событий или сообщений между различными сервисами.
    Outbox представляет собой специальную таблицу в базе данных, которая служит буфером для записи событий или сообщений, которые должны
    быть отправлены другим сервисам.

## Паттерны
1. **Принцип единственной ответственности (Single Responsibility Principle, SRP)** - класс должен иметь только одну
   ответственность. Например, класс, отвечающий за работу с базой данных, не должен также заниматься обработкой
   пользовательского ввода или выводом на экран.
   Можно упомянуть, как распознать проблему в коде:
   - Класс имеет больше 100–200 строк кода.
   - Методы класса логически несвязаны (например, sendEmail() и validatePayment()).
   - При изменении одной части кода ломается другая, казалось бы, не связанная с ней.
2. **Принцип открытости/закрытости (Open/Closed Principle, OCP)** - классы должны быть открыты для расширения, но закрыты для
   модификации. Это означает, что новый функционал должен добавляться через добавление новых классов или методов,
   а не изменение существующих.
3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)** - класс который наследовался от родителя не должен
   ломать интерфейс. Допустим если мы наследовались от класс который не бросает Exception а я бросаю Exception то
   родительский класс может этого не знать и у него будет не объяснимое поведение.
   К примеру у нас есть класс прямоугольник и у него есть два поля ширина и высота. Мы создаем класс Квадрат который наследуется
   от треугольника и он оверайдит метод 
   `  @Override
    public void setHeight(int height) {
        this.height = height;
        this.width = height; // Нарушение! Меняет width
    }`
   в итоге происходит нарушение т.к. квадрат не может быть подтипом треугольника и меняется оба поля. Как вариант пересмотреть иерархию наследования.
4. **Принцип разделения интерфейса (Interface Segregation Principle, ISP)** - клиенты не должны зависеть от интерфейсов, которые
   они не используют. Интерфейсы должны быть маленькими и специфическими для конкретных задач.
5. **Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)** - класс должен зависеть не от реализации а от
   абстракций. Тоесть класс должен быть написан так чтобы он зависел не от конкретной реализации а от интерфейса.
   Например, класс, который использует базу данных, должен зависеть от абстрактного интерфейса базы данных, а не от конкретной
   реализации базы данных.
   Этот принцип уменьшает связанность, позволяет легко меняь реализации(PostgreSQL, MySQL)
   Проблемный код:
   `class OrderService {
     private MySQLDatabase database;  // Прямая зависимость от конкретного класса!
     public OrderService() {
       this.database = new MySQLDatabase();  // Жесткая привязка
     }
     public void saveOrder(Order order) {
       database.save(order);
     }
   }`
   Проблемы:
  - OrderService жестко зависит от MySQLDatabase.
  - Если нужно перейти на PostgreSQL, придется переписывать код.
  - Сложно тестировать: нельзя подменить MySQLDatabase моком.
    Как исправить? Применение DIP
  - Решение 1: Внедрение зависимости через интерфейс

1. **Порождающие** - абстрагируют процесс создание экземпляра. Позволяют сделать систему
   независимой от способа создания, композиции и представления объектов.
2. **Структурные** - определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его
   реализацию, позволяя облегчить разработку и оптимизировать программу.
3. **Поведения** - определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

Порождающие:
1. **Абстрактная фабрика** - представляет собой интерфейс для создания других классов, позволяя создавать семейства связанных объектов не привязываясь к конкретным классам.
   `public interface CarsFactory { }
    public class ToyotaFactory implements CarsFactory {}
    public class FordFactory implements CarsFactory {}

   public interface CarsFactory {
     Sedan createSedan();
     Coupe createCoupe();
   }

   public class ToyotaFactory implements CarsFactory {
     @Override
     public Sedan createSedan() {
       return new  ToyotaSedan();
     }
     @Override
     public Coupe createCoupe() {
       return new ToyotaCoupe();
     }
   }`
2. **Строитель (Builder)** - представляет собой интерфейс для создания сложного объекта. Тоесть позволяет шаг за шагом строить сложные объекты.
   Он позволяет строить нам объекты избегая громозких конструкторов, устанавливая поля пошагово через цепочку методов.
3. **Фабричный метод (Factory method)** - Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой
   класс создавать. К примеру @Bean аннотация это Factory method. 
4. **Прототип (Prototype)** - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через
   конструктор.
5. **Одиночка (Singleton)**

Структурные:
1. **Адаптер** - Позволяет несовместимым интерфейсам работать вместе.
   `interface Car(){}
    interface Locomotive(){}
    class ElectroCar implemets Car(){}
    class ElectricLocomotive implements Locomotive() {}
    class CarToLocomotive implemets Locomotive {
       private Car car;
    }
   `
2. **Мост (Bridge)** - позволяет разделять абстракцию и реализацию позволяя им изменяться независимо. Он применяется допустим когда нужно разделить монолитный класс на части, которые могут изменяться независимо.
3. **Компоновщик (Composite)** - Объединяет объекты в древовидные структуры и позволяет работать как с одним объектом. Используется к примеру для реализации файловой системы (иерархии папок).
   `
    interface Container {
      void add(Box box);
      void delete(int number)
    }
    interface Box {
      int getNumber();
    }
    class BigContainer implements Container {
      private List<Box> boxes;
      public void add(Box box) {}
      public void delete(int number) {}
      public List<Box> getBoxes(){}
    }
    `
4. **Декоратор (Decorator)** - Динамически добавляет новую функциональность объекту, не меняя основной класс. (когда класс реализует интерфейс, имплементит
   его метод и добавляет дополнительные методы)
5. **Фасад (Facade)** - Предоставляет упрощенный интерфейс к сложной системе. (тоесть это реализован метод в котором находятся множество взаимодействий с дочерними классами их вызов и логика)
   `
   public class Tree {
     private Roots root = new Roots();
     private Branches branches = new Branches();
     private Trunk trunk = new Trunk();

     public void grow() {
       roots.growRoots();
       trunk.growTaller();
       trunk.growAround();
       branches.growLimbs(6);
       branches.growLeaves(500);
     }
   `
6. **Приспособленец (Flyweight)** - позволяет эффективно поддерживать множество объектов, разделяя их общее состояние. Тоесть в классе есть метод который служит как фабрикой для создания классов.
   К примеру у нас приложение создает множество объектов отчего растет потребление памяти и мы можем спроектировать так что будет внутренее состояние которое неизменно для многе объектов и
   внешнее состояние которые уникальное для каждого объекта создаваемого.
   `  public void display(int position) {  // position - внешнее состояние
        System.out.printf("Символ '%c' (шрифт: %s, размер: %d) на позиции %d%n", 
                         symbol, fontFamily, size, position);
    }`
7. **Заместитель (Proxy)**

Поведения:
1. **Цепочка обязанностей (Chain of responsibility)**
2. **Итератор (Iterator)** - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта
3. **Наблюдатель (Observer)** - Позволяет объектам уведомлять подписчиков об изменениях.
4. **Стратегия (Strategy)** - Инкапсулирует алгоритмы в отдельные классы, делая их взаимозаменяемыми. Тоесть Мы отделяем процедуру
   выбора алгоритма от его конкретных реализаций.

## Алгоритмы

1. Алгоритмы сортировки:
- пузырьковая сортировка,
- сортировка выбором,
- сортировка вставкой,
- быстрая сортировка,
- сортировка слиянием,
- пирамидальная сортировка, 
- сортировка Шелла,
- TimSort (по умолчанию для Collections.sort),
- сортировка подсчетом, (опционально)
- поразрядная сортировка, (опционально)
2. Алгоритмы поиска:
- линейный поиск
- бинарный поиск
- поиск прыжками
- интероляционный поиск
- экспонциальный поиск
- поиск фибоначчи
3. Алгоритмы обхода графов:
- поиск в ширину (BFS)
- поиск в глубина (DFS)

Алгоритм	 Лучший случай	Средний случай	Худший случай	Память
Вставками	 O(n)	          O(n²)	          O(n²)	        O(1)
Выбором	   O(n²)	        O(n²)	          O(n²)	        O(1)
Пузырьком	 O(n)	          O(n²)	          O(n²)	        O(1)
Быстрая	   O(n log n)	    O(n log n)	    O(n²)	        O(log n)

                Алгоритмы сортировки
1. **Быстрая сортировка**: использует стратегию разделяй и властвую.
   - Средняя сложность: O(N*logN). 
   - Худшая сложность (когда массив почти отсортирован) O(n²)
   - Пространственная сложность: O(log n) (из-за рекурсии)
   Берется элемент (pivot), может быть первым\последним, средним, или случайным элементом.
   Массив разделяется на две части, левая часть элементы меньше выбранного, правая часть больше.
   Дальше происходит рекурсивная сортировка левой и правой части массива.
2. **Сортировка слиянием**: использует стратегию разделяй и властвую.
   Массив рекурсивно разбивается на две половины пока не останутся подмассивы из одного элемента. После этого массивы с одним элементом у каждого объединяются в один упорядоченный
   массив. Хорошо работает для больших данных и внешней сортировки (например, сортировка файлов)
   - лучший\худший\средний - O(n log n)
   - Пространственная сложность: O(n) (требуется дополнительная память)
3. **Сортировка вставкой**: строит итоговый массив по одному элементу за раз вставляя новый элемент в правильную позицию отсортированной части.
   Разделяет массив на два подмассива (отсортированного и не отсортированного). Последовательно берем элемент из не отсортированной части и вставляем в позицию отсортированной части, сдвигая остальные.
   - Лучший случай когда массив отсортирован O(n)
   - средний\худший  O(n²)
   - Пространственная сложность: O(1) (in-place, не требует доп. памяти)
4. **Пирамидальная сортировка**: основан на структуре двоичная куча.
   Преобразует массив в max-кучу где каждый родитель больше своих потомков. Корень это макс.элемент.
   - лучший\средний\худший: O(n log n)
   - Пространственная сложность: O(1)
5. **Сортировка выбором**:
   Массив делится на две части. Одна из частей отсортирована (изначально пустая) другая не отсортирована. На каждом шаге выбирает минимальный элемент из неотсортированной части и помещает его в конец отсортированной.
   - лучший\средний\худший: O(n²)
6. **Пузырьковая сортировка**:
   Проход по всей коллекции и сравниваем если число слева больше то меняем местами.
   - лучший O(n)
   - средний\худший O(n²)
7. **Сортировка Шелла**: улучшенная версия сортировкой вставками только сортирует элементы в интервале
   Так же делится на два подмассива (сортированный и не сортированный) но с правой не отсортированной части берется не по 1 элементу а в интервале элементов.
   - лучший случай O(n log n)
   - худший случай O(n²) (при неудачном выборе шага)
8. **TeamSort**: комбинирует MergeSort (слияние) и InsertionSort (вставками)
   Массив разделяется на небольшие упорядоченные подмассивы (обычно длиной от 32 до 64 элементов). Каждый подмассив сортируется вставками.
   Подмассивы объединяются аналогично Merge Sort, но с оптимизациями:
   1. Используется галоп (galloping mode) для быстрого слияния.
   2. Минимизируется количество операций копирования.
   - лучший случай O(n)(массив почти отсортирован). 
   - Средний\Худший случай O(n log n). 
   - Пространственная сложность O(n) использует доп.память.

Алгоритм обхода графов:
1. **Обход в глубину(DFS)** - один из популярных способов это рекурсия. Чтобы не переполнять стек можно использовать итерационный подход с Stack коллекцией. Необходим для поиск пути, циклы в графе, компоненты.
   При обходе в глубину порядок обработки текущего узла и узлов его правого и левого поддеревьев варьирует:
  - прямой: вершина – левое поддерево – правое поддерево
  - обратный: левое поддерево – вершина – правое поддерево
  - концевой: левое поддерево – правое поддерево – вершина
2. **Обход в ширину(BFS)** - применяется итерационный подход чтобы избежать переполнение стека, используются очередь Queue. Необходим для поиска кратчайшего пути, обхода по уровням, поиска в соц.сетях.
   Вначале обрабатываются все узлы текущего уровня, после чего осуществляется переход на нижний уровень.

Виды деревьев в Java:
1. **Бинарное дерево**
   Дерево, где каждый узел имеет не более двух дочерних узлов (левый и правый).
2. **Бинарное дерево поиска**
   - Все узлы левого поддерева меньше корня. Все узлы правого поддерева больше корня.
3. **AVL-дерево**
   Самобалансирующееся BST, где разница высот поддеревьев (баланс) не превышает 1.
4. **Красно-черное дерево**
   Ещё один тип самобалансирующегося BST, где каждый узел имеет цвет (красный или чёрный).
5. **B-дерево**
   Сбалансированное дерево, где узел может иметь более двух дочерних элементов
6. **Двоичная куча (опционально)**
   Полное бинарное дерево, где каждый родитель меньше (min-heap) или больше (max-heap) своих детей.
7. **Префиксное дерево (опционально)**
8. **Декартово дерерво (опционально)**
9. **Дерево отрезков (опционально)**

