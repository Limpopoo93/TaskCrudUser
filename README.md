-[Определения](#Определения) <br/>
-[Типы_данных](#Типы_данных) <br/>
-[Реляционная_модель_данных](#Реляционная_модель_данных) <br/>
-[Ключи](#Ключи) <br/>
-[Кластерный и не кластерный индекс](#Кластерный_не_кластерный_индекс) <br/>
-[Entity](#Entity) <br/>
-[Транзакции](#Транзакции) <br/>
-[Cache_Cacheble](#Cache_Cacheble) <br/>
-[Стратегии_кэширования](#Стратегии_кэширования) <br/>
-[Чем_отличается_пессимистичная_и_оптимистичная_блокировка](#Чем_отличается_пессимистичная_и_оптимистичная_блокировка) <br/>
-[Чем_отличается_Statement_от_PreparedStatement](#Чем_отличается_Statement_от_PreparedStatement) <br/>
-[Как_осуществляется_запрос_к_базе_данных_и_обработка_результатов](#Как_осуществляется_запрос_к_базе_данных_и_обработка_результатов) <br/>
-[Какие_виды_нормализации_бывают_в_SQL](#Какие_виды_нормализации_бывают_в_SQL) <br/>
-[Что_такое_инструкция_TRUNCATE](#Что_такое_инструкция_TRUNCATE) <br/>
-[Какие_аналитические_функции_поддерживает_SQL](#Какие_аналитические_функции_поддерживает_SQL) <br/>
-[Join](#Join) <br/>
-[Расскажите_об_основных_функциях_ранжирования_в_Transact_SQL](#Расскажите_об_основных_функциях_ранжирования_в_Transact_SQL) <br/>
-[Для_чего_используются_операторы_INTERSECT_EXCEPT_в_Transact_SQL](#Для_чего_используются_операторы_INTERSECT_EXCEPT_в_Transact_SQL) <br/>
-[CAP](#CAP) <br/>
-[Аннотации](#Аннотации) <br/>
-[NoSql](#NoSql) <br/>

Функция	                  Описание	                                                    Пример <br/>
CEILING(x)	   возвращает наименьшее целое число, большее или равное x             CEILING(-5.8)=-5 <br/>
               (округляет до целого числа в большую сторону)	                     CEILING(4.2)=5 <br/>
ROUND(x, k)	   округляет значение x до k знаков после запятой,                     ROUND(5.86592,1)=5.9 <br/>
               если k не указано – x округляется до целого	                       ROUND(4.361)=4 <br/>
FLOOR(x)	     возвращает наибольшее целое число, меньшее или равное x             FLOOR(-5.8)=-6 <br/>
               (округляет до  целого числа в меньшую сторону)	                     FLOOR(4.2)=4 <br/>
POWER(x, y)	   возведение x в степень y	                                           POWER(3,4)=81.0 <br/>
SQRT(x)	       квадратный корень из x	                                             SQRT(4)=2.0 <br/>
DEGREES(x)	   конвертирует значение x из радиан в градусы	                       DEGREES(3) = 171.8... <br/>
RADIANS(x)	   конвертирует значение x из градусов в радианы	                     RADIANS(180)=3.14... <br/>
ABS(x)	       модуль числа x	                                                     ABS(-1) = 1 <br/>

IF(логическое_выражение, выражение_1, выражение_2)
округления числа до знаков после запятой: Round(число, 2) as new_item
HAVING - используется для условий с GROUP BY  `SELECT author, MIN(price) AS Минимальная_цена FROM book GROUP BY author HAVING SUM(price * amount) > 5000 ORDER BY Минимальная_цена DESC;`
UNION и UNION ALL — это операторы SQL, которые объединяют результаты двух и более запросов в одну таблицу.

## Определения
Модели данных Субд:
1. Иерархическая - построение вертикальных связей образуя древовидную структуру.
2. Сетевая - у узла может быть несколько предков. Тоже образует графы.
3. Реляционная - строится на понятии отношений основанного на декартовом произведении.
4. Объектно-ориентированная - проектирование данных в виде объектов.
5. Графовая
6. Объектно-реляционная
7. Документо-ориентированная

Домен - множество значений которые может принимать элемент данных
Отношение - подмножество декартового произведения доменов.
Кортеж - элемент отношений.
Атрибут - элемент кортежа.

Базы данных могут быть распределенными и централизованными.

ORM (Object-relational mapping) — ORM — это технология для работы с БД через объекты в Java. Я чаще всего использую Hibernate,
так как он реализует JPA и снижает объем шаблонного кода.

JPA (Java Persistence API) - это стандарт (интерфейсы: EntityManager, @Entity).
Hibernate — самая популярная реализация JPA (но есть и другие, например, EclipseLink).

JPQL — Java Persistence Query Language. Фактически это как SQL, только запросы делаются не к таблицам, а к классам. JPQL основан на HQL.
HQL — Hibernate Query Language. Аналог SQL, но работает с сохраняемыми объектами (Persistent Objects) и их полями (аттрибутами класса).

Criteria API — это программный, типобезопасный способ создания запросов к базе данных в JPA. В отличие от JPQL
(который использует строковые запросы), Criteria API позволяет строить запросы через Java-объекты, что дает преимущества
на этапе компиляции.

DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.
DataSource - интерфейс, который предоставляет более гибкий способ получения подключений с поддержкой:
- Пулинга соединений
- Кеширования и балансировки

Connection - интерфейс, представляющий активное подключение к БД

ResultSet - это интерфейс в JDBC, который представляет собой таблицу данных, полученную в результате выполнения SQL-запроса
ResultSetMetaData - это интерфейс, который предоставляет метаинформацию о структуре.

# Типы_данных
1. smalint (2байта) в не большом диапозоне
2. integer (4байта) типичный выбор целых чисел
3. bigint (8байт) целое в большом диапазоне
4. decunal (переменный) вещественное число с указанной точностью
5. numberic (переменный) вещественное число с указанной точностью
6. real (4байта) вещественное число с переменнной точностью
7. double presion (8байт) вещественное число с переменной точностью
8. smallserial (2байта) небольшое целое с автоувеличением 
9. serial (4байта) целоее с автоувеличением
10. bigserial (8байт) целое с автоувеличением

# Реляционная_модель_данных
Реляционная модель данных — это построение бд на основе отношений между таблицами путем связей.
Реляционная модель данных включает в себя следующие компоненты:
1. Структурный аспект — данные представляют собой набор отношений.
2. Аспект целостности — отношения отвечают определенным условиям целостности: уровня домена (типа данных), уровня отношения и уровня базы данных.
3. Аспект обработки (манипулирования) — поддержка операторов манипулирования отношениями (реляционная алгебра, реляционное исчисление).
4. Нормальная форма - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности и определённое как совокупность 
   требований, которым должно удовлетворять отношение.

## Ключи
1. Простой ключ состоит из одного атрибута (поля). Составной - из двух и более.
2. Потенциальный ключ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных.
3. Естественный Ключ – набор атрибутов описываемой записью сущности, уникально её идентифицирующий (например, номер паспорта для человека).
4. Суррогатный Ключ – автоматически сгенерированное поле, никак не связанное с информационным содержанием записи.

## Кластерный_не_кластерный_индекс
Некластерные индексы - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит 
   для часто изменяемого набора данных.
При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного 
   доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.

## Основные_классы_и_интерфейсы_JPA
1. EntityManagerFactory – Он создает и управляет несколькими экземплярами EntityManager.
2. EntityManager - интерфейс, вызывая методы которого можно управлять сущностями. EntityManager аналогом Connection
3. Entity – это постоянные объекты, хранящиеся в виде записей в базе данных.
4. EntityTransaction – интерфейс для работы с транзакциями.

## Entity
Методы операций над Entity:
1. persist (добавление Entity под управление JPA)
2. merge (обновление)
3. remove (удаления)
4. refresh (обновление данных)
5. detach (удаление из управление JPA)
6. lock (блокирование Enity от изменений в других thread).

Жизненный цикл Entity:
1. new - объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
2. managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи.
3. detached — объект был создан, но не управляется (или больше не управляется) JPA.
4. removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.

## Транзакции
У @Transactional есть ряд параметров:
1. @Transactional (isolation=Isolation.READ_COMMITTED) - уровень изоляции.
2. @Transactional(timeout=60) - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной
   системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение
   об откате не отвечающих транзакций.
3. @Transactional(propagation=Propagation.REQUIRED_NEW) - (Если не указано, распространяющееся поведение по умолчанию —
   REQUIRED.)

2 типа управления транзакции:
1. програмное - Используется TransactionTemplate, либо через реализацию PlatformTransactionManager напрямую.
2. декларативное - Отделяется управление транзакциями от бизнес-логики. Мы используем только
   аннотации @Transactional и конфигурацией на основе XML для управления транзакциями

Типы Propagation (пропагнации) в транзакциях:
1. REQUIRED (по умолчанию) — если есть транзакция, используется она, иначе создаётся новая.
2. REQUIRES_NEW — всегда создаёт новую транзакцию, приостанавливая текущую.
3. SUPPORTS — работает в транзакции, если она есть, но не создаёт новую.
4. NOT_SUPPORTED — приостанавливает текущую транзакцию, если она есть.
5. MANDATORY — требует активной транзакции, иначе — исключение.
6. NEVER — запрещает транзакцию, иначе — исключение.
7. NESTED — вложенная транзакция (поддерживается не всеми БД, например, работает в MySQL с InnoDB).

Уровни изоляции транзакций:
1. TRANSACTION_NONE – драйвер не поддерживает транзакции;
2. TRANSACTION_READ_UNCOMMITTED – транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены.
   не спасает не от чего.
3. TRANSACTION_READ_COMMITTED – транзакция может читать только те изменения в других параллельных транзакциях,
   которые уже были закоммичены.
   Это нас спасает от грязного чтения но не спасает от неповторяющегося чтения и от фантомного чтения.
4. TRANSACTION_REPEATABLE_READ – пока транзакция не завершится, никто параллельно не может изменять или удалять строки,
   которые транзакция уже прочитала.
   Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения.
5. TRANSACTION_SERIALIZABLE – блокирует любые действия, пока запущена транзакция.

Потерянное обновление (lost update) — когда две транзакции записывают разные значения в одну и ту же ячейку, одно из изменений теряется
Грязное чтение - когда данные, которые я прочитал, кто-то может откатить ещё до того, как я завершу свою транзакцию.
Неповторяющееся чтение - я могу дважды прочитать одни и те же строки в одной транзакции в разное время и получить разный результат.
Фантомное чтение - Данные которые я прочитал и когда в итоге я хочу закомитить свою транзакцию то кол-во строк данных отличается.

## Cache_Cacheble
@Cache - настраивает тонкости кэширования объекта в кэше второго уровня.
Принимает три параметра:
1. include (all - означающий кэширование всего объекта, non-lazy - запрещает кэширование лениво загружаемых объектов)
2. region - позволяет задать имя региона кэша для хранения сущности
3. usage - задаёт стратегию одновременного доступа к объектам.
@Cacheable - используется для указания того, должна ли сущность храниться в кэше второго уровня
Параметр shared-cache-mode:
1. ENABLE_SELECTIVE - только сущности с аннотацией @Cacheable будут сохраняться в кэше второго уровня
2. DISABLE_SELECTIVE - все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных аннотацией @Cacheable
3. None - ни одна сущность не кэшируется, даже если помечена как кэшируемая
4. All - сущности всегда кэшируются, даже если они помечены как некэшируемые

## Стратегии_кэширования
1. Read-only — объекты кэшируются только для чтения и изменение удаляет их из кэша.
2. Read-write — полноценный доступ к одной конкретной записи и разделение её состояния между транзакциями. Однако суммарное состояние 
   нескольких объектов в разных транзакциях может отличаться.
3. Nonstrict-read-write — аналогичен read-write, но изменения объектов могут запаздывать и транзакции могут видеть старые версии объектов. 
   Рекомендуется использовать в случаях, когда одновременное обновление объектов маловероятно и не может привести к проблемам.
4. Transactional — полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, как если бы только они с ним 
   работали последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.

## Чем_отличается_пессимистичная_и_оптимистичная_блокировка

Пессимистичная (через SELECT FOR UPDATE) – блокирует данные заранее.
Оптимистичная – проверяет конфликты при коммите (например, через version).

## Чем_отличается_Statement_от_PreparedStatement

В высоконагруженных системах мы используем PreparedStatement + пул соединений (HikariCP) для максимальной производительности. Для batch-операций — addBatch(),
чтобы снизить нагрузку на сеть.

1. Statement:
- Используется для простых случаев запроса без параметров.
- Запрос формируется через конкатенацию строк.
- Медленнее (каждый запрос компилируется заново).
- Уязвим к SQL-инъекциям.
- Для статичных запросов.

2. PreparedStatement:
- предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.
- Использует параметры (?).
- Быстрее (прекомпиляция + кэширование).
- Защищает от SQL-инъекций.
- Для динамических запросов.

## Как_осуществляется_запрос_к_базе_данных_и_обработка_результатов

Выполнение запросов осуществляется при помощи вызова методов объекта, реализующего интерфейс Statement:
1. executeQuery() - для запросов, результатом которых является один набор значений, например запросов SELECT. Результатом выполнения является
   объект класса ResultSet;
2. executeUpdate() - для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов DDL (Data Definition Language). Метод
   возвращает целое число, показывающее, сколько записей было модифицировано;
3. execute() – исполняет SQL-команды, которые могут возвращать различные результаты. Например, может использоваться для операции CREATE TABLE.
   Возвращает true, если первый результат содержит ResultSet и false, если первый результат - это количество модифицированных записей или
   результат отсутствует. Чтобы получить первый результат необходимо вызвать метод getResultSet() или getUpdateCount(). Остальные результаты
   доступны через вызов getMoreResults(), который при необходимости может быть произведён многократно.

## Какие_виды_нормализации_бывают_в_SQL

1НФ (Первая нормальная форма):
- Все атрибуты атомарны (неделимы)
- Нет повторяющихся групп данных
- Пример нарушения: поле "Телефоны" со значением "123, 456"
  2НФ (Вторая нормальная форма):
- Уже соответствует 1НФ
- Все неключевые атрибуты зависят от всего первичного ключа (а не от его части)
- Пример нарушения: в таблице "Заказ-Товар" с PK (order_id, product_id) хранится product_name (зависит только от product_id)
  3НФ (Третья нормальная форма):
- Уже соответствует 2НФ
- Нет транзитивных зависимостей (неключевые атрибуты не зависят от других неключевых атрибутов)
- Пример нарушения: в таблице "Заказы" хранится customer_phone, который зависит от customer_id, а не напрямую от order_id

## Что_такое_инструкция_TRUNCATE

TRUNCATE — это команда для быстрого удаления всех данных из таблицы без удаления её структуры. Она работает быстрее, чем DELETE,
но не поддерживает условия WHERE и не активирует триггеры.

Работает быстрее, чем DELETE, потому что:
- Не записывает удаляемые строки в журнал транзакций (в большинстве СУБД).
- Не активирует триггеры ON DELETE.
- Не проверяет ограничения FOREIGN KEY (если не указано CASCADE).

Ограничения:
- Нельзя использовать с WHERE (в отличие от DELETE).
- Требует прав DROP на таблицу (в некоторых СУБД).

## Какие_аналитические_функции_поддерживает_SQL

Основные типы аналитических функций:
- Ранжирующие: ROW_NUMBER(), RANK(), DENSE_RANK()
- Агрегатные: SUM(), AVG(), COUNT() с OVER()
- Функции смещения: LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE()
- Функции распределения: NTILE(), PERCENT_RANK(), CUME_DIST()

## Join

1. JOIN-операции (основной инструмент)
  - INNER JOIN - только совпадающие строки
  - LEFT JOIN - все строки из левой таблицы + совпадения справа
  - RIGHT JOIN - все строки из правой таблицы + совпадения слева
  - FULL JOIN - все строки из обеих таблиц
  - CROSS JOIN - декартово произведение (все со всеми)

Операторы PIVOT и UNPIVOT в Transact-SQL предназначены для преобразования данных из строк в столбцы и наоборот, что упрощает анализ и представление информации.
1. PIVOT
   Назначение: Преобразует уникальные значения из одного столбца в несколько столбцов, агрегируя данные.
   Когда использовать:
  - Когда нужно свести строки в столбцы (например, для создания сводных таблиц).
  - Для агрегации данных с группировкой по определенным полям.

2. UNPIVOT
   Назначение: Преобразует столбцы в строки, "разворачивая" данные.
   Когда использовать:
  - Когда нужно нормализовать данные (например, если данные хранятся в виде матрицы).
  - Для обратного преобразования PIVOT.

## Расскажите_об_основных_функциях_ранжирования_в_Transact_SQL

1. ROW_NUMBER() – если нужна строгая уникальная нумерация (например, для пагинации).
   Назначение: Присваивает уникальный порядковый номер каждой строке в результирующем наборе.
   Особенности:
  - Номера идут последовательно (1, 2, 3, ...).
  - Если значения в PARTITION BY одинаковые, номера всё равно будут разными.
2. RANK() – если важно учитывать пропуски (например, спортивные рейтинги).
   Назначение: Присваивает ранг с пропусками (если есть одинаковые значения).
   Особенности:
  - Если значения одинаковые, им присваивается один ранг, а следующий ранг пропускается.
  - Пример: 1, 2, 2, 4 (после двух одинаковых значений следующий ранг — 4).
3. DENSE_RANK() – если нужен ранг без пропусков (например, ранжирование товаров по продажам).
   Назначение: Присваивает ранг без пропусков (если есть одинаковые значения).
   Особенности:
  - Если значения одинаковые, следующий ранг идёт без пропуска.
  - Пример: 1, 2, 2, 3 (в отличие от RANK, где было бы 1, 2, 2, 4).

## Для_чего_используются_операторы_INTERSECT_EXCEPT_в_Transact_SQL

Операторы INTERSECT и EXCEPT в Transact-SQL используются для работы с множествами данных, позволяя находить пересечения и разности между результатами двух запросов.
Они похожи на операции с математическими множествами и работают с наборами строк, возвращаемыми SELECT.
1. INTERSECT (Пересечение)
   Назначение: Возвращает только те строки, которые есть в обоих запросах (аналог логического AND).
   Особенности
  - Удаляет дубликаты (как UNION).
  - Структура столбцов в обоих запросах должна совпадать.
  - Порядок столбцов и их типы данных должны быть согласованы.

2. EXCEPT (Разность)
   Назначение: Возвращает строки из первого запроса, которых нет во втором (аналог MINUS в Oracle).
   Особенности
  - Удаляет дубликаты.
  - Порядок запросов важен: A EXCEPT B ≠ B EXCEPT A.

## CAP
CAP теорема
CAP-теорема - это теорема, которая утверждает, что в распределенных компьютерных системах невозможно одновременно
обеспечить следующие три свойства (CAP): согласованность данных (Consistency), доступность системы (Availability)
и устойчивость к разделению сети (Partition tolerance).

Теорема утверждает, что в любой распределённой системе можно одновременно гарантировать только два из трёх свойств:
1. Consistency (Согласованность) - все узлы видят одни и те же данные в одно и то же время
2. Availability (Доступность) - система всегда возвращает ответ, даже если некоторые узлы недоступны
3. Partition tolerance (Устойчивость к разделению) - система продолжает работать при разрыве связи между узлами

В микросервисной архитектуре каждый сервис должен явно выбирать между:
- CP-системы (согласованность и устойчивость к разделению): например, сервисы обработки финансовых транзакций
- AP-системы (доступность и устойчивость к разделению): например, сервисы кеширования или каталогов товаров

## Аннотации
@Access — типа доступа связанного класса сущности. <br/>
@AssociacionOverride — для переопределения отношений один к одному, многие к одному, один ко многим. <br/>
@AttibuteOverride — для переопределения атрибутов Entity классов у наследованных от встраемых Embeddable классов. <br/>
@Basic — для сопоставления базового типа атрибута столбцу таблицы базы данных. <br/>
@Cacheable — для кэша 2 уровня. <br/>
@CollectionTable — для указания таблицы в которой хранятся значения коллекций. <br/>
@ColumnResult — отображает столбец SQL для заданного Select. <br/>
@ConstructorResult — для сопоставления столбцов запроса Select к конструктору объекта. <br/>
@Converts — аннотация используется для группирования нескольких аннотаций @Convert. <br/>
@ElementCollection — для указания коллекции базового или встраиваемого типа. <br/>
@Embeddable — для указания встраиваемых типов. <br/>
@EntityListeners — для указания массива классов слушателя обратного вызова, которые используются текущей аннотированной сущностью. <br/>
@EntityResult — используется с аннотацией @SqlResultSetMapping для сопоставления выбранных столбцов сущности. <br/>
@Enumerated — используется, чтобы указать, что атрибут entity представляет перечислимый тип. <br/>
@FieldResult — используется для сопоставления выбранных столбцов полям объекта. <br/>
@ForeignKey — используется для сопоставления @JoinColumn. <br/>
@IdClass — определяет объект как составной ключ. <br/>
@Lob — представляет большой тип объекта. <br/>
@MapKey — ключ у нас определяется как java.util.Map. <br/>
@MapKeyClass — ключ у нас определяется как java.util.Map. <br/>
@MapKeyColumn — ключ у нас определяется как java.util.Map. <br/>
@MappedSuperlass — текущие атрибуты аннотированного типа наследуются любой Entity сущностью класса-наследника. <br/>
@MapsId — для @ManyToOne или @OneToOne. <br/>
@NamedQuery — для указания JPQL-запроса, который впоследствии можно найти по его имени. <br/>
@PersistenceContext — используется для указания EntityManager, который необходимо ввести как зависимость. <br/>
@PersistenceContexts — используется для группирования нескольких @PersistenceContext аннотаций. <br/>
@PostLoad — используется для указания метода обратного вызова, который срабатывает после загрузки объекта. <br/>
@PostPersist — используется для обратного вызова, который срабатывает после сохранения объекта. <br/>
@PostRemove — используется для обратного вызова, который срабатывает после удаления объекта. <br/>
@PostUpdate — используется для обратного вызова, который срабатывает после обновления объекта. <br/>
@PrePersist — используется для обратного вызова, который срабатывает до того, как объект будет сохранен. <br/>
@PreRemove — используется для обратного вызова, который срабатывает до удаления объекта. <br/>
@PreUpdate — используется для обратного вызова, который срабатывает до обновления объекта. <br/>
@SecondaryTable — используется для указания вторичной таблицы. <br/>
@SecondaryTables — используется для группирования нескольких аннотаций @SecondaryTable. <br/>
@SequenceGenerator — используется для указания последовательности базы данных, используемой генератором идентификатора. <br/>
@SqlResultSetMapping — используется для указания отображения ResultSet собственного SQL-запроса или хранимой процедуры. <br/>
@SqlResultSetMappings — является аннотацией нескольких групп @SqlResultSetMapping. <br/>
@StoredProcedureParameter — используется для указания параметра @NamedStoredProcedureQuery. <br/>
@TableGenerator — используемая для генерации идентификаторов. <br/>
@Temporal — используется для указания TemporalType атрибута java.util.Date или java.util.Calendar.  <br/>
@Transient — используется для указания того, что данный атрибут сущности не должен сохраняться. <br/>
@Version — используется для указания атрибута версии Entity, используемого для оптимистической блокировки. <br/>

## NoSql
Они бывают:
1. ключ-значение: reddis
2. документоориентированные MongoDB and ElasticSearch
3. графовые Neo4j and Neptune
4. колоночные
