


-[JRE_JVM_JDK](#JRE_JVM_JDK) <br>
-[ООП](#ООП) <br>
-[JPA_ORM](#JPA_ORM) <br>
-[Транзакции](#Транзакции) <br>
-[Entity](#Entity) <br>
-[AOP](#AOP) <br>
-[Паттерны](#Паттерны) <br>
-[Параметры_для_аннотаций](#Параметры_для_аннотаций) <br>
-[Виды_функциональных_интерфейсов](#Виды_функциональных_интерфейсов) <br>
-[Коллекции_скорость](#Коллекции_скорость) <br>
-[Коллекции_виды](#Коллекции_виды) <br>
-[Docker](#Docker) <br>
-[CAP](#CAP) <br>
-[Kubernetes](#Kubernetes) <br>
-[Reddis](#Reddis) <br>
-[Кода ошибок](#Кода_ошибок) <br>
-[Сертификат](#Сертификат) <br>
-[Протоколы](#Протоколы) <br>
-[Микросервисы](#Микросервисы) <br>

## ООП
1. **<u>Инкапсуляция</u>** - позволяет скрыть детали реализации объекта (данные и методы) в классе от пользователя предоставив только то
   что необходимо при использовании. Тоесть пользователь не должен вникать во внутреннюю реализацию класса а лишь использовать
   те классы которые открыты или описаны в интерфейсе.
2. Наследование - позволяет создавать новые классы на основе уже существующих, добавляя при необходимости новые свойства и
   методы.(допустим есть телефон который умеет звонить а от него наследуются разные операторы которые добавляют к логике
   звонить еще свою)
3. Полиморфизм - позволяет объектам с одинаковым интерфейсом иметь различную реализацию.
   (к примеру метод который имеет printLn а уже каждый класс определяет что необходимо напечатать) (динамический,статический)
4. Абстракция

Ассоциация - объекты двух классов могут ссылаться один на другой, имея связь друг с другом.
(Типы: один к одному, Многие ко многим) <br>
агрегация - ассоциация со слабой связью. односторонняя связь с одноправленным отношением. (Пример: двигатель и автомобиль) <br>
композиция - это ассоциация с сильной связью. Когда класс владеет объектом и несет ответственность за его время жизни.
(сотрудник и роль)

## Что_такое_ковариантность_типов

Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке.
ковариация — это если бы мы могли переменной типа List<Animal> задать объект типа ArrayList<Dog>

Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>.

Инвариантность — ситуация, когда наследование исходных типов не переносится на производные.

## JRE_JVM_JDK
JRE,JVM,JDK
1. JRE - пакет для запуска Java (включает в себя JVM, библиотеки классов)
2. JVM - выполняет Java-байткод
3. JDK - включает в себя всё необходимое для разработки (javac,библиотеки)

## JPA_ORM
JPA - это стандартный Java-интерфейс для ORM, который описывает, как объекты Java должны сохраняться в реляционной
базе данных. Это не реализация, а спецификация. <br>
ORM — это технология для работы с БД через объекты в Java. Я чаще всего использую Hibernate,
так как он реализует JPA и снижает объем шаблонного кода. <br>
EntityManager – это легковесный объект, который выполняет CRUD-операции с Entity и управляет их жизненным циклом. <br>
Criteria - Используется для создания и выполнения объекто-ориентированных запроса на получение объектов. <br>
PersistenceContext — это контейнер (или "кэш первого уровня"), который управляет жизненным циклом сущностей (Entity)
в рамках одной транзакции или сессии. <br>
Триггер (Trigger) — это специальная хранимая процедура в базе данных, которая автоматически выполняется при наступлении
определенного события


## Коллекции_скорость
       Скорость работы коллекций <br>
List реализации <br>
Коллекция	           Получение (get)	Добавление (add)	  Удаление (remove)	    Поиск (contains) <br>
ArrayList	             O(1)	           O(1)* / O(n)	        O(n)	                 O(n) <br>
LinkedList	             O(n)	           O(1)	                O(1)	                 O(n) <br>
CopyOnWriteArrayList	    O(1)	           O(n)	                O(n)	                 O(n) <br>
Set реализации <br>
Коллекция	                            Добавление (add)	  Удаление (remove)	    Поиск (contains) <br>
HashSet	                                O(1)	              O(1)	                 O(1) <br>
LinkedHashSet	                          O(1)	              O(1)	                 O(1) <br>
TreeSet	                                O(log n)	          O(log n)	             O(log n) <br>
CopyOnWriteArraySet	                    O(n)	              O(n)	                 O(n) <br>
Map реализации <br>
Коллекция	           Получение (get)  Вставка (put)	  	   Удаление (remove)	  Поиск (containsKey) <br>
HashMap	               O(1)	            O(1)	              O(1)                   O(1) <br>
LinkedHashMap	         O(1)	            O(1)	              O(1)                   O(1) <br>
TreeMap	               O(log n)	        O(log n)	          O(log n)	             O(log n) <br>
ConcurrentHashMap	     O(1)	            O(1)	              O(1)                   O(1) <br>
Hashtable	             O(1)	            O(1)	              O(1)                   O(1) <br>
Queue/Deque реализации <br>
Коллекция	                             Добавление (offer)	 Удаление (poll)	    Просмотр (peek) <br>
ArrayDeque	                            O(1)	              O(1)	                 O(1) <br>
PriorityQueue	                          O(log n)	          O(log n)	             O(1) <br>
ConcurrentLinkedQueue	                  O(1)	              O(1)	                 O(1) <br>

## Коллекции_виды

Коллекции: Iterable -> Collection -> (List,Queue, Set) <br>
List: ArrayList, LinkedList, Vector -> Stack <br>
Set: HashSet, LinkedHashSet, SortedSet -> TreeSet, (IdentityHashSet - доп) <br>
Queue: PriorityQueue, Deque, LinkedList, ArrayDeque <br>

Map: HashMap, LinkedHashMap, SortedMap -> TreeMap, (WeakHashMap - доп)

Многопоточка: CopyOnWriteArrayList, ConcurrentHashMap

1. ArrayList
2. LinkedList
3. Vector: Старая коллекция. динамический массив типа ArrayList но синхронизирован и медленный.
4. Stack: LIFO. Структура данных стек, является подклассом Vector. Принцип работы LIFO. Потокобезопасен.
  - методы: push(добавляет), pop(удаляети возвращает вершину), peek(возвращает вершину), empty(проверка), search(поиск позиции элем.)
  - используется: Парсинг выражений (проверка скобок, HTML). Обратный порядок выполнения.

1. HashSet: уникальные элементы без гарантии порядка.
  - add в среднем O(1), в худшем при коллизиях 0(n).
  - remove\contain\size: O(1).
2. LinkedHashSet: Хранит уникальные элементы с порядком их добавления. Высокопроизводительная. Удаление дубликатов без потери порядка.
- add в среднем O(1), в худшем при коллизиях 0(n).
- remove\contain\size: O(1).
3. SortedSet: Реализацией является TreeSet. Элементы отсортированы. Предоставляет сортировку по естественном порядку (Comparable) или с помощью Comporator.
  - add/remove/contains: O(log n)
  - first/last: O(1)
  - методы: first/last/headSet(E elem) возвр.подмножество элем.строго меньше elem/tailSet(E elem) возвр.подмножество элем.больше или равно elem/subSet(E fromE, toE)возвр.подмножество в диапазоне/comparator
4. TreeSet: Элементы отсортированы с использованием самобалансирующего красно-черного дерева. Используется для элементов в отсорт. порядке,
   нужны диапазоны значений(headSet, tailSet), часто требуется first, last элем. Запрет на null значения.
  - add/remove/contains O(log n)
  - first/last/size/isEmpty O(1)
5. IdentityHashSet: сравнение элементов по == а не по equals(). порядок не гарантируется. Производительность как и у hashmap.

1. PriorityQueue: это очередь с приоритетами, которая хранит элементы в отсортированном порядке(по умолчанию — натуральный порядок или компаратор).
   Использует Comparator или естественный порядок (Comparable). Основана на двоичной мин-куче— это дерево, где каждый родитель меньше своих потомков.
  - offer/add/poll - O(log n)
  - remove/contains - O(n)
  - peek/size - O(1)
  - методы: offer(E e)(добавляет элемент), poll(удаляет и возвращает голову), element(возвращает голову или exception), peek(возвращает голову или null)
2. Deque: Добавление/удаление с обоих концов (головы и хвоста). Разрешены Null элементы.
  - методы: addFirst, offerFirst(добавляет в начало или false), removeFirst, pollFirst(удаляет первый), getFirst(получает первый или exception), peekFirst(получает первый или null)
  - все операции: О(1)
3. ArrayDeque: реализация Deque на основе массива. Автоматическое расширение, может работать как стек и очередь одновременно. Не поддерживает null.
  - addFirst\addLast\removeFirst\removeLast\peekFirst\size - O(1)
  - contains\iterator - O(n)
  - методы: addFirst/addLast. removeFirst\removeLast. peekFirst\peekLast. size\contains

1. HashMap:
  - Добавление: О(1)
  - получение\удаление: в зависимости распределения хэш-функций(присутствуют ли коллизии). В идеале О(1), но может быть и О(n)
2. LinkedHashMap: упорядоченная по добавлению хэш-таблица. Сохраняет порядок элементов. Поддержка null значений.
  - put\get\remove\containsKey - O(1)
3. TreeMap: реализована как красно-чёрное дерево, которая хранит элементы в отсортированном порядке сс использованием красно-черного дерева, что позволяет эффективно работать с диапазонами.
  - put\get\remove\containsKey -O(log n)
  - firstKey\lastKey - O(1)
    Сортировка ключей: по естественному порядку (Comparable) или через Comparator
    Порядок итерации: элементы возвращаются в отсортированном порядке
  - Новый элемент добавляется в дерево, как если бы TreeMap была обычным бинарным деревом поиска.
  - Затем производится перебалансировка дерева с помощью поворотов и изменения цвета узлов.
  - TreeMap автоматически упорядочивает элементы в соответствии с естественным порядком или с помощью компаратора
4. WeekHashMap:

Set<T> t = new HashSet(); <br>
Set<T> t = new LinkedHashSet(); <br>
SortedSet<T> t = new TreeSet(); <br>
Set<T> t = new TreeSet(); <br>
Queue<T> t = new PriorityQueue(); <br>
Deque<T> t = new ArrayDeque(); <br>
Map<T,T> t = new TreeMap(); <br>
Map<T,T> t = new LinkedHashMap(); <br>

## Entity
Методы операций над Entity:
1. persist (добавление Entity под управление JPA)
2. merge (обновление)
3. remove (удаления)
4. refresh (обновление данных)
5. detach (удаление из управление JPA)
6. lock (блокирование Enity от изменений в других thread).

Жизненный цикл Entity:
1. new - объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
2. managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи.
3. detached — объект был создан, но не управляется (или больше не управляется) JPA.
4. removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.

## Транзакции
У @Transactional есть ряд параметров:
1. @Transactional (isolation=Isolation.READ_COMMITTED) - уровень изоляции.
2. @Transactional(timeout=60) - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной
   системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение
   об откате не отвечающих транзакций.
3. @Transactional(propagation=Propagation.REQUIRED_NEW) - (Если не указано, распространяющееся поведение по умолчанию —
   REQUIRED.)

2 типа управления транзакции:
1. програмное - Используется TransactionTemplate, либо через реализацию PlatformTransactionManager напрямую.
2. декларативное - Отделяется управление транзакциями от бизнес-логики. Мы используем только
   аннотации @Transactional и конфигурацией на основе XML для управления транзакциями

Типы Propagation (пропагнации) в транзакциях:
1. REQUIRED (по умолчанию) — если есть транзакция, используется она, иначе создаётся новая.
2. REQUIRES_NEW — всегда создаёт новую транзакцию, приостанавливая текущую.
3. SUPPORTS — работает в транзакции, если она есть, но не создаёт новую.
4. NOT_SUPPORTED — приостанавливает текущую транзакцию, если она есть.
5. MANDATORY — требует активной транзакции, иначе — исключение.
6. NEVER — запрещает транзакцию, иначе — исключение.
7. NESTED — вложенная транзакция (поддерживается не всеми БД, например, работает в MySQL с InnoDB).

Уровни изоляции транзакций:
1. TRANSACTION_NONE – драйвер не поддерживает транзакции;
2. TRANSACTION_READ_UNCOMMITTED – транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены.
   не спасает не от чего.
3. TRANSACTION_READ_COMMITTED – транзакция может читать только те изменения в других параллельных транзакциях,
   которые уже были закоммичены.
   Это нас спасает от грязного чтения но не спасает от неповторяющегося чтения и от фантомного чтения.
4. TRANSACTION_REPEATABLE_READ – пока транзакция не завершится, никто параллельно не может изменять или удалять строки,
   которые транзакция уже прочитала.
   Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения.
5. TRANSACTION_SERIALIZABLE – блокирует любые действия, пока запущена транзакция.

Грязное чтение - когда данные, которые я прочитал, кто-то может откатить ещё до того, как я завершу свою транзакцию. <br>
Неповторяющееся чтение - я могу дважды прочитать одни и те же строки в одной транзакции в разное время и получить разный результат. <br>
Фантомное чтение - Данные которые я прочитал и когда в итоге я хочу закомитить свою транзакцию то кол-во строк данных отличается. <br>

## AOP
Join Point — это точка в выполнении программы, где может быть применён аспект, например, вызов метода или
обработка исключения. <br>
Advice — это код, который выполняется в определенных точках (join points) программы для добавления сквозной
функциональности. <br>
Pointcut определяет "где" (какие методы перехватывать). <br>
Advice определяет "что делать" в этих точках. <br>
Aspect — это модуль, объединяющий Advice и Pointcut. <br>

Конкуренция — это способ одновременного решения множества задач. <br>
Параллелизм — это способ выполнения разных частей одной задачи. <br>
Процесс — экземпляр программы во время выполнения, независимый объект. Каждый процесс выполняется в отдельном адресном пространстве <br\>
Поток(thread) — способ выполнения процесса, определяющий последовательность исполнения кода в процессе. <br\>
Потоки всегда создаются в контексте какого-либо процесса

## Параметры_для_аннотаций
Аннотации:
@Target - указывается, какой элемент программы будет использоваться аннотацией
Свойства:
1. PACKAGE - назначением является целый пакет (package);
2. TYPE - класс, интерфейс, enum или другая аннотация:
3. METHOD - метод класса, но не конструктор (для конструкторов есть отдельный тип CONSTRUCTOR);
4. PARAMETER - параметр метода;
5. CONSTRUCTOR - конструктор;
6. FIELD - поля-свойства класса;

@Retention - указываем, в какой момент жизни программного кода будет доступна аннотация
Свойства:
1. SOURCE - аннотация доступна только в исходном коде и сбрасывается во время создания .class файла;
2. CLASS - аннотация хранится в .class файле, но недоступна во время выполнения программы;
3. RUNTIME - аннотация хранится в .class файле и доступна во время выполнения программы.

## Виды_функциональных_интерфейсов
Виды функциональных интерфейсов:
1. Function - принимает 1 аргумент и возвращает аргумент
2. Predicate - принимает 1 аргумент и возвращает true\false
3. Consumer - принимает 1 аргумент нечего не возвращает (void)
4. Supplier - нечего не принимает и возвращает аргумент

## Docker
Docker Image - Образ докера это как снимок экземпляра приложения который в себе содержит все необходимое для запуска. <br>
Слой - это изменение файловой системы, которое возникает при выполнении каждой инструкции в Dockerfile. <br>
Docker container - запущенный экземпляр образа. <br>
Dockerfile — это текстовый файл с инструкциями для сборки Docker-образа. <br>
Docker Machine — это утилита для автоматического развертывания Docker-хостов на различных платформах. <br>
Docker Swarm — это встроенная в Docker система оркестрации контейнеров. <br>

Dockerfile — это 'сборка' (как Maven для образа) <br>
Compose — это 'оркестрация' (как дирижер для контейнеров) <br>

Виртуализация — это абстрактная версия физической машины (Позволяет разработчикам запускать и размещать несколько ОС на
оборудовании одного физического сервера)

контейнеризация — это абстрактная версия приложения. (Помогает разработчикам развернуть несколько приложений с использованием
одной и той же операционной системы)

Пример минимального Dockerfile для Java: <br>
FROM eclipse-temurin:17-jdk //Базовый образ с JDK <br>
COPY target/my-app.jar /app.jar  //Добавление JAR-файла <br>
CMD ["java", "-jar", "/app.jar"]  //Команда запуска <br>

CNM (Container Network Model)
Внутри Docker Desktop есть несколько DNS-серверов.
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов.

docker system prune - Эта команда очищает неиспользуемые ресурсы Docker. <br>
FROM - Задаёт базовый (родительский) образ. <br>
ENV - Создаёт переменную окружения <br>
COPY - Копирует файл с основной системы в контейнер (обеспечивает только базовую поддержку копирования локальных файлов в контейнер) <br>
ADD - Копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или url <br>
RUN - это 'сборка' (аналог фазы Maven package). Выполняет команду и создаёт слой образа <br>
ENTRYPOINT - это 'запуск' Определяет исполняемую команду (аналог main() в java) <br>
CMD - Задает аргументы по умолчанию для ENTRYPOINT <br>
ARG - позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. <br>

Основные команды:
1. Запуск: `docker run -d --name my_container nginx`
2. Просмотр запущенных контейнеров: `docker ps` и включая остановленные`docker ps -a`
3. Остановка контейнера `docker stop <контейнер_ID_или_имя>`
4. Удаление контейнера `docker rm <контейнер_ID_или_имя>`
5. Просмотр логов контейнера `docker logs <контейнер_ID_или_имя>`
6. Вход в запущенный контейнер `docker exec -it <контейнер_ID_или_имя> /bin/bash`
7. Запуск остановленного контейнера `docker start <контейнер_ID_или_имя>`
8. Перезапуск контейнера `docker restart <контейнер_ID_или_имя>`
9. Поиск образа `docker search <название_образа>`
10. Скачивание образа `docker pull <образ>:<тег>`
11. Сборка образа из Dockerfile `docker build -t <имя_образа> .`
12. Просмотр списка сетей `docker network ls`
13. Подключение контейнера к сети `docker network connect <сеть> <контейнер>`
14. Просмотр списка томов `docker volume ls`
15. Просмотр использования ресурсов `docker stats`
16. Детальная информация о контейнере `docker inspect <контейнер_ID_или_имя> | grep -i "cpu\|memory"`

## CAP
CAP теорема <br\>
CAP-теорема - это теорема, которая утверждает, что в распределенных компьютерных системах невозможно одновременно
обеспечить следующие три свойства (CAP): согласованность данных (Consistency), доступность системы (Availability)
и устойчивость к разделению сети (Partition tolerance).

Теорема утверждает, что в любой распределённой системе можно одновременно гарантировать только два из трёх свойств:
1. Consistency (Согласованность) - все узлы видят одни и те же данные в одно и то же время
2. Availability (Доступность) - система всегда возвращает ответ, даже если некоторые узлы недоступны
3. Partition tolerance (Устойчивость к разделению) - система продолжает работать при разрыве связи между узлами

В микросервисной архитектуре каждый сервис должен явно выбирать между:
- CP-системы (согласованность и устойчивость к разделению): например, сервисы обработки финансовых транзакций
- AP-системы (доступность и устойчивость к разделению): например, сервисы кеширования или каталогов товаров

## Kubernetes

1. Master-нода (Control Plane)
   Master — это "мозг" кластера Kubernetes. Он управляет всем кластером, принимает решения о развертывании,
   масштабировании и обеспечивает отказоустойчивость.
   Основные компоненты Master-ноды:
1. kube-apiserver
   - Что делает? Главный интерфейс для управления кластером.
   - Как работает? Принимает REST-запросы от пользователей (kubectl), валидирует их и обновляет состояние в etcd.
   - Пример: Когда ты запускаешь kubectl create deployment, запрос идёт именно сюда.
2. etcd
   - Что делает? Распределённое key-value хранилище, где хранится все состояние кластера (конфиги, секреты, метаданные).
   - Как работает? Работает по алгоритму консенсуса Raft (как в Consul). Если etcd падает — кластер становится неуправляемым.
3. kube-scheduler
   - Что делает? Решает, на какой Worker-ноде запускать под (Pod).
   - Как работает? Анализирует:
  - Достаточно ли на ноде CPU/RAM?
  - Есть ли ограничения (tolerations, node affinity)?
  - Какая нода менее загружена?
4. kube-controller-manager
   - Что делает? Следит за тем, чтобы текущее состояние кластера соответствовало желаемому (declarative approach).
   - Какие контроллеры внутри?
  - Deployment Controller – следит за репликами подов.
  - Node Controller – реагирует на отвалившиеся ноды.
  - Endpoint Controller – связывает сервисы и поды.

2. Worker-ноды
   Worker — это рабочие серверы, на которых фактически запускаются контейнеры.
   Основные компоненты Worker-ноды
1. kubelet
   - Что делает? "Агент" на Worker-ноде, который запускает и контролирует поды.
   - Как работает?
  - Получает команды от Master-ноды ("запусти под с таким-то образом").
  - Следит, чтобы контейнеры в подах были живы.
  - Отчитывается Master-ноде о состоянии ноды.
2. kube-proxy
   - Что делает? Обеспечивает сетевую коммуникацию между сервисами.
   - Как работает?
  - Настраивает правила iptables/IPVS для балансировки нагрузки.
  - Позволяет подам внутри кластера находить друг друга по DNS или ClusterIP.
3. Container Runtime
   - Что делает? Запускает контейнеры (например, Docker, containerd, CRI-O).
   - Как работает?
  - Получает от kubelet команду: "Запусти контейнер из образа nginx:latest".
  - Скачивает образ и запускает контейнер.

Как Master и Worker взаимодействуют?
- Ты отправляешь команду через kubectl → она попадает в kube-apiserver.
- kube-scheduler решает, на какой Worker-ноде запустить под.
- kubelet на Worker-ноде получает задание и запускает контейнер через Container Runtime.
- kube-proxy настраивает сетевые правила, чтобы под был доступен.
- Controller Manager следит, чтобы всё работало как задумано.

Sidecar — это архитектурный паттерн, при котором вспомогательный контейнер (sidecar) работает вместе с основным
контейнером в одном Pod, расширяя его функциональность без изменения кода основного приложения.

etcd — это распределённое key-value хранилище, используемое Kubernetes как основная база данных для хранения всего состояния кластера.
Это критически важный компонент Control Plane, без которого кластер не сможет функционировать.

kube-proxy — это компонент Kubernetes, который работает на каждой ноде кластера и отвечает за маршрутизацию трафика к
сервисам (Services). Он обеспечивает, чтобы запросы к сервису (например, по ClusterIP, NodePort или LoadBalancer) корректно
перенаправлялись на подходящие Pod'ы.

## Reddis

Типы данных reddis:
1. базовые - встроенные, нативные типы(они очень быстрые т.к. реализованы на языке C без внешних зависимостей)
   String, List, Set, Sorted Set, Hash, Stream, Bitmap, Bitfield, Geospatial, HyperLogLog.
2. модульные
   JSON, Time Series, Bloom Filter,Cuckoo Filter

Стратегии кэширования:
1. Cache-Aside(Lazy-loading)
2. Read-Through
3. Write-Through
4. Write-Behind
5. Full Page/Fragment Cache

Инвалидация кэша:
1. Time-based(TTL)
2. Explicit Invalidate
3. Versioning
4. Event-based
5. Write through/Write-behind
6. Cache Buster/Soft Invalidate

## Кода_ошибок

Клиентские 400
Серверные 500

400 - bar request сервер не принимает запрос из за синтаксиса
401 - требуется аутенфикация
403 - доступ запрещен
404 - ресурс не найден
408 - сервер не дождался запроса от клиента
429 - превышен лимит запросов

500 - общая ошибка сервера (сбой в коде)
501 - не поддерживает функциональность запроса
502 - bad gateway - прокси-сервер получил не допустимы ответ от сервера.
503 - сервер временно не доступен
504 - сервер не дождался ответа
505 - сервер не поддерживает версию http запроса.

## Сертификат

1. Клиент → Серверу: ClientHello
2. Сервер → Клиенту
  - ServerHello (выбранный шифр).
  - Сертификат сервера
3. Сервер запрашивает сертификат клиента (CertificateRequest)
4. Клиент проверяет сертификат сервера
5. Клиент генерирует pre-master key, шифрует его публичным ключом сервера и отправляет серверу.
6. Клиент отправляет свой сертификат
7. Сервер расшифровывает pre-master key своим приватным ключом.
8. Сервер проверяет сертификат клиента (так же, как клиент проверял серверный).
9. Обе стороны вычисляют общий сессионный ключ (для симметричного шифрования).
10. Далее – обмен ключами как в обычном TLS.
    Как проверяется сертификат?
1. Проверка подписи CA
  - Клиент проверяет, что сертификат подписан доверенным УЦ (CA).
  - Проверяется цепочка сертификатов (Root CA → Intermediate CA → Серверный сертификат).
2. Проверка срока действия
3. Проверка имени (SAN/CN)

## Протоколы
Протоколы
1. Транспортные протоколы
- TCP - обеспечивает гарантированную доставку данных между приложениями. Перед передачей данных клиент и сервер выполняют
  "рукопожатие" (HTTP, БД, файловые передачи)
  Данные разбиваются на сегменты.
  Каждый сегмент нумеруется (Seq), получатель подтверждает (ACK) получение.
  Если ACK не пришел за время таймаута, данные пересылаются.
- UDP - обеспечивает быструю передачу данных без установки соединения (Стриминг, игры)
2. Сетевые протоколы
- IPv4 / IPv6 - отвечает за маршрутизацию и доставку пакетов между устройствами в сети. IP не гарантирует, что пакет дойдет до
  получателя
  - Каждый роутер содержит таблицу маршрутизации, которая определяет, куда отправить пакет.
  - Если IP-адрес получателя в локальной сети – пакет отправляется напрямую (через ARP).
  - Если нет – пакет пересылается на шлюз (gateway) по умолчанию.
3. Прикладные протоколы
- HTTP
  - Протокол для передачи данных между клиентом (браузером) и сервером.
  - Работает на порту 80.
  - Данные передаются в открытом виде
  - Данные передаются в текстовом формате → их можно перехватить
- HTTPS
  - Защищённая версия HTTP с шифрованием.
  - Работает на порту 443.
  - Использует SSL/TLS для шифрования данных.
    Как работает?
    - "Рукопожатие" (Handshake)
    - Браузер и сервер согласовывают параметры шифрования.
    - Сервер отправляет SSL-сертификат для проверки подлинности.
    - Обмен ключами
    - Создаётся сеансовый ключ для шифрования данных.
- WebSocket
- REST
- gRPC - это пакетная технология передачи данных
- GraphQL
4. Электронная почта
- SMTP

## Микросервисы

1. `Circuit Breaker` - Это механизм, который предотвращает распространение сбоев в системе. Он обеспечивает отказоустойчивость, переключая
   запросы на альтернативные сервисы или возвращая значения по умолчанию, если сервис недоступен.
   Состояния Circuit Breaker:
   - Closed (Закрыто) — запросы проходят нормально.
     В закрытом состоянии Circuit Breaker позволяет запросам проходить к защищаемому сервису. Это нормальное рабочее состояние.
   - Open (Разомкнуто) — все запросы мгновенно отклоняются.
     В открытом состоянии Circuit Breaker блокирует все попытки выполнить запрос к защищаемому сервису. Это профилактическая мера, предотвращающая дальнейшее распространение ошибок.
   - Half-Open (Полуоткрыто) — пробует пропустить несколько запросов для проверки восстановления сервиса.
     Полуоткрытое состояние - это переходное состояние, в котором Circuit Breaker начинает частично разрешать запросы к сервису для тестирования его доступности и надежности.
2. `Apigateway` - это сервер, который выступает в роли единой точки входа для клиентов
    Основные задачи API Gateway:
    - Маршрутизация запросов
    - Агрегация данных (Объединяет ответы от нескольких сервисов в один (например, данные пользователя + его заказы).)
    - Аутентификация и авторизация
    - Лимитирование запросов (Rate Limiting)
    - Кэширование
    - Обработка ошибок и Circuit Breaker
    Популярные API Gateway:
     1. NGINX
     2. Spring Cloud Gateway
3. `Saga` - Паттерн Saga сосредотачивается на достижении атомарности каждого шага транзакции в микросервисной архитектуре.
4. `CQRS` - это подход, разделяющий модели для чтения (Query) и записи (Command) данных. Вместо единой модели, как в классическом CRUD.
5. `SOA` - это набор архитектурных принципов в котором объекты независимы и слабо связаны. Тоесть мы разбиваем все на сервисы (платежи, логирование) которые разрабатываются и работают независимо друг от друга.
6. `DDD_Domain_Driven_Design` - это подход который фокусируется на бизнес-логике и доменной модели. Необходим где надо четке разделение бизнес-логики.
7. `РАСТ` - это инструмент для тестирования и контрактного тестирования между поставщиком и потребителем в микросервисной архитектуре.
    цель PACT в микросервисной архитектуре заключается в обеспечении согласованности и надежности взаимодействия между сервисами путем создания контрактов и автоматического тестирования.
8. `Retry_pattern` - представляет собой подход, который позволяет обрабатывать временные сбои
    при попытке подключения к сервису или сетевому ресурсу. Этот шаблон позволяет приложению автоматически повторять запросы, которые
    не удалось выполнить из-за временных проблем, таких как сетевые задержки, ошибки сервера или перегрузка ресурсов.
9. `Explain_Sidecar` - это архитектурный шаблон, который используется в микросервисной архитектуре для добавления дополнительной
    функциональности к основному сервису без изменения его кода.
10. `Explain_Outbox` - Он используется для обеспечения надежной и атомарной доставки событий или сообщений между различными сервисами.
    Outbox представляет собой специальную таблицу в базе данных, которая служит буфером для записи событий или сообщений, которые должны
    быть отправлены другим сервисам.

## Паттерны
L - Принцип подстановки Барбары Лисков - класс который наследовался от родителя не должен
ломать интерфейс. Допустим если мы наследовались от класс который не бросает Exception а я бросаю Exception то
родительский класс может этого не знать и у него будет не объяснимое поведение.
D - Принцип инверсии зависимостей - класс должен зависеть не от реализации а от абстракций. Тоесть класс должен быть написан
так чтобы он зависел не от конкретной реализации а от интерфейса.(SQLDatabase)
Например, класс, который использует базу данных, должен зависеть от абстрактного интерфейса базы данных, а не от конкретной
реализации базы данных.

1. Порождающие - абстрагируют процесс создание экземпляра. Позволяют сделать систему
   независимой от способа создания, композиции и представления объектов.
2. Структурные - определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его
   реализацию, позволяя облегчить разработку и оптимизировать программу.
3. Поведения - определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

Порождающие:
1. Абстрактная фабрика - представляет собой интерфейс для создания других классов.
2. Строитель (Builder) - представляет собой интерфейс для создания сложного объекта. Тоесть позволяет шаг за шагом строить сложные объекты.
3. Фабричный метод (Factory method) - Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой
   класс инстанцировать
4. Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через
   конструктор.
5. Одиночка (Singleton)

Структурные:
1. Адаптер - Позволяет несовместимым интерфейсам работать вместе.
2. Мост (Bridge) - позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. Есть интерфейс с методом,
   мы его через конструктор можем передать в абстрактный класс без реализации методов а потом уже в классе в котором будем
   реализовывать абстрактный класс
3. Компоновщик (Composite) - Объединяет объекты в древовидные структуры.
4. Декоратор (Decorator) - Динамически добавляет новую функциональность объекту, не меняя основной класс. (когда класс реализует интерфейс, имплементит
   его метод и добавляет дополнительные методы)
5. Фасад (Facade) - Предоставляет упрощенный интерфейс к сложной системе. (тоесть это реализован метод в котором находятся
   множество взаимодействий с дочерними классами их вызов и логика)
6. Приспособленец (Flyweight) - Тоесть в классе есть метод который служит как фабрикой для создания классов.
7. Заместитель (Proxy)

Поведения:
1. Цепочка обязанностей (Chain of responsibility)
2. Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта
3. Наблюдатель (Observer) - Позволяет объектам уведомлять подписчиков об изменениях.
4. Стратегия (Strategy) - Инкапсулирует алгоритмы в отдельные классы, делая их взаимозаменяемыми. Тоесть Мы отделяем процедуру
   выбора алгоритма от его конкретных реализаций.

