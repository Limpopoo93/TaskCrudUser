## сулиманов

## Разница Процесса и потока

Процесс - экземпляр выполняемой программы, а так же текущее значения команд, переменных. Для каждого процесса ОС выделяет свою
stack и heap память. Внутри которой работают потоки. 
Поток - основная единица которой операционная система выделяет время процессора. Тоесть внутри процесса у нас есть потоки.

## Отличие многопоточности от параллелизма

Отличие в том что многопоточность это когда в одном приложении несколько потоков, но они не могут выполняться параллельно т.к. общее CPU (процессоры)
а параллелизм это когда так же несколько потоков и ОС имеет более одного CPU (процессора) позволяя выполняться потокам параллельно в 
зависимости от колво CPU (процессора)

## deamont поток

это поток который присваивается флагом isDaemon и он всегда выполняется в фоне и завершается только тогда когда завершается основной
поток main.
Он имеет низкий приоритет, Необходим когда важно чтобы поток не был завершен сразу по завершении выполнения а только когда main будет
завершен.

## Синхронизация данных

Процесс имеет Stack и heap память. 
Stack хранит стек вызовов методов, локальные переменные и аргументы методов.
Heap хранит объекты.
У каждого потока своя stack память, но все потоки имеют общую heap память.

## synchronized блок

Ниже код мы передаем класс в блок synchronized и это говорит что мы делаем блокировку на уровне класса. Это означает что когда поток
дойдет до блока synchronized
он заблочит класс и остальные потоки не смогут достучаться до других методов synchronized. Такой вариант работает медленне.
Отличия:
`public class IncrementCounterSynchronizedBlockDemo {
   private Integer counter;
   private Integer anotherCounter;

   private static void incrementCounter() {
     synchronized (IncrementCounterSynchronizedBlockDemo.class) {
       counter++;
     }
   }
   private static void incrementCounter() {
     synchronized (IncrementCounterSynchronizedBlockDemo.class) {
       anotherCounter++;
     }
   }
}`

Второй вариант который работает быстрее. Тут два отдельных монитора (counterLock, anotherCounterLock) которые работают параллельно 
не блокируя друг друга.
В таком случае у нас нету контроля над потоками кто захватил кто освободил какой монитор.

`public class IncrementCounterSynchronizedBlockDemo {
    private Integer counter;
    private Integer anotherCounter;
    private Object counterLock = new Object();
    private Object anotherCounterLock = new Object();
    
    private static void incrementCounter() {
       synchronized (counterLock) {
          counter++;
       }
    }
    private static void incrementCounter() {
       synchronized (anotherCounterLock) {
          anotherCounter++;
       }
    }
}`

Для того чтобы был контроль над тем какой поток захватил какой освободил были созданы синхронизаторы это Lock и Semaphore.

## ReentrantLock

Реализация Lock. Он захватывает монитор в counterLock.lock(); потом увеличивает counter и освобождает монитор counterLock.unlock()

`public class IncrementCounterSynchronizedBlockDemo {
   private Integer counter;
   private Lock counterLock = new ReentrantLock();

   private static void incrementCounter() {
     counterLock.lock();
     counter++;
     counterLock.unlock();
  }
}
`

## Механизм передачи данных между потоками

Для этого используется класс Exchanger.
`Exchanger<AtomicInteger> exchanger = new Exchanger<>();`
Этот класс позволяет обмениваться данными но он не синхронизирован и синхронизацию должны делать мы.

## DeadLock LiveLock Starvation

DeadLock - ситуация когда 2 и более потока ждут бесконечно ресурс который занял другой поток.
  процесс1 захватил ресурс1 и ждет ресурс2
  процесс2 захватил ресурс2 и ждет ресурс1
Livelock - система занимается бесполезной работой (не в режиме блокировки) состояние системы постоянно меняется но тем не менее она зациклилась и не производит полезную работу.
  процесс1 приходит к общему ресурс и спрашивает процесс2 работает? если да то он говорит я подожду пока процесс2 не зайдет в этот блок
  процесс2 так же приходит к общему ресурсу только спрашивает процесс1 доступен и если да то тоже уступает ему место в итоге два потока ждут выполнения друг друга
Starvation(голодание потока) - результат процесса который не может получить регулярный доступ к ресурсам необходимым для выполнения задачи, и соответственно не может добиться какого либо прогресса.

## Future

Это некая сущность которая позволяет мне работать с отложенным результатом. Тоесть мы не блокируемся на выполнении а продолжаем работу а дальше по коду можем вызвать результат работы Future и его обработать.

## Fork-join pull

В нем мы работаем с RecursiveTask<T> и переопределяем метод compile(), а не работаем с Future. В нем потоки сами воруют работу у другого потока.

## Виртуальные потоки

В обычном сценарии у нас есть потоки JVM и потоки ОП (операционной системы) и есть CPU
так вот потоки JVM мапятся 1 к 1 с потоками ОП 
а виртуальные потоки это отдельные потоки внутри нашей машины которые мапятся с потоками платформы и потом переходят к CPU

## ThreadLocal переменные

ThreadLocal — это специальный класс в Java, который позволяет создавать переменные, доступные только для конкретного потока. 
Каждый поток имеет свою собственную независимую копию такой переменной.

Основные концепции ThreadLocal:
1. Изоляция данных между потоками
   - Переменные ThreadLocal не являются общими для всех потоков — у каждого потока своя копия.
2. Использование внутреннего Map
   - Внутри ThreadLocal использует ThreadLocalMap, который хранит значения для каждого потока.
3. Автоматическая очистка
   - Когда поток завершается, все его ThreadLocal-переменные удаляются (если нет других ссылок).

Проблемы и особенности:
1. Утечки памяти
   - При использовании в пулах потоков (например, в сервлет-контейнерах) значения могут не очищаться автоматически. 
     Всегда вызывайте remove() после использования.
2. Наследование
   - По умолчанию значения не передаются дочерним потокам. Для этого нужно использовать InheritableThreadLocal.
3. Производительность
   - Доступ к ThreadLocal переменным немного медленнее, чем к обычным переменным.

InheritableThreadLocal - Особый вид ThreadLocal, который передает значения дочерним потокам.

## ConcurrentHashMap

Отсутствие поддержки null-ключей и null-значений
Как работает:
- Используется массив Node (узлов)
-Блокировка на уровне отдельных узлов (более тонкая синхронизация)
- При коллизиях используются:
- Списки (при малом количестве коллизий)
- Сбалансированные деревья (при большом количестве коллизий)

Принцип работы основных операций
1. put(K key, V value)
   - Вычисляется хэш ключа
   - Находится соответствующий сегмент/узел
   - Если узел пуст — добавляется новый элемент (CAS-операция)
   - Если узел занят — блокируется только этот узел
   - Элемент добавляется в цепочку/дерево
2. get(Object key)
   - Вычисляется хэш ключа
   - Находится соответствующий сегмент/узел
   - Чтение происходит без блокировок
   - Возвращается значение или null, если ключ отсутствует

3. remove(Object key)
   - Вычисляется хэш ключа
   - Находится соответствующий сегмент/узел
   - Узел блокируется (если требуется)
   - Элемент удаляется из цепочки/дерева

Преимущества перед Hashtable и Collections.synchronizedMap():
1. Более высокая производительность за счет меньшей конкуренции за блокировки
2. Лучшая масштабируемость при большом количестве потоков
3. Богатый API для атомарных операций

В ConcurrentHashMap используется специальный тип итератора, который называется weakly consistent iterator
(слабо согласованный итератор). Это важная особенность, отличающая его от итераторов в обычных HashMap.
Особенности weakly consistent итератора:
1. Не бросает ConcurrentModificationException
   - В отличие от итераторов обычных коллекций, этот итератор не выбрасывает исключение при изменении карты во время итерации.
2. Отражает состояние карты на момент создания итератора или позже
   - Итератор может видеть (но не гарантирует) изменения, сделанные после его создания.
3. Не гарантирует отражение всех последних изменений
   - Некоторые изменения могут быть не видны во время итерации.
4. Работает без блокировок
   - Итерация происходит без остановки других операций с картой.

## CopyOnWriteArrayList

Принцип работы:
В основе лежит массив (volatile Object[] array), который заменяется при каждой модификации
1. Операции чтения (get, size, итерация)
   - Чтение происходит непосредственно из массива
   - Не требует синхронизации
   - Всегда возвращает актуальные данные (благодаря volatile)
2. Операции записи (add, set, remove)
   - Блокировка всей коллекции на время модификации
   - Создание новой копии внутреннего массива
   - Внесение изменений в новую копию
   - Атомарная замена ссылки на массив

CopyOnWriteArrayList использует неизменяемый snapshot-итератор (immutable snapshot iterator), который обладает 
следующими ключевыми характеристиками:
Особенности итератора
1. Неизменяемый снимок данных:
   - Итератор работает с копией массива на момент создания итератора
   - Не отражает изменения, сделанные после создания итератора
2. Не поддерживает операцию remove():
   - При вызове remove() выбрасывает UnsupportedOperationException
   - Это связано с концепцией "копирования при записи"
3. Weakly-consistent поведение:
   - Гарантирует только что увидит элементы, существовавшие на момент создания
   - Не гарантирует отражение последующих изменений

## Atomic переменные (AtomicInteger, AtomicLong)

Atomic-переменные предоставляют потокобезопасные операции над примитивами и ссылками 
без использования блокировок. Их работа основана на аппаратных возможностях процессоров.

Основные принципы работы:
1. Compare-And-Swap (CAS) операции
   - Основа всех атомарных операций
   - Принцип: "Обнови значение, если оно до сих пор равно ожидаемому"
   - Реализуется через нативные методы (JNI)
2. Использование процессорных инструкций
   - На x86 используется инструкция LOCK CMPXCHG
   - На других архитектурах - аналогичные атомарные инструкции
3. Volatile переменные + CAS
   - Все Atomic-классы используют volatile поля для значений
   - CAS обеспечивает атомарность изменений

Принцип работы операции incrementAndGet:
1. Входит в цикл
2. Получает текущее значение
3. Пытается установить новое значение (current + 1)
4. Если другой поток уже изменил значение - повторяет операцию

Как работает CAS:
1. Процессор читает текущее значение из памяти
2. Сравнивает его с ожидаемым (expect)
3. Если значения совпадают - записывает новое значение (update)
4. Если не совпадают - операция не выполняется
5. Возвращает true/false в зависимости от результата

ABA-проблема и её решение
Проблема:
  - Поток 1 читает значение A
  - Поток 2 меняет A → B → A
  - Поток 1 выполняет CAS(A, C) - операция успешна, хотя состояние изменилось
Решение - AtomicStampedReference:
  - Хранит не только значение, но и версию (stamp)

Версия (stamp) в AtomicStampedReference — это дополнительное числовое значение (обычно int), которое помогает решить ABA-проблему 
в атомарных операциях. Она служит счетчиком изменений и позволяет отслеживать, было ли значение изменено, даже если в итоге оно 
вернулось к исходному.

AtomicStampedReference хранит пару:
1. reference — само значение (например, объект или примитив)
2. stamp — метка версии (целое число, обычно инкрементируется при каждом изменении)

## @PostConstruct

Основные случаи применения
1. Инициализация после инъекции зависимостей
   Когда вам нужно выполнить настройку объекта после того, как все зависимости (через @Autowired, @Inject или @Resource) уже внедрены
2. Проверка конфигурации
   Для валидации корректности настроек бина после его создания
   @Value("{aa}")
3. Регистрация слушателей или подписка на события
   Когда нужно зарегистрировать бин как слушатель событий


## Чем отличается Thread от Runnable и Callable?

1. Thread (поток)
   - Класс, который напрямую создаёт и управляет потоком ОС.
   - Не возвращает результат выполнения.
   - Не может выбрасывать проверяемые исключения (только unchecked).
2. Runnable (задача)
   - Интерфейс с единственным методом run().
   - Не возвращает результат (метод void).
   - Не поддерживает исключения (только через try-catch).
   - Можно передать в Thread или ExecutorService.
3. Callable (расширенная задача)
   - Интерфейс с методом call(), который возвращает результат (V).
   - Может выбрасывать проверяемые исключения (например, IOException).
   - Используется с ExecutorService и Future для получения результата.

## Как создать и запустить поток в Java?

1. Наследование от класса Thread
2. Реализация интерфейса Runnable
3. Использование ExecutorService
4. Через CompletableFuture
   `CompletableFuture.runAsync(() -> {
    System.out.println("Асинхронный поток: " + Thread.currentThread().getName());
    });`

## Что такое daemon-поток и зачем он нужен?

Daemon-поток (демон-поток) — это фоновый поток в Java, который автоматически завершается, когда все обычные (не-daemon) потоки 
завершили свою работу. JVM не ждёт завершения daemon-потоков перед выходом.

Как создать daemon-поток?
1. Через setDaemon(true)
2. Через ThreadFactory (в ExecutorService)

## Какие состояния (State) может иметь поток в Java?

1. Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start()
2. Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start()
3. Работающий (Running)
4. Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait()
5. Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
6. Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта.
7. Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен.

## Как работает Thread.sleep() и Thread.yield()?

Метод yield() служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), 
давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.

Метод sleep() вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).

## Что такое race condition и как его избежать?

Race Condition (состояние гонки) — это ошибка многопоточности, возникающая, когда несколько потоков одновременно обращаются к общим 
данным
Как избежать Race Condition?
1. Синхронизация (synchronized)
2. Атомарные классы
3. Блокировки (ReentrantLock, ReadWriteLock)

## Разница между synchronized методами и блоками?

1. synchronized методы
   Характеристики:
   Захватывают монитор всего объекта (для нестатических методов) или монитор класса (для статических методов).
   Просты в использовании, но менее гибкие.
`public static synchronized void staticMethod() {}`

2. synchronized блоки
   Характеристики:
   Позволяют явно указать объект для блокировки.
   Дают точечный контроль над синхронизацией.
`private final Object lock = new Object();
public void staticMethod() {
    synchronized (MyClass.class) {
        // ...
    }
}`

## Как работает volatile и зачем он нужен?

volatile решает две основные проблемы многопоточности:
1. Видимость изменений
   Гарантирует, что все потоки видят актуальное значение переменной (отключает кэширование в регистрах CPU).
2. Запрет переупорядочивания операций
   Компилятор и процессор не могут переставить операции чтения/записи volatile-переменной относительно других операций.

## Что такое happens-before в Java Memory Model (JMM)?

Happens-before в Java Memory Model (JMM) — это формальное отношение между операциями в многопоточной среде, которое гарантирует, 
что одна операция видит результаты другой операции.
Если операция A happens-before операция B, то всё, что сделано в A, будет видно в B.

## Чем ReentrantLock отличается от synchronized?

synchronized:
- Работает только в пределах блока/метода.
- Нельзя разблокировать из другого метода.
- Нет встроенного таймаута (риск deadlock).

ReentrantLock:
- Можно захватывать и освобождать вручную в разных местах.
- Полезно для сложных сценариев (например, обход deadlock).
- Можно попытаться захватить блокировку с таймаутом

## Что такое ReadWriteLock и когда его использовать?

ReadWriteLock — это интерфейс. Он разделяет блокировки на:
1. ReadLock (shared lock) — для операций чтения (много потоков могут читать одновременно).
2. WriteLock (exclusive lock) — для операций записи (только один поток может писать).

Основная реализация — ReentrantReadWriteLock
Идеально подходит для сценариев:
✅ Частое чтение, редкая запись (например, кэш, словари, конфигурации).
✅ Высокая конкуренция за чтение (чтение не блокирует другие чтения).
✅ Требуется высокая производительность (меньше блокировок → лучше scalability).

Как работает ReadWriteLock?
- Несколько потоков могут одновременно удерживать ReadLock.
- Только один поток может удерживать WriteLock (и только если нет читателей).
- WriteLock блокирует и чтение, и запись.

## Как работает CompletableFuture и чем отличается от Future?

Future - представляет результат асинхронной операции, который будет доступен в будущем.
Основные методы:
- get() — блокирует поток, пока результат не будет готов (можно с таймаутом).
- isDone() — проверяет, завершена ли задача.
- cancel() — попытка отменить выполнение.

Недостатки Future:
❌ Нет callback-ов (приходится вручную проверять isDone()).
❌ Сложно комбинировать несколько асинхронных операций (например, future1 + future2).
❌ Нет обработки исключений в цепочках.

CompletableFuture расширяет Future и CompletionStage, добавляя:
- Неблокирующую обработку (callback-и).
- Цепочки асинхронных операций (как в JavaScript Promise).
- Комбинирование нескольких Future.
- Гибкую обработку ошибок.

Ключевые особенности:
1. Ручное завершение
   `CompletableFuture<String> cf = new CompletableFuture<>();
    cf.complete("Готово!"); // завершаем успешно
    cf.completeExceptionally(new RuntimeException("Ошибка!")); // с ошибкой`
2. Асинхронное выполнение
   `CompletableFuture.runAsync(() -> System.out.println("Без результата")); // Runnable  
    CompletableFuture.supplyAsync(() -> "Результат"); // Supplier  `
3. Цепочки вызовов (chaining)
   `CompletableFuture.supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World") // синхронное преобразование
    .thenAccept(System.out::println); // потребитель`
4. Комбинирование Future
   `CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> "A");
    CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> "B");
    cf1.thenCombine(cf2, (a, b) -> a + b) // "A + B"
    .thenAccept(System.out::println);`
5. Обработка ошибок
   `CompletableFuture.supplyAsync(() -> {
        if (Math.random() > 0.5) throw new RuntimeException("Ошибка!");
        return "Успех";
    })
    .exceptionally(ex -> "Запасной вариант: " + ex.getMessage())
    .thenAccept(System.out::println);`

## Что такое Semaphore и где его можно применить?

Semaphore — это синхронизатор, который ограничивает доступ к ресурсу через счётчик разрешений (permits). Он полезен, 
когда нужно контролировать количество потоков, одновременно работающих с общим ресурсом.
Как работает Semaphore?
- Имеет счётчик разрешений (например, Semaphore(3) даёт 3 разрешения).
- Поток захватывает разрешение через acquire() (если есть свободные).
- Если разрешений нет, поток блокируется, пока они не появятся.
- После завершения работы поток освобождает разрешение через release().

## Разница между CountDownLatch, CyclicBarrier, Semaphore.
1. CountDownLatch - Позволяет одному или нескольким потокам ждать, пока другие потоки не завершат определенные операции
   Одноразовый — после обнуления счетчика нельзя использовать повторно.
   Инициализируется числом (count), которое уменьшается методом countDown().
   Потоки, вызывающие await(), блокируются, пока счетчик не станет 0
2. CyclicBarrier - Заставляет набор потоков ждать друг друга в определенной точке (барьере), прежде чем продолжить выполнение.
   Многоразовый — после срабатывания барьера счетчик сбрасывается.
   Можно задать действие (Runnable), которое выполнится при достижении барьера.
   Если поток "ломает" барьер (например, из-за исключения), все остальные получают BrokenBarrierException.
3. Semaphore - Ограничивает количество потоков, которые могут одновременно работать с ресурсом
   Поддерживает "разрешения" (permits), которые потоки захватывают (acquire()) и освобождают (release()).
   Может быть "честным" (fair), чтобы избежать голодания потоков.
   Полезен для пулов ресурсов (например, подключений к БД).

## Что такое Phaser?
Phaser — это гибкий синхронизатор, представленный в Java 7, который объединяет возможности CountDownLatch, CyclicBarrier, Phaser
и даже Exchanger, но с более продвинутыми функциями


https://w3resource.com/java-exercises/multithreading/index.php
