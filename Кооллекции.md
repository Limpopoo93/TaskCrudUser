Основные интерфейсы, определяющие поведение коллекций:
- Collection – базовый интерфейс для всех коллекций.
  1. List – упорядоченная коллекция (может содержать дубликаты).
  2. Set – неупорядоченная коллекция без дубликатов.
  3. Queue (Очередь) – коллекция, работающая по принципу FIFO (первым пришёл – первым ушёл).
  4. Deque (Двусторонняя очередь) – расширение Queue, поддерживает вставку и удаление с обоих концов.
- Map – не является наследником Collection, но относится к коллекциям. Хранит пары ключ-значение.

Списки (List):
1. ArrayList – динамический массив, быстрый доступ по индексу, но медленные вставка/удаление в середине.+
2. LinkedList – двусвязный список, быстрая вставка/удаление, но медленный доступ по индексу.+
3. Vector – устаревший аналог ArrayList с синхронизацией (потокобезопасный).+
4. Stack – наследник Vector, реализует стек (LIFO).+

Множества (Set):
1. HashSet – Уникальные не упорядоченные данные с быстрым доступом. каждый добавленный элемент становится ключом
   Хеш-функция вычисляет hashCode объекта
   Этот код используется для определения позиции в массиве
   Если два объекта имеют одинаковый hashCode, возникает коллизия, и элементы размещаются в одной корзине
   Метод equals() используется для сравнения элементов внутри одного бакета
2. LinkedHashSet – сохраняет порядок добавления элементов и наследует все из HashSet, а так же это двухсвязанный список.
3. TreeSet – хранит элементы в отсортированном порядке (на основе TreeMap).
4. SortedSet - отсортированные уникальные элементы. Сортировка происходит либо по алфавиту либо на основе естественного порядка.
   либо при помощи компаратора. Это интерфейс реализацией которой является TreeSet.
5. NavigableSet - расширяет SortedSet добавляя методы для навигации по отсортированному множеству. Элементы отсортированы, они 
   уникальные а так же поддержка обратного порядка.
5. IdentityHashSet - это карта, в которой ключи сравниваются по ссылке (==), а не по методу equals()

Очереди (Queue и Deque):
1. PriorityQueue – элементы автоматически упорядочены по приоритету, а наивысший приоритет извлекается первым. Это очередь с 
   приоритетом, а не в порядке добавления как в обычной Queue или LinkedList.
   Не гарантирует порядок добавления — порядок зависит от приоритета.
   Элементы сортируются либо по: 1. естественному порядку (Comparable). 2. пользовательскому компаратору (Comparator)
   Позволяет дубликаты и не допускает null
2. ArrayDeque – двусторонняя очередь на основе массива. Позволяет добавлять и удалять элементы как с начала, так и с конца.
   Нельзя добавлять null значения.
3. BlockingQueue - расширяет обычную очередь (Queue), добавляя блокирующее поведение при добавлении и извлечении элементов.
   Реализации: 1. ArrayBlockingQueue. 2. LinkedBlockingQueue. 3. PriorityBlockingQueue.
   Хорошо использовать для: 1. При реализации производитель–потребитель. 2. При передаче данных между потоками.
   3. Для ограничения нагрузки.

Ассоциативные массивы (Map):
1. HashMap – хэш-таблица, не гарантирует порядок.
2. LinkedHashMap – сохраняет порядок добавления.
3. SortedMap
3. TreeMap – реализация интерфейса NavigableMap в Java, которая хранит пары ключ-значение в отсортированном порядке по ключу.
   Она основана на красно-черном дереве. Быстрый поиск, вставка и удаление. Не поддерживает null в качестве ключа, 
   но допускает null значения. Поддерживает естественный порядок ключей (через Comparable) или пользовательский компаратор.
4. Hashtable – устаревший потокобезопасный аналог HashMap.
6. WeakHashMap - weak ссылки.
7. IdentityHashMap - использует сравнение ключей и значений по ссылке (==), а не по методу equals().
   Не поддерживает null как ключ (в отличие от HashMap), но допускает null как значение.

Потокобезопасные:
1. ConcurrentHashMap - Потокобезопасный аналог HashMap с сегментированной блокировкой
2. CopyOnWriteArrayList - Потокобезопасный ArrayList
3. CopyOnWriteArraySet - Потокобезопасный HashSet на основе CopyOnWriteArrayList
4. ConcurrentLinkedQueue - это потокобезопасная неблокирующая очередь на основе связного списка (linked list) в Java
   Методы не блокируют выполнение — вместо этого используют CAS (compare-and-swap). null запрещён.
5. BlockingQueue - расширяет обычную очередь (Queue), добавляя блокирующее поведение при добавлении и извлечении элементов.
   Реализации: 1. ArrayBlockingQueue. 2. LinkedBlockingQueue. 3. PriorityBlockingQueue.
   Хорошо использовать для: 1. При реализации производитель–потребитель. 2. При передаче данных между потоками.
   3. Для ограничения нагрузки.
