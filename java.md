# Java
- [Java](#Java)
-
-   Общие
  - [3 принципа ООП?](#3_принципа_ООП)
  - [Что такое статический и динамический полиморфизм?](#Что_такое_статический_и_динамический_полиморфизм)
  - [В чем разница между ООП и процедурным программированием?](#В_чем_разница_между_ООП_и_процедурным_программированием)
  - [В чем преимущества и недостатки ООП, если сравнивать с процедурным/функциональным программированием?](#В_чем_преимущества_и_недостатки_ООП_если_сравнивать_с_процедурным_функциональным_программированием)
  - [Какая есть проблема наследования?](#Какая_есть_проблема_наследования)
  - [Какие есть виды полиморфизма?](#Какие_есть_виды_полиморфизма)
  - [Когда лучше использовать наследование, а не агрегацию?](#Когда_лучше_использовать_наследование_а_не_агрегацию)
  - [Что такое статическое и динамическое связывание в Java?](#Что_такое_статическое_и_динамическое_связывание_в_Java)
  - [Расскажите про Classloader?](#Расскажите_про_Classloader)
  - [Какие типы загрузчиков класса бывают?](#Какие_типы_загрузчиков_класса_бывают)
  - [Чем различаются JRE, JVM и JDK?](#Чем_различаются_JRE_JVM_и_JDK)
  - Garbage Collectors
  - [Как работает Garbage Collector?](#Как_работает_Garbage_Collector)
  - [Какие существуют Garbage Collectors в JVM и зачем их столько?](#Какие_существуют_Garbage_Collectors_в_JVM_и_зачем_их_столько)
  - [Существует два подхода к обнаружению мусора?](#Существует_два_подхода_к_обнаружению_мусора)
  - Память
  - [Что такое Heap и Stack память в Java? Какая разница между ними?](#Что_такое_Heap_и_Stack_память_в_Java_Какая_разница_между_ними)
  - [Расскажите о Java Memory Model.  Какие типы памяти у JVM?](#Расскажите_о_Java_Memory_Model_Какие_типы_памяти_у_JVM)
  - [Что будет с Garbage Collector, если finalize() будет долго выполняться или в процессе выполнения получим исключение?](#Что_будет_с_Garbage_Collector_если_finalize_будет_долго_выполняться_или_в_процессе_выполнения_получим_исключение)
  - [Каким образом передаются переменные в методы, по значению или по ссылке?](#Каким_образом_передаются_переменные_в_методы_по_значению_или_по_ссылке)
  - [Расскажите про классы-загрузчики и про динамическую загрузку классов?](#Расскажите_про_классы_загрузчики_и_про_динамическую_загрузку_классов)
  - [В чем разница передачи параметров по ссылке и значению?](#В_чем_разница_передачи_параметров_по_ссылке_и_значению)
  - [Расскажите, в чем разница между WeakReference и SoftReference?](#Расскажите_в_чем_разница_между_WeakReference_и_SoftReference)
  - java
  - [Расскажите про абстрактный класс?](#Расскажите_про_абстрактный_класс)
  - [Расскажите про интерфейс?](#Расскажите_про_интерфейс)
  - [Чем отличается абстрактный класс от интерфейса?](#Чем_отличается_абстрактный_класс_от_интерфейса)
  - [Какие типы классов бывают в java?](#Какие_типы_классов_бывают_в_java)
  - [Можно ли наследоваться от класса String?](#Можно_ли_наследоваться_от_класса_String)
  - [Как будет вести себя String при конкатинации?](#Как_будет_вести_себя_String_при_конкатинации)
  - [Какие области видимости\влияния есть в Java?](#Какие_области_видимости_влияния_есть_в_Java)
  - [Расскажите про вложенные классы. В каких случаях они применяются?](#Расскажите_про_вложенные_классы_В_каких_случаях_они_применяются)
  - [Чем отличаются final, finally и finalize()?](#Чем_отличаются_final_finally_и_finalize)
  - [Какая основная разница между String, StringBuffer, StringBuilder?](#Какая_основная_разница_между_String_StringBuffer_StringBuilder)
  - [Что такое класс Object? Какие в нем есть методы?](#Что_такое_класс_Object_Какие_в_нем_есть_методы)
  - [Когда используется ключевое слово this?](#Когда_используется_ключевое_слово_this)
  - [Что такое ковариантность типов?](#Что_такое_ковариантность_типов)
  - [Что такое обобщенные типы в Java? Как они используются при работе с коллекциями?](#Что_такое_обобщенные_типы_в_Java_Как_они_используются_при_работе_с_коллекциями)
  - Equals vs hashcode
  - [Зачем нужен equals(). Чем он отличается от операции ==?](#Зачем_нужен_equals_Чем_он_отличается_от_операции_равно)
  - [Какая связь между hashCode() и equals()?](#Какая_связь_между_hashCode_и_equals)
  - [Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?](#Что_будет_если_переопределить_equals_не_переопределяя_hashCode_Какие_могут_возникнуть_проблемы)
  - [Могут ли у разных объектов быть одинаковые hashCode()?](#Могут_ли_у_разных_объектов_быть_одинаковые_hashCode)
  - [Какова роль equals() и hashCode() в HashMap?](#Какова_роль_equals_и_hashCode_в_HashMap)
  - [Как работает hashCode() и equals() в Java?](#Как_работает_hashCode_и_equals_в_Java)
  - [Расскажите о контракте между equals and hashcode?](#Расскажите_о_контракте_между_equals_and_hashcode)
  - [Каково максимальное число значений hashCode()?](#Каково_максимальное_число_значений_hashCode)
  - [Что такое коллизия в Hashcode? И как с ней бороться?](#Что_такое_коллизия_в_Hashcode_И_как_с_ней_бороться)
  - [Какие условия выдвигаются при переопределении equals?](#Какие_условия_выдвигаются_при_переопределении_equals)
  - Exception
  - [Опишите иерархию исключений?](#Опишите_иерархию_исключений)
  - Stream api
  - [Что такое generics?](#Что_такое_generics)
  - [Что такое «лямбда»?](#Что_такое_лямбда)
  - [Что такое «ссылка на метод»?](#Что_такое_ссылка_на_метод)
  - [Что такое «функциональные интерфейсы»?](#Что_такое_функциональные_интерфейсы)
  - [Какие новые функциональные интерфейсы появились в Java 8?](#Какие_новые_функциональные_интерфейсы_появились_в_Java_8)
  - [Как взаимосвязаны функциональные интерфейсы и лямбда-выражения?](#Как_взаимосвязаны_функциональные_интерфейсы_и_лямбда_выражения)
  - [Что такое static метод интерфейса?](#Что_такое_static_метод_интерфейса)
  - [Какие существуют способы создания стрима?](#Какие_существуют_способы_создания_стрима)
  - [Для чего в стримах предназначены методы flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong()?](#Для_чего_в_стримах_предназначены_методы_flatMap_flatMapToInt_flatMapToDouble_flatMapToLong)
  - [Какие основные ограничения действуют на статические переменные и методы?](#Какие_основные_ограничения_действуют_на_статические_переменные_и_методы)
  - [Что такое FunctionInterface и чем он отличается от обычного интерфейса?](#Что_такое_FunctionInterface_и_чем_он_отличается_от_обычного_интерфейса)
  - [Что такое и для чего нужны Atomic types?](#Что_такое_и_для_чего_нужны_Atomic_types)
  - [Чем отличается метод map от flatMap?](#Чем_отличается_метод_map_от_flatMap)
  - [Чем отличается Lambda от анонимного класса?](#Чем_отличается_Lambda_от_анонимного_класса)
  - [Чем отличается ForkJoinPool от ScheduledThreadPoolExecutor и ThreadPoolExcutor?](#Чем_отличается_ForkJoinPool_от_ScheduledThreadPoolExecutor_и_ThreadPoolExcutor)
  - Collection
  - [Расскажите про иерархию коллекции?](#Расскажите_про_иерархию_коллекции)
  - [Что такое «fail-fast поведение»?](#Что_такое_fail_fast_поведение)
  - [Как между собой связаны Iterable и Iterator?](#Как_между_собой_связаны_Iterable_и_Iterator)
  - [В чем разница между Enumeration и Iterator?](#В_чем_разница_между_Enumeration_и_Iterator)
  - [Comparator vs Comparable?](#Comparator_vs_Comparable)
  - [Как избежать ConcurrentModificationException во время перебора коллекции?](#Как_избежать_ConcurrentModificationException_во_время_перебора_коллекции)
  - [Какой интерфейс нужно реализовать, чтобы создать свою собственную коллекцию?](#Какой_интерфейс_нужно_реализовать_чтобы_создать_свою_собственную_коллекцию)
  - [Как работает итератор в Java-коллекциях?](#Как_работает_итератор_в_Java_коллекциях)
  - [Каким образом можно создать immutable коллекции в Java?](#Каким_образом_можно_создать_immutable_коллекции_в_Java)
  - [Чем отличается ArrayList от LinkedList?](#Чем_отличается_ArrayList_от_LinkedList)
  - [Сравните интерфейсы Queue и Deque?](#Сравните_интерфейсы_Queue_и_Deque)
  - [Какая коллекция реализует дисциплину обслуживания FIFO?](#Какая_коллекция_реализует_дисциплину_обслуживания_FIFO)
  - [Какая коллекция реализует дисциплину обслуживания FILO?](#Какая_коллекция_реализует_дисциплину_обслуживания_FILO)
  - [Что позволяет сделать PriorityQueue?](#Что_позволяет_сделать_PriorityQueue)
  - [Что такое WeakHashMap? В каких случаях его использование может быть полезно?](#Что_такое_WeakHashMap_В_каких_случаях_его_использование_может_быть_полезно)
  - [Что такое IdentityHashSet? В каких случаях его использование может быть полезно?](#Что_такое_IdentityHashSet_В_каких_случаях_его_использование_может_быть_полезно)
  - [Что такое CopyOnWriteArrayList? В каких случаях он может быть полезен?](#Что_такое_CopyOnWriteArrayList_В_каких_случаях_он_может_быть_полезен)
  - [Как работает HashMap?](#Как_работает_HashMap)
  - [Принцип работы HashSet?](#Принцип_работы_HashSet)
  - [Каково внутреннее строение TreeMap?](#Каково_внутреннее_строение_TreeMap)
  - [Основные характеристики TreeSet?](#Основные_характеристики_TreeSet)
  - [Основные характеристики LinkedHashSet?](#Основные_характеристики_LinkedHashSet)
  - [LinkedHashMap - что в нем от LinkedList, а что от HashMap?](#LinkedHashMap_что_в_нем_от_LinkedList_а_что_от_HashMap)
  - [В чем разница между HashMap и IdentityHashMap?](#В_чем_разница_между_HashMap_и_IdentityHashMap)
  - [В чем разница между HashMap и WeakHashMap?](#В_чем_разница_между_HashMap_и_WeakHashMap)
  - [В чем разница между HashMap и TreeMap?](#В_чем_разница_между_HashMap_и_TreeMap)
  - [В чем разница между HashSet, LinkedHashSet и TreeSet?](#В_чем_разница_между_HashSet_LinkedHashSet_и_TreeSet)
  - [Чем отличается ConcurrentHashMap от HashMap?](#Чем_отличается_ConcurrentHashMap_от_HashMap)
  - [Какой будет hash у объекта null в HashMap](#Какой_будет_hash_у_объекта_null_в_HashMap)
  - [Можно ли использовать null-ключ в HashMap?](#Можно_ли_использовать_null_ключ_в_HashMap)
  - [В каком случае может быть потерян элемент в HashMap?](#В_каком_случае_может_быть_потерян_элемент_в_HashMap)
  - [Как и когда происходит увеличение количества корзин в HashMap?](#Как_и_когда_происходит_увеличение_количества_корзин_в_HashMap)
  - [Как узнать, что ключ уже присутствует в HashMap?](#Как_узнать_что_ключ_уже_присутствует_в_HashMap)
  - [Что произойдет, если попытаться добавить null-элемент в LinkedList или HashSet?](#Что_произойдет_если_попытаться_добавить_null_элемент_в_LinkedList_или_HashSet)
  - [Какие коллекции в Java являются потокобезопасными?](#Какие_коллекции_в_Java_являются_потокобезопасными)
  - [Какие алгоритмы обхода деревьев бывают и почему они разные?](#Какие_алгоритмы_обхода_деревьев_бывают_и_почему_они_разные)
  - Многопоточность
  - [Какие средства для работы с многопоточностью вы знаете?](#Какие_средства_для_работы_с_многопоточностью_вы_знаете)
  - [Расскажите о модели памяти Java?](#Расскажите_о_модели_памяти_Java)
  - [Существует несколько основных правил для отношения happens-before?](#Существует_несколько_основных_правил_для_отношения_happens_before)
  - [К вопросу видимости имеют отношение?](#К_вопросу_видимости_имеют_отношение)
  - [Что такое «потокобезопасность»?](#Что_такое_потокобезопасность)
  - [В чём разница между «конкуренцией» и «параллелизмом»?](#В_чём_разница_между_конкуренцией_и_параллелизмом)
  - [Что такое «кооперативная многозадачность»?](#Что_такое_кооперативная_многозадачность)
  - [Что такое ordering?](#Что_такое_ordering)
  - [Что такое sequential consistency?](#Что_такое_sequential_consistency)
  - [Что такое visibility?](#Что_такое_visibility)
  - [Что такое happens-before?](#Что_такое_happens_before)
  - [Что такое atomicity?](#Что_такое_atomicity)
  - [Что такое mutual exclusion?](#Что_такое_mutual_exclusion)
  - [Что такое safe publication?](#Что_такое_safe_publication)
  - [Чем отличается процесс от потока?](#Чем_отличается_процесс_от_потока)
  - [Что такое «зелёные потоки» и есть ли они в Java?](#Что_такое_зелёные_потоки_и_есть_ли_они_в_Java)
  - [Каким образом можно создать поток?](#Каким_образом_можно_создать_поток)
  - [Каким образом можно остановить поток?](#Каким_образом_можно_остановить_поток)
  - [Чем различаются Thread и Runnable?](#Чем_различаются_Thread_и_Runnable)
  - [В чём заключается разница между методами start() и run()?](#В_чём_заключается_разница_между_методами_start_и_run)
  - [Что такое «монитор» в Java?](#Что_такое_монитор_в_Java)
  - [Какие существуют способы синхронизации в Java?](#Какие_существуют_способы_синхронизации_в_Java)
  - [В каких состояниях может находиться поток?](#В_каких_состояниях_может_находиться_поток)
  - [Как работают методы wait() и notify()/notifyAll()?](#Как_работают_методы_wait_и_notify_notifyAll)
  - [Почему методы wait() и notify() вызываются только в синхронизированном блоке?](#Почему_методы_wait_и_notify_вызываются_только_в_синхронизированном_блоке)
  - [Чем отличается работа метода wait() с параметром и без параметра?](#Чем_отличается_работа_метода_wait_с_параметром_и_без_параметра)
  - [Чем отличаются методы Thread.sleep() и Thread.yield()?](#Чем_отличаются_методы_Thread_sleep_и_Thread_yield)
  - [Как работает метод Thread.join()?](#Как_работает_метод_Thread_join)
  - [Что такое deadlock?](#Что_такое_deadlock)
  - [Что такое livelock?](#Что_такое_livelock)
  - [Для чего используется ключевое слово volatile, synchronized, transient, native?](#Для_чего_используется_ключевое_слово_volatile_synchronized_transient_native)
  - [В чём различия между volatile и Atomic переменными?](#В_чём_различия_между_volatile_и_Atomic_переменными)
  - [Что значит «приоритет потока»?](#Что_значит_приоритет_потока)
  - [Что такое «потоки-демоны»?](#Что_такое_потоки_демоны)
  - [Чем отличаются два интерфейса Runnable и Callable?](#Чем_отличаются_два_интерфейса_Runnable_и_Callable)
  - [Что такое FutureTask?](#Что_такое_FutureTask)
  - [В чем заключаются различия между CyclicBarrier и CountDownLatch?](#В_чем_заключаются_различия_между_CyclicBarrier_и_CountDownLatch)
  - [Что такое race condition?](#Что_такое_race_condition)
  - [Что такое мьютекс?](#Что_такое_мьютекс)
  - [Существует ли способ решения проблемы race condition?](#Существует_ли_способ_решения_проблемы_race_condition)
  - [Что происходит, когда в потоке выбрасывается исключение?](#Что_происходит_когда_в_потоке_выбрасывается_исключение)
  - [В чем разница между interrupted() и isInterrupted()?](#В_чем_разница_между_interrupted_и_isInterrupted)
  - [Что такое «пул потоков»?](#Что_такое_пул_потоков)
  - [Объясните жизненный цикл потока?](#Объясните_жизненный_цикл_потока)
  - [Методы Executors для создания пулов?](#Методы_Executors_для_создания_пулов)
  - [Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?](#Что_будет_если_очередь_пула_потоков_уже_заполнена_но_подаётся_новая_задача)
  - [В чём заключается различие между методами submit() и execute() у пула потоков?](#В_чём_заключается_различие_между_методами_submit_и_execute_у_пула_потоков)
  - [Как получить дамп потока?](#Как_получить_дамп_потока)
  - [Что такое ThreadLocal-переменная?](#Что_такое_ThreadLocal_переменная)
  - [Назовите различия между synchronized и ReentrantLock?](#Назовите_различия_между_synchronized_и_ReentrantLock)
  - [Что такое ReadWriteLock?](#Что_такое_ReadWriteLock)
  - [Что такое «фреймворк Fork/Join»?](#Что_такое_фреймворк_Fork_Join)
  - [Что такое Semaphore?](#Что_такое_Semaphore)
  - [Чем полезны неизменяемые объекты?](#Чем_полезны_неизменяемые_объекты)
  - [Перечислите принципы, которым вы следуете в многопоточном программировании?](#Перечислите_принципы_которым_вы_следуете_в_многопоточном_программировании)
  - [Что такое Happens-before? Каковы особенности использования ключевого слова volatile?](#Что_такое_Happens_before_Каковы_особенности_использования_ключевого_слова_volatile)
  - [Что такое deadlock? Какие типы есть? Нарисуйте схематически, как это может произойти?](#Что_такое_deadlock_Какие_типы_есть_Нарисуйте_схематически_как_это_может_произойти)
  - [Что такое optimistic и pessimistic locking?](#Что_такое_optimistic_и_pessimistic_locking)
  - [Механизм CAS?](#Механизм_CAS)
  - [Что означает CAP-теорема?](#Что_означает_CAP_теорема)
  - [Что такое n+1 проблема?](#Что_такое_n_1_проблема)


## 3_принципа_ООП

1. Инкапсуляция - это принцип, который позволяет скрыть детали реализации объекта.
   Таким образом, объект может предоставить только необходимый интерфейс для работы с ним.
2. Наследование - это принцип, который позволяет создавать новые классы на основе уже существующих. 
   Новый класс наследует свойства и методы родительского класса и может добавить свои собственные свойства и методы.
3. Полиморфизм - это принцип, который позволяет объектам с одинаковым интерфейсом иметь различную реализацию. 
   Такой подход позволяет использовать один и тот же метод для работы с разными типами объектов.

Принцип наследования:
С помощью наследования один класс может наследовать свойства и методы другого класса (родительского класса), 
что позволяет избежать дублирования кода и повысить его переиспользуемость.
Когда новый класс наследует свойства и методы родительского класса, он может изменять их или добавлять свои собственные 
свойства и методы. Таким образом, наследование позволяет создавать дополнительные классы с более сложным поведением на 
основе уже существующих классов.

Принцип полиморфизм:
предполагает использование одного и того же имени метода или свойства для объектов разных классов. Иными словами, 
полиморфизм позволяет обращаться к объектам разных классов с помощью одних и тех же методов или свойств.
Работа полиморфизма основывается на наследовании и переопределении методов в наследниках. Когда мы создаем новый класс, 
наследующий свойства и методы от родительского класса, мы можем переопределить некоторые методы в наследнике. Таким 
образом, если у нас есть переменная с типом родительского класса, то ее можно использовать для хранения экземпляра любого 
из наследников этого класса. При вызове метода через эту переменную будет вызываться метод из соответствующего наследника.
Еще один способ реализации полиморфизма - это использование интерфейсов. Интерфейс определяет набор методов, которые должны
быть реализованы всеми классами, которые реализуют этот интерфейс. Это позволяет использовать объекты разных классов, 
которые реализуют один и тот же интерфейс, как если бы это были объекты одного класса.

## Что_такое_статический_и_динамический_полиморфизм

Статический полиморфизм - Это перегрузка методов (method overloading) — когда в одном классе есть несколько методов с 
одинаковым именем, но разными параметрами.

Динамический полиморфизм - Это переопределение методов (method overriding) — когда подкласс предоставляет свою реализацию 
метода, унаследованного от суперкласса. Метод выбирается во время выполнения, в зависимости от типа объекта, на который 
ссылается переменная.

## В_чем_разница_между_ООП_и_процедурным_программированием

В процедурном программировании данные и функции для их обработки разбиты на отдельные функции, которые работают независимо
друг от друга, а в ООП данные и функции упаковываются в объекты которые взаимодействуют друг с другом.

## В_чем_преимущества_и_недостатки_ООП_если_сравнивать_с_процедурным_функциональным_программированием

ООП удобно для моделирования сложных систем с объектами и состоянием. Оно повышает читаемость, повторное использование 
и масштабируемость кода. Но для задач с большим количеством вычислений, трансформацией данных или параллелизмом часто 
лучше работает функциональный подход, так как он проще, безопаснее и лучше масштабируется.

## Какая_есть_проблема_наследования

1. Нарушение инкапсуляции (Fragile Base Class Problem)
   Проблема: Изменения в родительском классе могут сломать поведение дочерних классов, даже если они не касались их напрямую.
2. Жёсткая связь (Tight Coupling)
   Проблема: Дочерний класс жёстко привязан к родителю.
3. Проблема "ромбовидного наследования" (Diamond Problem) - Это классическая проблема множественного наследования, когда один 
   класс наследует от двух классов, которые, в свою очередь, наследуют от одного общего родителя.
   Проблема: В Java нет множественного наследования классов, но если бы оно было, возникла бы неоднозначность
4. Неправильная иерархия (Inheritance for Code Reuse)
   Проблема: Наследование часто используют только для переиспользования кода, а не для выражения отношения «является» (is-a)
6. Нарушение принципа подстановки Барбары Лисков (LSP)
   Принцип LSP: Подклассы должны быть взаимозаменяемы с родителями

## Какие_есть_виды_полиморфизма

1. Перегрузка методов (Method Overloading) — статический полиморфизм
   Определение: Разные методы с одним именем, но разными параметрами
2. Переопределение методов (Method Overriding) — динамический полиморфизм
   Определение: Подкласс изменяет поведение метода, унаследованного от родителя.
3. Полиморфизм через интерфейсы и абстрактные классы
   Интерфейсы позволяют разным классам реализовывать одну и ту же функциональность.
4. Параметрический полиморфизм (Generics)
   Generics позволяют писать обобщённые классы и методы.
5. Полиморфизм через лямбда-выражения (Java 8+)
   Функциональные интерфейсы позволяют передавать разное поведение в методы.

## Когда_лучше_использовать_наследование_а_не_агрегацию

Наследование - это процесс создания нового класса на основе существующего класса, называемого базовым классом или
суперклассом.

Агрегация - это процесс создания нового класса через комбинирование других классов, которые представляют собой его части.

## Что_такое_статическое_и_динамическое_связывание_в_Java

Статическое связывание происходит во время компиляции кода и определяет, какой метод будет вызван на основе типа
переменной или ссылки на объект, которая содержит метод. Если тип переменной или ссылки заранее известен, то компилятор
может точно определить, какой метод будет вызван, и связать его с этой переменной или ссылкой.

Динамическое связывание происходит во время выполнения программы и определяет, какой метод будет вызван на основе
фактического типа объекта, на который ссылается переменная или ссылка. Если тип объекта не известен заранее, то компилятор
не может точно определить, какой метод будет вызван, и связь происходит только во время выполнения программы.

## Расскажите_про_Classloader

Classloader (загрузчик классов) - это механизм в Java, который загружает классы в память и связывает их друг с другом для
выполнения программы.
Когда JVM запускается, она создает три встроенных загрузчика классов:
1. Bootstrap Classloader - загружает стандартные библиотечные классы из папки JRE/lib.
2. Extension Classloader - загружает расширения Java из папки JRE/lib/ext.
3. System Classloader - загружает классы из переменной окружения CLASSPATH. Кроме того, в Java можно создавать
   пользовательские загрузчики классов, которые могут загружать классы из любых других источников, например, из базы
   данных или из сети.

## Какие_типы_загрузчиков_класса_бывают

Когда JVM запускается, она создает три встроенных загрузчика классов:
1. Bootstrap Classloader - загружает стандартные библиотечные классы из папки JRE/lib.
2. Extension Classloader - загружает расширения Java из папки JRE/lib/ext.
3. System Classloader - загружает классы из переменной окружения CLASSPATH. Кроме того, в Java можно создавать
   пользовательские загрузчики классов, которые могут загружать классы из любых других источников, например, из базы
   данных или из сети.

## Чем_различаются_JRE_JVM_и_JDK

JVM (Java Virtual Machine) - виртуальная машина Java, которая выполняет Java-байткод. Все программы на Java компилируются
в байткод, который может быть выполнен на любой платформе, на которую установлена JVM.

JDK (Java Development Kit) - это пакет разработчика Java , который включает в себя всё необходимое для разработки
Java-приложений, включая компилятор javac, библиотеки классов, документацию, примеры кода и JVM.

JRE (Java Runtime Environment) - это пакет для запуска Java-приложений, который включает в себя JVM, библиотеки классов и
другие необходимые компоненты для запуска Java-приложений.

## Как_работает_Garbage_Collector

Garbage Collector (GC) — это механизм в JVM, который автоматически освобождает память, удаляя объекты, на которые больше 
нет ссылок. Это предотвращает утечки памяти и позволяет не управлять памятью вручную.
Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:
1. Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые
2. Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
3. Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти.

Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:
1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
2. Когда область Eden заполняется, происходит минорная сборка мусора (Minor GC). Minor GC — это процесс, при котором 
   операции mark и sweep выполняются для young generation (молодого поколения).
3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и 
   S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что 
   они пережили сборку мусора).
5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются 
   в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor 
   GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
7. Major GC. При Major GC этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, 
   поскольку старое поколение в основном состоит из живых объектов.

Типы сборщиков мусора:
1. Serial - Использует один поток.
2. Parallel - Использует несколько потоков. (Работа со средними и большими наборами данных.)
3. G1 - Выполняет некоторую тяжелую работу параллельно с работой приложения. (Куча делится на регионы одинакового размера, и эти регионы 
   могут принадлежать либо молодому поколению, либо старому.)
4. Z1 - Выполняет всю тяжелую работу параллельно с работой приложения. Низкая задержка. Управляемая задержка через параметр.
5. ZGC - новое решение в котором минимальная задержка (ZGC использует так называемые load barriers - Это высоко оптимизированный код, 
   так что потоки приложения на Java будут работать практически незаметно, получая доступ к объекту)

Heap делится на три части:
1. Young Generation — новые объекты (большинство умирают быстро)
   Minor GC — частая, быстрая очистка молодых объектов.
2. Old Generation (Tenured) — "долго живущие" объекты
   Major GC / Full GC — более редкая, но дорогая операция.
3. Metaspace (до JDK 8 — PermGen) — хранит метаданные классов (не обычные объекты).

Алгоритмы GC в JVM:
1. Serial collector - Для сборки мусора используется один поток. Подходит для простых приложений с однопроцессорными машинами.
2. Parallel collector - В отличие от последовательного сборщика, использующего один поток, параллельный использует несколько потоков.
3. Concurrent collector - Concurrent collector выполняет сборку мусора вместе с работой потоков вашего приложения.

## Существует_два_подхода_к_обнаружению_мусора

1. Reference Counting (подсчёт ссылок)
2. Tracing Garbage Collection (Tracing-подход)
   В Java GC основан на Tracing-подходе, а не Reference Counting, так как последний не умеет работать с циклическими ссылками.
   Основные этапы:
   - Определение GC Roots – стартовая точка для обхода (стек, статика, JNI-ссылки).
   - Mark Phase – рекурсивный обход всех достижимых объектов (алгоритмы: DFS, BFS).
   - Sweep/Compact Phase – очистка или уплотнение памяти.

## Что_такое_Heap_и_Stack_память_в_Java_Какая_разница_между_ними

Примитивные типы (int, char, boolean, double и др.) хранятся непосредственно в стеке.
Ссылки на объекты (String, массивы, пользовательские классы) также хранятся в стеке, но сам объект – в куче.

Stack (Стек)
Назначение:
- Хранит примитивные типы (int, char, boolean и т. д.) и ссылки на объекты. 
- Содержит вызовы методов (стек вызовов – call stack) в виде фреймов (кадров).
- Автоматическое управление – память освобождается при завершении метода.

Heap (Куча)
Назначение:
- Хранит объекты и массивы, включая их поля (даже примитивные).

Особенности:
- Динамическое выделение памяти (размер можно регулировать через -Xms и -Xmx).
- Управляется Garbage Collector (GC) – автоматически удаляет неиспользуемые объекты.

## Расскажите_о_Java_Memory_Model_Какие_типы_памяти_у_JVM

Java Memory Model (JMM) - это модель памяти, описывающая способ, которым потоки в Java могут обращаться к переменным и
обмениваться данными. Она определяет правила, которые гарантируют корректность синхронизации и доступа к переменным в
разных потоках исполнения.

В JVM есть несколько типов памяти:
1. Heap – это регион памяти, где хранятся объекты Java. Куча управляется сборщиком мусора и является общей для всех потоков.
2. Stack – это область памяти, где хранятся локальные переменные и стек вызовов методов. Для каждого потока в JVM создается
   отдельный стек.
3. Method Area – это область памяти, где хранятся информация о классах и методах JVM. Здесь также хранятся константы и
   статические переменные.
4. Program Counter Register – это регистр, который указывает на следующую инструкцию, которую нужно выполнить в
   текущем потоке.
5. Native Method Stack – это стек, используемый для выполнения нативного кода.

## Что_будет_с_Garbage_Collector_если_finalize_будет_долго_выполняться_или_в_процессе_выполнения_получим_исключение

код будет всеравно выполнен

## Что_такое_сериализация_десириализация

Сериализация – преобразование объекта в байты, десериализация – восстановление.
чтобы его можно было:
- Сохранить в файл.
- Передать по сети.
- Записать в базу данных (как BLOB).

serialVersionUID – контроль версии класса
Если класс изменится после сериализации, при десериализации может возникнуть InvalidClassException.
Решение: явно задать serialVersionUID:

Альтернативы Serializable:
- JSON/XML (Gson, Jackson) – человекочитаемый формат, межъязыковая совместимость.
- Protocol Buffers (protobuf), Avro – бинарные форматы, эффективнее Serializable.

## Расскажите_про_классы_загрузчики_и_про_динамическую_загрузку_классов

В Java динамическая загрузка классов — это возможность загружать классы во время выполнения (runtime), а не во время 
компиляции. Это реализуется через ClassLoader и метод Class.forName() или с помощью кастомных загрузчиков.

## В_чем_разница_передачи_параметров_по_ссылке_и_значению

Разница в том, что при передаче по значению передаётся копия данных, а при передаче по ссылке — доступ к оригиналу. 
В Java всё передаётся по значению, но при передаче объектов передаётся значение ссылки, что позволяет менять состояние 
объекта, но не саму ссылку.

Передача по значению (pass by value):
В метод передаётся копия значения переменной. Изменения внутри метода не влияют на оригинал.

Передача по ссылке (pass by reference):
В метод передаётся реальная ссылка на объект, и любые изменения внутри метода влияют на оригинал.

## Расскажите_в_чем_разница_между_WeakReference_и_SoftReference

В Java существует два типа ссылок на объекты: WeakReference и SoftReference. Оба типа ссылок позволяют избежать утечек
памяти в приложениях, где объекты должны быть сохранены только до тех пор, пока они нужны.

WeakReference - это тип ссылки, который указывает на объект, который может быть удален из памяти JVM, когда он больше не
используется в программе, даже если у него есть активные ссылки. Таким образом, объект, на который указывает WeakReference,
может быть удален GC в любой момент времени.

SoftReference - это тип ссылки, который указывает на объект, который будет удален из памяти JVM только в том случае, если
системе необходимо освободить место в куче. Это означает, что объект, на который указывает SoftReference, будет удален
только в том случае, если память в куче заканчивается и других свободных ресурсов нет.

## Расскажите_про_абстрактный_класс

Абстрактный класс - это класс, который не может быть создан непосредственно экземпляром. Он служит только для описания
интерфейса для классов-наследников.

Абстрактный метод - это метод, который объявлен, но не реализован в абстрактном классе. Он не имеет тела и используется
для определения сигнатуры метода и типа возвращаемого значения.

## Расскажите_про_интерфейс

Интерфейс (interface) является типом данных, описывающим набор абстрактных методов без их реализации.

## Чем_отличается_абстрактный_класс_от_интерфейса

Абстрактный класс – если нужна общая базовая логика для родственных классов
Интерфейс – если нужно определить контракт для разных классов

Абстрактный класс — для иерархии и повторного использования кода.
Интерфейс — для определения поведения (даже для несвязанных классов).

Интерфейс - характеризует поведение
абстрактный класс - реализует отношение является

Абстрактный класс — средство разработки классов на нижнем уровне, средство для повторного использования кода; 
интерфейс — средство выражения семантики класса.
1. Абстрактные классы могут содержать как абстрактные, так и конкретные методы, тогда как интерфейсы могут содержать
   только абстрактные методы.
2. Класс может наследоваться только от одного абстрактного класса, но он может реализовывать несколько интерфейсов.
3. Абстрактные классы могут иметь конструкторы, тогда как интерфейсы не могут иметь конструкторов.

## record и sealed классы

Record-классы (записи) - это новый тип классов для моделирования неизменяемых (immutable) данных с минимальным количеством кода.
Record-классы идеально подходят для DTO

Основные особенности record-классов:
1. Краткость синтаксиса - объявление record заменяет множество шаблонного кода
2. Неизменяемость - все поля неявно final
3. Автоматические методы:
   - конструктор
   - методы доступа (геттеры)
   - equals()
   - hashCode()
   - toString()
Ограничения:
1. Нельзя наследовать record-классы (они неявно final)
2. Нельзя объявлять не-static поля (только в конструкторе)
3. Нельзя делать поля изменяемыми

Sealed-классы - нужны для контроля над иерархией наследования.
Основные цели sealed-классов:
1. Ограничение наследования - позволяют явно указать, какие классы или интерфейсы могут наследовать или реализовывать 
   данный класс/интерфейс
2. Улучшение безопасности типов - компилятор знает все возможные подтипы
3. Упрощение pattern matching - особенно полезно в сочетании с switch-выражениями

Проблема, которую решают sealed-классы:
Традиционно в Java есть два подхода:
1. final классы - вообще запрещают наследование
2. Обычные классы - позволяют неограниченное наследование любым классам
3. Sealed-классы предлагают золотую середину - наследование разрешено, но только явно указанным классам.

Преимущества:
1. Безопасность - компилятор проверяет все возможные варианты
2. Поддержка рефакторинга - при добавлении нового подтипа компилятор укажет места, которые нужно обновить
3. Четкий дизайн API - явное указание, какие реализации допустимы

Sealed-классы особенно полезны в сочетании с record-классами и pattern matching для создания типобезопасных, 
легко поддерживаемых моделей данных.

## Какие_типы_классов_бывают_в_java

В Java есть четыре типа вложенных классов:
1. Nested Inner Class (внутренний вложенный класс) - это нестатический вложенный класс, который определен внутри другого
   класса. Он имеет доступ ко всем полям и методам внешнего класса, а также может иметь свои собственные поля и методы.
2. Static Nested Class (статический вложенный класс) - это вложенный класс, который объявлен со словом ключевым static.
   Он не имеет доступа к нестатическим полям и методам внешнего класса, но может иметь собственные статические поля и методы.
3. Local Inner Class (локальный внутренний класс) - это вложенный класс, который определен внутри метода. Он имеет доступ к
   переменным и параметрам метода, а также может иметь доступ к нестатическим полям и методам внешнего класса.
4. Anonymous Inner Class (анонимный внутренний класс) - это класс без имени, который создается непосредственно в месте
   использования. Он обычно используется для реализации интерфейсов или классов-абстракций "на лету" без необходимости
   определения нового класса.

## Можно_ли_наследоваться_от_класса_String

Нет, нельзя. Класс String в Java объявлен как final

## Как_будет_вести_себя_String_при_конкатинации

допустим есть String, Integer "a","b","c",1,2,3 и как будут вести себя переменные мутабельные и не мутабельные при конкатинации
result = "a" + 1 + "b" + 2 + "c" + 3

поидее будет просто новая строка

## Какие_области_видимости_влияния_есть_в_Java

1. Локальные переменные (Local Variables)
   Объявляются внутри метода, конструктора или блока кода
   Видны только внутри этого блока.
2. Параметры методов (Method Parameters)
   Объявляются в списке параметров метода.
   Видны только внутри метода.
3. Переменные экземпляра (Instance Variables / Поля класса)
   Объявляются внутри класса, но вне методов.
   Видны во всех нестатических методах класса.
4. Статические переменные (Class Variables / Static Variables)

## var переменные

Это локальная переменная с выводом типа
1. Вывод типа на этапе компиляции
   - Компилятор определяет тип переменной на основе инициализатора
2. Только для локальных переменных
   - Не работает для:
     - полей класса
     - параметров методов
     - возвращаемых типов
3. Требует инициализации
   - Тип не может быть выведен без значения

## Расскажите_про_вложенные_классы_В_каких_случаях_они_применяются

Nested class используется для группировки связанных классов вместе и облегчения доступа к ним друг другу.
В Java есть четыре типа вложенных классов:
1. Nested Inner Class (внутренний вложенный класс) - это нестатический вложенный класс, который определен внутри другого
   класса. Он имеет доступ ко всем полям и методам внешнего класса, а также может иметь свои собственные поля и методы.
2. Static Nested Class (статический вложенный класс) - это вложенный класс, который объявлен со словом ключевым static.
   Он не имеет доступа к нестатическим полям и методам внешнего класса, но может иметь собственные статические поля и методы.
3. Local Inner Class (локальный внутренний класс) - это вложенный класс, который определен внутри метода. Он имеет доступ к
   переменным и параметрам метода, а также может иметь доступ к нестатическим полям и методам внешнего класса.
4. Anonymous Inner Class (анонимный внутренний класс) - это класс без имени, который создается непосредственно в месте
   использования. Он обычно используется для реализации интерфейсов или классов-абстракций "на лету" без необходимости
   определения нового класса.

## Чем_отличаются_final_finally_и_finalize

final - понятно
finally - block try,catch
finalize - блок который будет выполнен перед сборщиком мусора

## Какая_основная_разница_между_String_StringBuffer_StringBuilder

String - неизменяемый класс
StringBuffer - изменяемый класс для работы со строками. Он обеспечивает потокобезопасность и более медленный
StringBuilder - также изменяемый класс для работы со строками. Он не обеспечивает потокобезопасность

## Что_такое_класс_Object_Какие_в_нем_есть_методы

В Java все классы наследуются от класса Object. Некоторые методы, определенные в классе Object, включают в себя:
1. getClass(): возвращает объект Class, который представляет класс объекта
2. hashCode(): возвращает хэш-код объекта
3. equals(Object obj): определяет, равен ли данный объект указанному объекту
4. clone(): создает и возвращает копию данного объекта
5. toString(): возвращает строковое представление объекта
6. notify(): возобновляет выполнение потока, заблокированного на объекте
7. notifyAll(): возобновляет выполнение всех потоков, заблокированных на данном объекте
8. wait(): ожидает до тех пор, пока другой поток не уведомит о возможности продолжения выполнения
9. finalize(): вызывается сборщиком мусора перед тем, как объект будет удален

## Когда_используется_ключевое_слово_this

В Java ключевое слово "this" используется для ссылки на текущий объект внутри класса.

## Что_такое_ковариантность_типов

Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке.
ковариация — это если бы мы могли переменной типа List<Animal> задать объект типа ArrayList<Dog>

Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>.

Инвариантность — ситуация, когда наследование исходных типов не переносится на производные.

## Что_такое_обобщенные_типы_в_Java_Как_они_используются_при_работе_с_коллекциями

Generics — это механизм параметризации типов, который позволяет создавать обобщённые классы, методы, интерфейсы
Generics в Java реализованы через стирание типов (Type Erasure). На этапе компиляции информация о generics удаляется,
и в байт-коде остаются только сырые типы
Из-за этого в runtime нельзя:
❌ Создать new T() (нет информации о T).
❌ Проверить instanceof List<String> (можно только instanceof List).
❌ Использовать примитивы (List<int> → нужно Integer).

## Зачем_нужен_equals_Чем_он_отличается_от_операции_равно

Оператор == сравнивает ссылки на объекты, то есть проверяет, указывают ли две переменные на один и тот же объект в памяти.
Если две переменные указывают на один и тот же объект, то оператор == вернет true.
Метод equals(), с другой стороны, сравнивает содержимое объектов, а не ссылки на них.

## Какая_связь_между_hashCode_и_equals

Метод equals() определяет, равны ли два объекта друг другу. Если два объекта равны, то их hashCode() должны быть равными.

Метод hashCode() вычисляет числовое значение, которое идентифицирует объект. Это значение может быть использовано при
работе с коллекциями, такими как HashMap или HashSet, чтобы быстро найти нужный элемент.

Когда переопределяется метод equals(), также необходимо переопределить метод hashCode(). Это нужно потому, что если два
объекта равны, то их хеш-коды должны быть равными, чтобы они могли быть корректно добавлены в коллекцию, такую как HashMap
или HashSet.

Кроме того, хеш-код должен быть вычислен на основе полей объекта, которые используются в методе equals(). Это гарантирует,
что если два объекта равны с точки зрения метода equals(), то их хеш-коды будут равными. Если этого не происходит, то
может возникнуть проблема некорректного использования критических коллекций, например, HashMap.

## Что_будет_если_переопределить_equals_не_переопределяя_hashCode_Какие_могут_возникнуть_проблемы

Если в Java не переопределить методы equals и hashCode, то объекты будут сравниваться по ссылке (адресу памяти),
а не по содержимому. Это означает, что даже если два объекта имеют одинаковые значения своих полей, при сравнении
они будут не равны друг другу, если они находятся в разных местах в памяти. Таким образом, для корректной работы
коллекций, таких как HashMap и HashSet, необходимо переопределять методы equals и hashCode. Если этого не делать,
то при добавлении объектов в коллекции возможно некорректное поведение, например, дублирование элементов или потеря
элементов при запросе.

Что будет, если нарушить контракт equals() и hashCode()?
1. Случай 1: Переопределен equals(), но не hashCode()
  - Проблема: Объекты, которые равны по equals(), могут попасть в разные корзины из-за разного hashCode().
  - Результат: HashMap не сможет найти элемент, даже если он есть.
2. Случай 2: Переопределен hashCode(), но не equals()
  - Проблема: Объекты с одинаковым hashCode будут считаться разными, если equals() не переопределён.
  - Результат: В одной корзине могут находиться дубликаты ключей.
3. Случай 3: hashCode() возвращает константу
  - Проблема: Все объекты попадают в одну корзину → HashMap вырождается в связный список.
  - Результат: Производительность падает с O(1) до O(n).

## Могут_ли_у_разных_объектов_быть_одинаковые_hashCode

да могут это называется коллизией.
При коллизии используется equals() для точного сравнения.

## Какова_роль_equals_и_hashCode_в_HashMap

Роль hashCode()
1. Определение корзины  
   - При добавлении или поиске элемента HashMap сначала вычисляет hashCode() ключа.
2. Коллизии
   - Если два разных ключа имеют одинаковый hashCode, они попадают в одну корзину.
   - В этом случае HashMap использует equals(), чтобы проверить, действительно ли ключи одинаковые.

Роль equals()
1. Точное сравнение ключей
   - Если hashCode совпал, HashMap проверяет ключи через equals().
   - Если equals() возвращает true → значение перезаписывается (для put()) или возвращается (для get()).
   - Если equals() возвращает false → элемент добавляется в ту же корзину (как узел связного списка или дерева).

Что будет, если нарушить контракт equals() и hashCode()?
1. Случай 1: Переопределен equals(), но не hashCode()
   - Проблема: Объекты, которые равны по equals(), могут попасть в разные корзины из-за разного hashCode().
   - Результат: HashMap не сможет найти элемент, даже если он есть.
2. Случай 2: Переопределен hashCode(), но не equals()
   - Проблема: Объекты с одинаковым hashCode будут считаться разными, если equals() не переопределён.
   - Результат: В одной корзине могут находиться дубликаты ключей.

## Какие_условия_выдвигаются_при_переопределении_equals

При переопределении метода equals() в Java следует соблюдать несколько условий:
1. Рефлексивность: a.equals(a) должно вернуть true. То есть объект всегда равен самому себе.
2. Симметричность: если a.equals(b) вернуло true, то и b.equals(a) должно вернуть true.
3. Транзитивность: если a.equals(b) и b.equals(c) вернули true, то и a.equals(c) должно вернуть true.
4. Консистентность: повторные вызовы метода equals() для одного объекта должны возвращать одинаковый результат, при
   условии, что никакие поля, используемые при проверке на равенство, не были изменены.

## Как_работает_hashCode_и_equals_в_Java

Equals и HashCode в Java используются для работы с объектами в коллекциях и для поддержания уникальности объектов.
Метод equals() используется для проверки равенства двух объектов. Для классов, которые не переопределили этот метод,
он проверяет, являются ли два объекта ссылками на один и тот же объект в памяти.

Метод hashCode() используется при работе с хеш-таблицами и другими алгоритмами, основанными на хеш-функциях.
Он должен генерировать уникальный целочисленный код для каждого объекта класса. Это помогает быстро находить объекты
в коллекции, используя хеш-функцию для поиска.

## Расскажите_о_контракте_между_equals_and_hashcode

Контракт между методами equals() и hashCode() заключается в том, что если два объекта равны согласно методу equals(),
то они должны иметь одинаковый hashCode(). Обратное правило не всегда верно: два объекта с одинаковым hashCode()
могут быть не равными согласно методу equals(). Если этот контракт не выполняется, то объекты могут быть неправильно
обрабатываться в хеш-таблицах и других алгоритмах, основанных на хеш-функциях.

При переопределении методов equals() и hashCode() следует придерживаться следующих правил:
- Если два объекта равны согласно методу equals(), то они должны иметь одинаковый hashCode().
- Для двух любых объектов класса, для которых equals() возвращает false, не требуется, чтобы их hashCode() были разными,
  но это может увеличить эффективность работы с хеш-таблицами.

## Каково_максимальное_число_значений_hashCode

Максимальное количество уникальных хеш-кодов = 2³²

## Что_такое_коллизия_в_Hashcode_И_как_с_ней_бороться

1. Всегда переопределяйте hashCode() вместе с equals().
2. Используйте Objects.hash() для стандартного и эффективного хеширования.
3. Увеличивайте размер HashMap, если ожидается много элементов.
4. Выбирайте уникальные поля для хеширования (например, id + timestamp).

## Механизм_CAS

Механизм CAS (Compare and Swap) в Java используется для реализации атомарных операций над общей памятью. 
Он позволяет обновлять значение переменной только в том случае, если оно не было изменено другим потоком с момента 
последнего чтения. Это позволяет избежать состояния гонки и обеспечивает согласованность данных при параллельном 
выполнении.

В Java механизм CAS реализован с помощью класса java.util.concurrent.atomic.AtomicXXX, где XXX может быть Integer, Long,
Boolean и т.д. Эти классы предоставляют методы для выполнения атомарных операций, таких как чтение, запись и обновление 
значения переменной.

## Опишите_иерархию_исключений

В Java исключения делятся на две категории: checked (проверяемые) и unchecked (непроверяемые).
Checked исключения - это те, которые должны быть обработаны программистом.
Unchecked исключения - это те, которые не обязательно должны быть обработаны программистом.

Ключевые слова throw и throws используются для работы с исключениями в Java. Throw используется для выброса исключения 
в блоке кода, а throws используется в объявлении метода, чтобы указать, что метод может выбросить определенный тип 
исключения.

В Java, иерархия исключений начинается с класса Throwable. Throwable имеет два подкласса: Error и Exception.
Throwable также имеет два дополнительных подкласса: Checked и Unchecked. Checked является подклассом Exception и 
представляет проверяемые исключения, которые должны быть обработаны программистом, а Unchecked - это RuntimeException 
и его подклассы, которые не требуют обработки при компиляции кода.

## Что_такое_generics

Generics — это механизм, позволяющий создавать классы, интерфейсы и методы с параметризованными типами. 
Они обеспечивают:
1. Типобезопасность (избегание ClassCastException).
2. Улучшенную читаемость кода (явное указание типов).
3. Повторное использование кода (один алгоритм для разных типов).

Он позволяет определять классы, интерфейсы и методы, которые работают с различными типами объектов, 
не указывая точный тип данных заранее.
Основная проблема, которую решают generics - это избежание ошибок связанных с типами данных (Type Safety).

## Что_такое_лямбда

Лямбда-выражения — это анонимные функции, которые позволяют кратко и удобно реализовывать методы интерфейсов 
с одним абстрактным методом (функциональных интерфейсов).

## Что_такое_ссылка_на_метод

Ссылка на метод — это компактный синтаксис лямбда-выражения, который позволяет переиспользовать уже существующий
метод вместо написания новой лямбды.

## Что_такое_функциональные_интерфейсы

Функциональный интерфейс — это интерфейс, который содержит только один абстрактный метод.

Как создать свой функциональный интерфейс?
- Объявите интерфейс с одним абстрактным методом.
- Добавьте аннотацию @FunctionalInterface (опционально, но рекомендуется).

## Какие_новые_функциональные_интерфейсы_появились_в_Java_8

Некоторые из наиболее используемых функциональных интерфейсов включают:
1. Function: принимает один аргумент и возвращает результат заданного типа.
2. Predicate: принимает один аргумент и возвращает логическое значение (true,false)
3. Consumer: принимает один аргумент и не возвращает результат (void).
4. Supplier: не принимает аргументов, но возвращает заданный тип.
5. UnaryOperator: принимает один аргумент и возвращает значение того же типа.
6. BinaryOperator: принимает два аргумента и возвращает значение того же типа. Кроме того, в Java 8 были добавлены такие 
   функциональные интерфейсы, как BiFunction, BiPredicate, BiConsumer, IntFunction, DoubleFunction, LongFunction, 
   ToIntFunction, ToDoubleFunction, ToLongFunction и другие.

## Как_взаимосвязаны_функциональные_интерфейсы_и_лямбда_выражения

Лямбда-выражения в Java позволяют создавать экземпляры функциональных интерфейсов через компактный и выразительный 
синтаксис. Функциональные интерфейсы и лямбда-выражения тесно связаны между собой, поскольку лямбда-выражения используются
для реализации методов функциональных интерфейсов.

Функциональный интерфейс определяет единственный абстрактный метод, который должен быть реализован классом или 
лямбда-выражением. Лямбда-выражение является реализацией этого абстрактного метода. Например, можно создать 
лямбда-выражение, которое реализует метод apply() из функционального интерфейса Function

## Что_такое_static_метод_интерфейса

static-метод в интерфейсе — это метод, который принадлежит самому интерфейсу, а не его реализующим классам. 
Он вызывается через имя интерфейса (например, InterfaceName.staticMethod()), аналогично статическим методам в классах.
Особенности:
1. Принадлежит интерфейсу, а не объектам.
2. Не может быть переопределён в классах, реализующих интерфейс.
3. Не имеет доступа к нестатическим полям/методам интерфейса (только к другим static-методам и default-методам).

Зачем нужны static-методы в интерфейсах?
1. Утилитарные функции: Методы, которые логически связаны с интерфейсом, но не требуют состояния объекта.
2. Замена Utility-классам: Раньше для таких методов создавали отдельные классы (например, Collections), 
   теперь их можно размещать в интерфейсах.
3. Инкапсуляция логики: Помещение вспомогательных методов прямо в интерфейс, который их использует.

## Какие_существуют_способы_создания_стрима

1. Из коллекций (List, Set, Map)
2. Из массивов Arrays.stream(array)
3. Из значений (Stream.of)
4. Из файлов (Files.lines)
5. Из строки (String.chars, String.lines)

## Для_чего_в_стримах_предназначены_методы_flatMap_flatMapToInt_flatMapToDouble_flatMapToLong

Эти методы используются для "разворачивания" (flattening) вложенных структур данных 
(например, списков внутри списков, массивов в стримах и т.д.) в единый "плоский" (flat) стрим.

1. flatMap — Преобразует каждый элемент стрима в новый стрим, а затем объединяет все стримы в один.
   Пример: Если элемент стрима содержит вложенные коллекции
   `Stream<R> (один ко многим)	[ [1,2], [3,4] ] → [1, 2, 3, 4]`
2. flatMapToInt, flatMapToDouble, flatMapToLong - Эти методы аналогичны flatMap, но возвращают 
   специализированные стримы для примитивов.
   Пример: Если нужно работать с примитивными типами

## Какие_основные_ограничения_действуют_на_статические_переменные_и_методы

Ограничения для статических переменных:
1. Принадлежат классу, а не объекту
2. Не могут использовать нестатические поля/методы
3. Инициализация

Ограничения для статических методов:
1. Не могут обращаться к нестатическим членам класса
2. Не могут использовать this и super
3. Не могут быть переопределены (но можно "скрыть")

## Что_такое_FunctionInterface_и_чем_он_отличается_от_обычного_интерфейса

FunctionInterface - это функциональный интерфейс в Java. Он представляет собой интерфейс, который содержит только 
один абстрактный метод. Этот метод может иметь любое количество параметров и тип возвращаемого значения, но он должен 
быть единственным абстрактным методом в этом интерфейсе.

Отличие FunctionInterface от обычного интерфейса заключается в том, что функциональный интерфейс может быть использован 
как лямбда-выражение. Это означает, что вы можете создать анонимную реализацию функционального интерфейса без 
необходимости создавать новый класс.

## Чем_отличается_метод_map_от_flatMap

map — когда нужно изменить каждый элемент без изменения структуры (например, вычислить длину строк, привести к 
верхнему регистру).
Пример: `[a, b, c] → [A, B, C] (преобразование каждого элемента).`

flatMap — когда элементы содержат вложенные коллекции/стримы, и их нужно "разгладить".
Пример: `[[a, b], [c, d]] → [a, b, c, d]`

## Чем_отличается_Lambda_от_анонимного_класса

Lambda-выражение и анонимный класс в Java - это два способа создания объектов, которые могут быть использованы для 
реализации интерфейсов или абстрактных классов.
Лямбды — для краткости и производительности с функциональными интерфейсами.
Анонимные классы — для сложных сценариев (множество методов, изменение переменных).

Лямбда-выражения, по сути, это анонимный класс или метод. Лямбда-выражение не выполняется само по себе. Вместо этого, 
оно используется для реализации метода, определенного в функциональном интерфейсе.

Типы лямбда-выражений:
1. блочные
2. однострочные

Лямбда:
- Работа с Stream API (filter, map, forEach).
- Простые реализации функциональных интерфейсов (Runnable, Comparator).
- Когда нужна производительность и читаемость.

Анонимный класс:
- Интерфейсы/классы с несколькими методами.
- Когда нужно изменять переменные внешнего класса.
- Для переопределения методов абстрактных классов (например, Thread).

--------------------------------------------------------------------------------------------------------------------------------------------------

## Расскажите_про_иерархию_коллекции
                                        Itrerable
                                        Collection
           List             Queue               Set                  Map
        - ArrayList     - LinkedList        - SortedSet           - SortedMap
        - LinkedList    - Deque             - HashSet             - LinkedHashMap
        - Vector                            - TreeSet             - HashMap
                                            - LinkedHashSet

## Что_такое_fail_fast_поведение

Fail-fast и fail-safe представляют две разные стратегии обработки ошибок, применяемые при работе с коллекциями в Java.

Fail-fast:
Коллекции с fail-fast поведением немедленно выбрасывают исключение, если обнаруживают, что структура данных была 
изменена (добавление/удаление элементов) во время итерации.
Как работает?
- Использует счётчик изменений (modCount).
- При каждой модификации коллекции (например, add(), remove()) modCount увеличивается.
- Во время итерации сравнивает modCount с ожидаемым значением. Если они не совпадают → ConcurrentModificationException.

Fail-safe (Безопасный отказ)
Коллекции с fail-safe поведением не выбрасывают исключение при изменении во время итерации. Вместо этого они работают с 
копией данных или используют механизмы для избежания конфликтов.
Как работает?
- CopyOnWriteArrayList: Создаёт новую копию массива при изменении.
- ConcurrentHashMap: Использует сегментирование (блокировка только части данных).

## Как_между_собой_связаны_Iterable_и_Iterator

Интерфейс Iterable<T> (пакет java.lang) предоставляет возможность обхода элементов с помощью цикла for-each.
Интерфейс Iterator<E> (пакет java.util) предоставляет методы для последовательного доступа к элементам.
Связь: Iterable предоставляет Iterator через метод iterator().

## В_чем_разница_между_Enumeration_и_Iterator

Enumeration — это устаревший (legacy) интерфейс, оставшийся для совместимости.
Iterator — его усовершенствованная замена, представленная в Java Collections Framework

## Comparator_vs_Comparable

Comparable — это интерфейс для естественного порядка сортировки (например, числа по возрастанию). 
Реализуется внутри класса через метод compareTo().

Comparator — это интерфейс для кастомной сортировки (например, по имени или возрасту). Реализуется 
вне класса через метод compare()

## Как_избежать_ConcurrentModificationException_во_время_перебора_коллекции

Исключение ConcurrentModificationException возникает, когда коллекция изменяется 
(добавление/удаление элементов) во время итерации.

Как избежать:
1. Использовать Iterator и его метод remove()
2. Копировать коллекцию перед перебором
3. Использовать CopyOnWriteArrayList
4. Использовать Stream.filter()

## Какой_интерфейс_нужно_реализовать_чтобы_создать_свою_собственную_коллекцию

1. Выберите интерфейс (List, Set, Queue, Map).
2. Реализуйте обязательные методы (например, для List — get(), add(), size()).
3. Определите структуру данных:
   - ArrayList → динамический массив.
   - HashSet → хэш-таблица.
   - LinkedList → двусвязный список.
4. Переопределите equals()/hashCode() (если коллекция зависит от сравнения элементов).
5. Реализуйте Iterator (для поддержки for-each).

## Как_работает_итератор_в_Java_коллекциях

Итератор (Iterator) — это объект, который предоставляет стандартный способ последовательного доступа к 
элементам коллекции без раскрытия её внутренней структуры.
Для ArrayList
1. Хранение состояния:
   Итератор запоминает текущий индекс (cursor) и размер коллекции.
2. Проверка hasNext():
   Сравнивает cursor с size.
3. Получение элемента next():
   Возвращает элемент по индексу cursor и увеличивает cursor на 1.
4. Удаление remove():
   Удаляет элемент, который был последним возвращён next().

## Каким_образом_можно_создать_immutable_коллекции_в_Java

В Java вы можете сделать объект неизменяемым (immutable), задав его поля как final.

## Чем_отличается_ArrayList_от_LinkedList

ArrayList - ArrayList использует массив для хранения элементов. Когда вы добавляете новый элемент в ArrayList,
он добавляется в конец массива, если есть свободное место, или создается новый массив большего размера и все существующие
элементы копируются в него. Это позволяет быстро получать элементы по индексу, потому что индекс соответствует индексу
массива.
Плюсы
✅ Быстрый доступ по индексу (get(index), set(index)) – O(1).
✅ Эффективное использование кэша процессора (данные хранятся в непрерывной области памяти).
✅ Меньшие накладные расходы на хранение (только данные + немного служебной информации).
Минусы
❌ Медленная вставка/удаление в середине списка – O(n) (нужно сдвигать элементы).
❌ Требует увеличения capacity, что может приводить к временным затратам.

LinkedList - хранит элементы в виде узлов, каждый из которых содержит ссылку на следующий узел в списке.
Это означает, что при добавлении или удалении элементов нет необходимости перемещать другие элементы, только нужно
обновить ссылки на узлы. Однако доступ к элементам по индексу выполняется медленнее, потому что для этого нужно пройти
всю цепочку узлов до нужного индекса.

Плюсы
✅ Быстрая вставка/удаление в начале и середине – O(1) (если известна позиция).
✅ Нет затрат на увеличение capacity (разрастается динамически).
Минусы
❌ Медленный доступ по индексу (get(index), set(index)) – O(n) (нужно идти от начала/конца).
❌ Большие накладные расходы (каждый элемент хранит 2 ссылки + данные).
❌ Плохая локализация данных (элементы разбросаны по памяти).

## Сравните_интерфейсы_Queue_и_Deque

Queue (очередь) и Deque (двусторонняя очередь) — это интерфейсы для работы с упорядоченными коллекциями, но они различаются 
направлением доступа к элементам и функциональностью.
Queue — базовый интерфейс для очередей.
Deque наследует Queue и добавляет двусторонние операции.
Реализации:
- LinkedList: Подходит и для Queue, и для Deque.
- ArrayDeque: Эффективнее для Deque (на основе массива).
- PriorityQueue: Только для Queue (с приоритетами).

## Какая_коллекция_реализует_дисциплину_обслуживания_FIFO

Стандартные FIFO-коллекции: LinkedList, ArrayDeque.
Приоритетная очередь: PriorityQueue (не чистая FIFO!).
Для многопоточности: LinkedBlockingQueue.

## Какая_коллекция_реализует_дисциплину_обслуживания_FILO

Deque (ArrayDeque, LinkedList)

## Что_позволяет_сделать_PriorityQueue

PriorityQueue — это очередь с приоритетами, которая хранит элементы в отсортированном порядке (не по FIFO!).
Особенности PriorityQueue
1. Автоматическая сортировка
   Элементы хранятся не в порядке добавления, а по приоритету (по умолчанию — натуральный порядок или компаратор).
2. Гибкая настройка порядка
   Можно задать свой Comparator
3. Быстрая вставка и удаление
   Вставка (offer) и удаление (poll) работают за O(log n).
   Просмотр (peek) — O(1).

PriorityQueue основана на двоичной мин-куче (min-heap) — это дерево, где каждый родитель меньше своих потомков.
При вставке/удалении происходит перебалансировка кучи.

## Что_такое_WeakHashMap_В_каких_случаях_его_использование_может_быть_полезно

WeakHashMap — это специальная реализация Map в Java, которая использует слабые ссылки (Weak References) для ключей. 
Это позволяет сборщику мусора (GC) автоматически удалять записи, когда на ключи больше нет сильных ссылок.

Основные особенности WeakHashMap:
1. Ключи хранятся как WeakReference — если на ключ нет других ссылок, кроме самой мапы, GC может удалить запись.
2. Значения привязаны к ключам — если ключ удалён, значение тоже становится недоступным.
3. Не потокобезопасна — для многопоточной работы нужна внешняя синхронизация.
4. Производительность близка к HashMap — O(1) для get()/put() в среднем случае.

Когда использовать WeakHashMap?
1. Кеширование, где записи должны автоматически удаляться при неиспользовании.
2. Хранение метаданных для объектов, время жизни которых контролируется извне.
3. Связка объектов без "жёсткого" удержания в памяти.

## Что_такое_IdentityHashSet_В_каких_случаях_его_использование_может_быть_полезно

IdentityHashSet — это специальная реализация Set, которая использует сравнение объектов по ссылке (==), а не по 
значению (как стандартный HashSet). Это означает, что два объекта считаются одинаковыми только если это один и тот же
объект в памяти, даже если их equals() и hashCode() идентичны.

Когда использовать IdentityHashSet?
1. Сравнение объектов по ссылке (например, мониторы для синхронизации).
2. Тестирование утечек памяти (отслеживание уникальных экземпляров).
3. Работа с mutable-объектами, где equals()/hashCode() могут меняться.

## Что_такое_CopyOnWriteArrayList_В_каких_случаях_он_может_быть_полезен

CopyOnWriteArrayList — это потокобезопасная реализация List, которая обеспечивает безопасность в многопоточной среде 
за счёт стратегии "копирование при записи" (Copy-On-Write).
Внутренняя реализация:
1. Хранит данные в volatile массиве:
   `private transient volatile Object[] array;`
2. При модификации:
   - Создаётся полная копия массива
   - Изменения применяются к копии
   - Копия становится новым массивом

Когда использовать?
- Частые чтения, редкие записи
- Коллекции слушателей событий (listeners)
- Кэши, которые редко обновляются

## Как_работает_HashMap

Принцип работы:
Вставка
1. Вычисление хэша ключа:
   Если key == null, он попадает в бакет 0.
   Иначе вычисляется hash = key.hashCode()
2. Определение бакета:
   index = (n - 1) & hash, где n — размер массива.
3. Проверка коллизий:
   Если бакет пуст → элемент добавляется.
   Если в бакете уже есть элементы:
   - Если ключ совпадает (по equals()) → значение перезаписывается.
   - Если нет → элемент добавляется в конец связного списка (или в дерево, если список слишком большой).

Получение значения
1. Вычисляется hash(key).
2. Находится бакет: index = (n - 1) & hash.
3. Если в бакете один элемент → возвращается его value.
4. Если есть коллизия:
   Для связного списка – перебор элементов, пока не найдется совпадение по equals().
   Для дерева – используется TreeNode.getTreeNode()

HashMap - это реализация интерфейса Map в Java, который использует хэш-таблицу для хранения ключей и соответствующих
им значений. Внутренняя структура HashMap состоит из массива бакетов (buckets), которые содержат список связанных узлов
(Node).
Каждый элемент в HashMap представлен объектом Node, который содержит ключ, значение и ссылку на следующий элемент списка.
При добавлении нового элемента в HashMap вычисляется хэш-код ключа, и на основании этого хэш-кода определяется индекс
бакета, в который будет добавлен элемент.
Если два ключа имеют одинаковый хэш-код, то они будут добавлены в один и тот же бакет и будут связаны друг с другом в
виде списка. Каждый элемент списка связан со следующим элементом через ссылку на объект Node.
При поиске элемента в HashMap сначала вычисляется хэш-код ключа и определяется соответствующий ему бакет. Затем
производится поиск элемента в списке узлов, связанных в данном бакете. Если находится элемент с запрашиваемым ключом,
то он возвращается, в противном случае метод вернет null.
Когда количество элементов в HashMap достигает определенного порога, размер массива бакетов увеличивается. Это позволяет
увеличить количество бакетов и, следовательно, уменьшить среднее количество элементов в каждом бакете, что повышает
производительность поиска.

Как работает HashMap:
1. Каждый объект в HashMap имеет свой уникальный ключ.
2. При добавлении элемента в HashMap, вычисляется хэш-код ключа с помощью метода hashCode() у ключа.
3. Затем, для каждого хэш-кода вычисляется индекс массива, где будет храниться значение.
4. Если два ключа имеют одинаковый хэш-код, они могут быть сохранены в одной ячейке массива, но будут храниться в
   односвязном списке в этой ячейке.
5. Когда происходит запрос на получение значения по ключу, сначала вычисляется хэш-код ключа, затем определяется индекс
   массива, где может быть найдено значение. Если в этой ячейке есть список, пробегаем по списку, чтобы найти нужное
   значение.
6. Важно отметить, что при использовании HashMap необходимо правильно переопределить методы equals() и hashCode() класса
   ключа, чтобы обеспечить правильное функционирование хэш-таблицы. Кроме того, когда количество элементов в HashMap
   достигает определенного порога, размер массива увеличивается автоматически для поддержания эффективности хранения и
   доступа к данным.

## Принцип_работы_HashSet

HashSet — это обёртка над HashMap, где элементы хранятся как ключи.
Порядок не гарантирован → если важен порядок вставки, берите LinkedHashSet.
HashSet внутри Java работает по принципу хэш-таблицы. Хэш-таблица - это структура данных, которая позволяет быстро
добавлять, удалять и искать элементы. В HashSet каждый элемент имеет свой уникальный хэш-код, который используется
для определения его местоположения в хэш-таблице.

HashSet содержит массив элементов и список связанных списков (bucket), где каждый элемент помещается в соответствующий
bucket на основе его хэш-кода. Когда элемент добавляется в HashSet, сначала вычисляется его хэш-код, затем он помещается
в bucket, соответствующий этому хэш-коду. Если bucket пустой, элемент просто добавляется в него. Если bucket уже содержит
элементы, то новый элемент добавляется в конец списка связанных элементов.

При поиске элемента в HashSet, сначала вычисляется его хэш-код. Затем HashSet проверяет bucket, соответствующий этому
хэш-коду, чтобы найти элемент с таким же хэш-кодом. Если bucket не пустой, HashSet перебирает все элементы в списке
связанных элементов, чтобы найти элемент с таким же значением. Если элемент найден, метод возвращает true, иначе - false.

Поскольку HashSet использует хэширование для хранения элементов, порядок элементов внутри HashSet не сохраняется.
Однако, HashSet обеспечивает O(1) сложность поиска элемента, что делает его эффективным выбором для задач, связанных
с быстрой проверкой наличия элемента в коллекции.

## Каково_внутреннее_строение_TreeMap

TreeMap - это реализация интерфейса Map в Java, которая использует красно-черное дерево для хранения пар ключ-значение.
Внутреннее строение TreeMap состоит из узлов, каждый из которых содержит ключ, значение, ссылки на левого и правого
потомков, а также цвет узла. Каждый узел может быть либо чёрным, либо красным.
Красно-черное дерево (RBT) - это бинарное дерево поиска, в котором каждый узел помечен красным или чёрным цветом.
Свойства RBT:
1. Каждый узел является либо красным, либо чёрным.
2. Корень дерева всегда чёрный.
3. Если узел красный, то его потомки - чёрные.
4. Для каждого узла все простые пути от него до листьев дерева содержат одинаковое количество чёрных узлов.

Рассмотрим как работает TreeMap при добавлении нового элемента:
- Новый элемент добавляется в дерево, как если бы TreeMap была обычным бинарным деревом поиска.
- Затем производится перебалансировка дерева с помощью поворотов и изменения цвета узлов, чтобы сохранить свойства RBT.

Повороты - это операции, при которых узел дерева перемещается в другое место.
Существуют два типа поворотов: левый и правый. При левом повороте правый потомок узла становится его родителем, а сам
узел становится левым потомком своего правого потомка. При правом повороте левый потомок узла становится его родителем,
а сам узел становится правым потомком своего левого потомка.
При добавлении нового элемента и перебалансировке дерева TreeMap сохраняет свою высокую производительность поиска и
доступа к элементам, так как каждый узел имеет максимальное число потомков, равное двум. Красно-черное дерево также
обеспечивает быстрый поиск и удаление элементов.
Таким образом, благодаря использованию RBT, TreeMap обладает преимуществами перед другими коллекциями, которые не
поддерживают сложные операции сравнения (например, LinkedList и HashSet), и может быть использована в сценариях, где
требуется хранение данных в отсортированном порядке и быстрый доступ к элементам.

## Основные_характеристики_TreeSet

TreeSet - это реализация интерфейса NavigableSet в Java, которая хранит элементы в отсортированном порядке 
с использованием красно-чёрного дерева.
Основные характеристики:
1. Автоматическая сортировка элементов
2. Не допускает дубликаты (как и все Set-реализации)
3. Не поддерживает null (если только не задан явный Comparator)
4. Потоконебезопасен (требует внешней синхронизации)
5. Основан на TreeMap (использует его для хранения данных)

## Основные_характеристики_LinkedHashSet

LinkedHashSet — это гибридная коллекция, сочетающая возможности HashSet и LinkedList. 
Она сохраняет уникальность элементов как HashSet, но при этом поддерживает порядок вставки элементов.
Основные особенности LinkedHashSet:
1. Сохраняет порядок вставки (в отличие от HashSet)
2. Гарантирует уникальность элементов (как все Set-реализации)
3. Основан на LinkedHashMap (внутри использует хеш-таблицу + двусвязный список)
4. Производительность близка к HashSet (O(1) для основных операций)
5. Потоконебезопасен (как и большинство коллекций Java)

## LinkedHashMap_что_в_нем_от_LinkedList_а_что_от_HashMap

LinkedHashMap — это специальная реализация Map, которая сочетает возможности HashMap и LinkedList, 
сохраняя порядок элементов.

Основные особенности:
1. Сохраняет порядок: либо порядок вставки, либо порядок доступа (LRU)
2. Наследует HashMap: использует хеш-таблицу для быстрого доступа (O(1))
3. Двусвязный список: поддерживает порядок элементов
4. Не потокобезопасен: требует внешней синхронизации
5. Позволяет null: как ключи, так и значения

Она использует двусвязный список для хранения элементов и хеш-таблицу для быстрого доступа к ним. Ключи должны быть
уникальными и могут быть любого типа (кроме null). Эта реализация не является потокобезопасной.
LinkedHashMap бывает двух видов - с сохранением порядка вставки и с сохранением порядка доступа.

## В_чем_разница_между_HashMap_и_IdentityHashMap

1. Сравнение ключей
   HashMap
   - Использует equals() и hashCode() для сравнения ключей.
   - Если два объекта "равны" по equals(), они считаются одним ключом.
   IdentityHashMap
   - Использует == (сравнение по ссылке).
   - Два разных объекта с одинаковыми данными считаются разными ключами.
2. Внутренняя реализация
   HashMap
   - Основан на хеш-таблице с корзинами (buckets).
   - Использует hashCode() для распределения ключей.
   IdentityHashMap
   - Использует линейное хеширование (открытую адресацию).
   - Не полагается на hashCode() — вместо этого использует System.identityHashCode().
   - Разрешает несколько null-ключей (в отличие от HashMap).

## В_чем_разница_между_HashMap_и_WeakHashMap

WeakHashMap использует слабые ссылки (WeakReference) для ключей. Это значит:
1. Если на ключ нет других сильных ссылок, кроме самой мапы, запись будет автоматически удалена сборщиком мусора.
2. Значения остаются доступны только пока существует ключ.

## В_чем_разница_между_HashMap_и_TreeMap

Разница между HashMap и TreeMap:

- Упорядоченность элементов: В HashMap порядок элементов не гарантируется, тогда как TreeMap автоматически упорядочивает 
элементы в соответствии с естественным порядком или с помощью компаратора.
- Производительность: Вставка, удаление и поиск элементов происходят быстрее в HashMap, чем в TreeMap, потому что HashMap 
использует хэш-таблицу для хранения элементов, в то время как TreeMap использует красно-черное дерево.
- Дополнительные методы: TreeMap предоставляет дополнительные методы для работы с элементами в порядке их ключей, такие как 
- firstKey(), lastKey() и subMap(). HashMap не имеет этих методов.

HashMap лучше использовать, если не требуется сохранять элементы в определенном порядке и когда требуется высокая скорость 
выполнения операций вставки, удаления и поиска элементов.

TreeMap лучше использовать, когда необходимо сохранять элементы в отсортированном порядке или в порядке, заданном 
компаратором.

## В_чем_разница_между_HashSet_LinkedHashSet_и_TreeSet

TreeSet — если нужна сортировка или работа с диапазонами
HashSet — если важна скорость и порядок не имеет значения
LinkedHashSet — если нужен HashSet с сохранением порядка вставки

## Чем_отличается_ConcurrentHashMap_от_HashMap

тут лучше расскказать про итератор fail-fast и weeklendConsistent. Тут говорится о том что 
если во время итерации по хэшмапе проходить и данные поменябтся то возникнт ошибка а в ConcurenntHashMap нет.

HashMap — для однопоточных приложений (выше производительность)
ConcurrentHashMap — для многопоточных сценариев (без явных блокировок)"

HashMap:
- Не потокобезопасен (требует внешней синхронизации)
- Разрешает null-ключи и значения
- Использует хеш-таблицу
- Итераторы fail-fast (бросают ConcurrentModificationException)

ConcurrentHashMap:
- Потокобезопасен из коробки (оптимизирован для многопоточности)
- Запрещает null-значения
- Использует сегментированные блокировки (блокирует только часть данных)
- Итераторы weakly-consistent (не бросают исключений при изменении)
- Предоставляет атомарные операции (putIfAbsent, compute)

## Какой_будет_hash_у_объекта_null_в_HashMap

В Java, если в HashMap один из элементов (ключ или значение) равен null, то его хеш-код всегда будет 0.

Как работает HashMap с null?
Если ключ null:
- Его хеш-код hashCode() считается равным 0.
- В HashMap есть специальная логика для обработки null-ключей.
- null-ключ всегда хранится в нулевой корзине (bucket 0).

## Можно_ли_использовать_null_ключ_в_HashMap

Да, HashMap в Java разрешает использование null в качестве ключа
Может привести к NullPointerException, если не проверять containsKey(null)

## В_каком_случае_может_быть_потерян_элемент_в_HashMap

Элемент может быть "потерян" в HashMap в следующих случаях:
1. Изменение ключа после добавления
2. Коллизии при перезаписи
Если equals() реализован некорректно, два "одинаковых" ключа могут сосуществовать
3. Проблемы с многопоточностью
4. Неправильный hashCode()

## Как_и_когда_происходит_увеличение_количества_корзин_в_HashMap

threshold = capacity * loadFactor
Где:
capacity — текущий размер массива бакетов (по умолчанию 16)
loadFactor — коэффициент загрузки (по умолчанию 0.75)

Как происходит увеличение?
- Создаётся новый массив бакетов в 2 раза больше текущего (16 → 32 → 64 и т. д.).
- Все существующие элементы перераспределяются по новым бакетам.
- Индекс каждого элемента пересчитывается

## Как_узнать_что_ключ_уже_присутствует_в_HashMap

Использование containsKey()

## Что_произойдет_если_попытаться_добавить_null_элемент_в_LinkedList_или_HashSet

LinkedList Да, LinkedList позволяет добавлять null как элемент.
HashSet Да, но с ограничениями.

## Какие_коллекции_в_Java_являются_потокобезопасными

1. ConcurrentHashMap - Потокобезопасный аналог HashMap с сегментированной блокировкой
2. CopyOnWriteArrayList - Потокобезопасный ArrayList
3. CopyOnWriteArraySet - Потокобезопасный HashSet на основе CopyOnWriteArrayList
4. ConcurrentLinkedQueue - Потокобезопасная очередь (FIFO) без блокировок
5. BlockingQueue - Потокобезопасные очереди с блокирующими операциями

## Какие_алгоритмы_обхода_деревьев_бывают_и_почему_они_разные

В Java существует несколько алгоритмов обхода деревьев, каждый из которых подходит для определенных задач и имеет свои 
преимущества и недостатки. Рассмотрим наиболее распространенные из них.
1. Прямой обход (pre-order traversal) - при этом обходе сначала посещается корень дерева, затем левое поддерево, затем 
   правое поддерево. Этот алгоритм используют для копирования дерева, сохранения его структуры и для вычисления выражений в 
   польской записи.
2. Обратный обход (post-order traversal) - при данном обходе сначала посещаются листья, затем правое поддерево, затем левое 
   поддерево и в конце корень дерева. Этот алгоритм используется для вычисления выражений в обратной польской записи, а 
   также при удалении узлов дерева.
3. Симметричный обход (in-order traversal) - при данном обходе сначала посещается левое поддерево, затем корень дерева, 
   затем правое поддерево. Этот алгоритм используется для получения элементов дерева в отсортированном порядке.

------------------------------------------------------------------------------------------------------------------------------------

## ThreadLocal переменные




## Какие_средства_для_работы_с_многопоточностью_вы_знаете

Некоторые из этих средств:
- Класс Thread - предоставляет самый базовый способ создания и управления потоками в Java.
- Интерфейс Runnable - позволяет определить задачу, которую может выполнить поток.
- Класс Executor - предоставляет удобный способ управления группой потоков
- Классы Lock и Condition - предоставляют механизмы блокировки и синхронизации доступа к общим ресурсам.
- Классы Semaphore и CyclicBarrier - предоставляют дополнительные средства для управления поведением параллельного кода.
- Классы AtomicBoolean, AtomicInteger и AtomicReference- предоставляют безопасные атомарные операции над примитивными 
  типами данных и объектами.
- Классы CountDownLatch и Exchanger - предоставляют дополнительные возможности для синхронизации потоков.

## Расскажите_о_модели_памяти_Java

Модель памяти Java (Java Memory Model, JMM) описывает поведение потоков в среде исполнения Java.
Модель памяти включает в себя захват\освобождение монитора, чтение\запись volatile переменной, запуск нового потока а также
взаимодействия между действиями -happens-before - абстракции обозначающей, что если операция X связана отношением 
happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, 
сделанные другим потоком, до операции X


## Существует_несколько_основных_правил_для_отношения_happens_before

Существует несколько основных правил для отношения happens-before:
1. В рамках одного потока любая операция happens-before любой операцией, следующей за ней в исходном коде;
2. Освобождение монитора (unlock) happens-before захват того же монитора (lock);
3. Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе;
4. Запись volatile поля happens-before чтение того же самого volatile поля;
5. Завершение метода run() экземпляра класса Thread happens-before выход из метода join() или возвращение false методом 
   isAlive() экземпляром того же потока;
6. Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же потока;
7. Завершение конструктора happens-before начало метода finalize() этого класса;
8. Вызов метода interrupt() на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем 
   выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted().
9. Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.
10. Освобождение/захват монитора и запись/чтение в volatile переменную связаны отношением happens-before, только если 
    операции проводятся над одним и тем же экземпляром объекта.
11. В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом
    из них не наступит отношение happens-before с другим потоком.

## К_вопросу_видимости_имеют_отношение

Видимость (visibility). Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, 
а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, 
может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и 
локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.

К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final.

## Что_такое_потокобезопасность

Потокобезопасность – свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими 
потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже 
если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.

## В_чём_разница_между_конкуренцией_и_параллелизмом

Конкуренция — это способ одновременного решения множества задач.
Признаки:
* Наличие нескольких потоков управления (например, Thread в Java, корутина в Kotlin), если поток управления один, то 
  конкурентного выполнения быть не может
* Недетерминированный результат выполнения. Результат зависит от случайных событий, реализации и того, как была проведена 
  синхронизация. Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированным

Параллелизм — это способ выполнения разных частей одной задачи.
Признаки:
* Необязательно имеет несколько потоков управления
* Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, 
  не изменится, если умножать его по частям параллельно.

## Что_такое_кооперативная_многозадачность

Кооперативная многозадачность - это способ деления процессорного времени между потоками, при котором каждый поток обязан 
отдавать управление следующему добровольно.

Преимущества такого подхода - простота реализации, меньшие накладные расходы на переключение контекста.
Недостатки - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда 
не получат управление.

## Что_такое_ordering

ordering механизм, который определяет, когда один поток может увидеть out-of-order (неверный) порядок исполнения инструкций 
другого потока. CPU для повышения производительности может переупорядочивать процессорные инструкции и выполнять их в 
произвольном порядке до тех пор пока для потока внутри не будет видно никаких отличий. Гарантия, предоставляемая этим 
механизмом, называется as-if-serial semantics.

## Что_такое_sequential_consistency

sequential consistency - то же что и as-if-serial semantics, гарантия того, что в рамках одного потока побочные 
эффекты от всех операций будут такие, как будто все операции выполняются последовательно.

## Что_такое_visibility

visibility определяет, когда действия в одном потоке становятся видны из другого потока.

## Что_такое_happens_before

Happens-before - это концепция в Java Memory Model, которая определяет отношения порядка между операциями чтения и 
записи в многопоточном приложении. Happens-before гарантирует, что если операция A happens-before операции B, то любое 
изменение значения, выполненное в операции A, будет видно операции B.

Например, если один поток записывает значение в переменную, а затем другой поток прочитывает это значение, выражение 
"запись happens-before чтение" гарантирует, что второй поток увидит актуальное значение, записанное первым потоком.

Ключевое слово volatile используется для обозначения переменных, которые могут быть доступны нескольким потокам 
одновременно. Особенностью использования volatile является то, что он обеспечивает не только видимость значений в 
разных потоках, но также гарантирует обновление значений переменных для всех потоков.

Кроме того, ключевое слово volatile может использоваться для предотвращения переупорядочивания операций компилятором или 
процессором. Без использования volatile, компилятор и процессор могут переупорядочивать операции чтения и записи 
переменной в целях оптимизации кода. Но с использованием volatile, все операции чтения и записи выполняются в том порядке,
в котором они написаны в коде программы.

## Что_такое_atomicity

atomicity — атомарность операций. Атомарная операция выглядит единой и неделимой командой процессора, 
которая может быть или уже выполненной или ещё невыполненной.

## Что_такое_mutual_exclusion

mutual exclusion (взаимоисключающая блокировка, семафор с одним состоянием) - механизм, гарантирующий потоку 
исключительный доступ к ресурсу. Используется для предотвращения одновременного доступа к общему ресурсу. 
В каждый момент времени таким ресурсом может владеть только один поток. Простейший пример: synchronized(obj) { … }.

## Что_такое_safe_publication

safe publication? - показ объектов другим потокам из текущего, не нарушая ограничений visibility. 
Способы такой публикации в Java:
1. static{} инициализатор;
2. volatile переменные;
3. atomic переменные;
4. сохранение в разделяемой переменной, корректно защищенной с использованием synchronized(), синхронизаторов 
   или других конструкций, создающих read/write memory barrier;
5. final переменные в разделяемом объекте, который был корректно проинициализирован.

## Чем_отличается_процесс_от_потока

Процесс - это программа во время выполнения. Он является экземпляром программы, которая запускается на компьютере. 
Каждый процесс имеет свое состояние, которое включает данные, код и другие системные ресурсы, используемые программой.

Поток - это легковесный подпроцесс, который работает внутри процесса. Потоки выполняются параллельно, как будто они 
являются отдельными программами, но все еще могут обмениваться данными и доступом к ресурсам процесса. Каждый поток 
имеет свой стек вызовов и может выполнять некоторую часть главной программы.

## Что_такое_зелёные_потоки_и_есть_ли_они_в_Java

Зелёные (легковесные) потоки(green threads) - потоки эмулируемые виртуальной машиной или средой исполнения. 
Создание зелёного потока не подразумевает под собой создание реального потока ОС.

## Каким_образом_можно_создать_поток

1. Создать потомка класса Thread и переопределить его метод run();
2. Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. 
   Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, 
   когда завершится его метод run().
3. Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, передав ему в качестве параметра 
   экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается 
   логика выполнения).

## Каким_образом_можно_остановить_поток

1. Вызов метода interrupt() на экземпляре класса Thread - это устанавливает у потока флаг прерывания, который можно 
   проверять в коде потока с помощью метода isInterrupted(). Поток может продолжать выполнение, если он не вызывал 
   блокирующие операции (например, методы wait(), sleep() или join()) или не проверял состояние флага прерывания.
2. Использование флагов volatile или AtomicBoolean для управления циклом выполнения потока. Метод run() должен проверять 
   значение флага и завершать свое выполнение, если он установлен.
3. Использование метода stop() для принудительной остановки потока. Однако этот метод не рекомендуется к использованию, 
   так как он может оставить системные ресурсы в непредсказуемом состоянии.
4. Использование метода System.exit() для завершения всей программы, которая содержит потоки.
5. Использование метода Thread.interrupt(), захваченного блокировкой, которая вызывает InterruptedException. Это позволяет
   обработать исключение и корректно завершить выполнение потока.

## Чем_различаются_Thread_и_Runnable

Класс Thread - это класс, который предоставляет базовые функциональные возможности для работы с потоками. При создании 
экземпляра этого класса, он наследует все методы и свойства объекта Thread, такие как start(), run() и другие. Создание 
потока через наследование от класса Thread позволяет проще управлять жизненным циклом потока и его состоянием.

Интерфейс Runnable - это интерфейс, который определяет только один метод run(). Для использования этого интерфейса 
необходимо создать новый объект, реализующий данный интерфейс и передать его в качестве параметра конструктору класса 
Thread. Использование интерфейса Runnable позволяет более гибко организовать код при работе с множеством потоков и 
упрощает процесс наследования и разделения кода между несколькими потоками.

## В_чём_заключается_разница_между_методами_start_и_run

start - новый поток создает и запускает
run - запускает существующий поток

## Что_такое_монитор_в_Java

Монитор, мьютекс (mutex) – это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум 
один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для 
обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, 
захватить его и только потом начать использовать ресурс.

В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он 
так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он
вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. Если нет – поток останавливается и ждет,
пока монитор будет отпущен.

## Какие_существуют_способы_синхронизации_в_Java

Синхронизация - это процесс, который позволяет выполнять потоки параллельно.
Способы синхронизации:
1. Системная синхронизация с использованием wait()/notify(). Поток, который ждет выполнения каких-либо условий, вызывает у этого 
   объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать 
   на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на 
   объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через 
   synchronized-блок, потому как методы wait()/notify() не синхронизированы!
2. Системная синхронизация с использованием join(). Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку 
   остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.
3. Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного 
   взаимодействия. Примеры таких классов - Lock, Semaphore и пр.. Концепция данного подхода заключается в использовании 
   атомарных операций и переменных.

## В_каких_состояниях_может_находиться_поток

Потоки могут находиться в одном из следующих состояний:
1. Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). 
   В этом состоянии поток не считается живым.
2. Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). Поток может перейти 
   в это состояние также из состояния Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.
3. Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его 
   как работающий в данный момент.
4. Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:
   - Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести 
     поток из состояния Ожидания в состояние Работоспособный.
   - Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
   - Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого 
     объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
   - Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое 
     состояние, даже если для него вызван метод start().

## Как_работают_методы_wait_и_notify_notifyAll

1. wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();
2. notify(): продолжает работу потока, у которого ранее был вызван метод wait();
3. notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().

## Почему_методы_wait_и_notify_вызываются_только_в_синхронизированном_блоке



## Чем_отличается_работа_метода_wait_с_параметром_и_без_параметра



## Чем_отличаются_методы_Thread_sleep_и_Thread_yield

Метод Thread.sleep() заставляет текущий поток "уснуть" на указанное количество миллисекунд. Во время этого состояния 
поток не будет выполняться.

Метод Thread.yield() сообщает планировщику потоков, что поток готов освободить процессор и переключиться на другой поток 
с более высоким приоритетом или на тот же самый поток. Однако, планировщик может проигнорировать этот вызов, если другие 
потоки не готовы к выполнению.

## Как_работает_метод_Thread_join

Метод Thread.join() блокирует текущий поток до тех пор, пока указанный поток не завершится.

Когда вызывается метод join() для потока A ссылающегося на поток B, то поток A будет заблокирован и ожидать завершения 
потока B. Как только поток B завершится, поток A продолжит выполнение со следующей инструкции после вызова join().

Например, если в главном потоке созданы и запущены два дочерних потока (назовем их поток А и поток В), и главный поток 
вызывает метод join() для потока А и потока B, то главный поток будет ждать, пока эти два потока не завершат свою работу.
Затем главный поток продолжит свое выполнение.

## Что_такое_deadlock

Deadlock (зависание) - это состояние программы, в котором два или более потока не могут продвинуться дальше из-за 
блокировки необходимых ресурсов. То есть каждый поток ожидает освобождения ресурса, который занят другим потоком, и ни 
один из потоков не может продолжить свою работу.

В Java есть два типа deadlock-а:
1. Resource deadlock (deadlock ресурсов) - происходит, когда два или более потока ждут доступа к ресурсам, которые находятся 
   в другом потоке и которые они сами удерживают. Например, если поток A заблокировал ресурс 1 и пытается получить доступ к 
   ресурсу 2, который заблокировал поток B, в то время как поток B пытается получить доступ к ресурсу 1, заблокированному 
   потоком A, то оба потока будут заблокированы, ожидая освобождения ресурсов.
2. Thread deadlock (deadlock потоков) - происходит, когда два или более потока ждут друг друга, чтобы завершить выполнение 
   определенных действий. Например, поток A заблокировал ресурс 1 и ждет, когда поток B освободит ресурс 2, в то время как 
   поток B заблокировал ресурс 2 и ждет, когда поток A освободит ресурс 1.

Причины deadlock могут быть различными, например:
1. Взаимная блокировка (deadlock), когда два или более потоков ждут освобождения других ресурсов, которые заняты другими
   потоками.
2. Неправильная синхронизация приложения: когда потоки работают с общими данными, но не правильно синхронизируют доступ к 
   ним, что может привести к deadlock.
3. Неправильное управление потоками: когда потоки не корректно запускаются, останавливаются или завершаются, что также 
   может привести к deadlock.

## Что_такое_livelock

livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность 
при попытке получения каких-либо ресурсов.

## Для_чего_используется_ключевое_слово_volatile_synchronized_transient_native

volatile - это ключевое слово в Java, которое применяется к переменным для обеспечения видимости изменений в 
многопоточной среде. Переменная, помеченная как volatile, гарантирует, что ее значение всегда будет считываться из памяти, 
а не из локального кэша процессора, что помогает избежать race condition.

synchronized - это ключевое слово, используемое в Java для создания блока кода, который может быть выполнен только одним 
потоком в данный момент времени. Это позволяет предотвратить race condition, когда несколько потоков пытаются обратиться 
к одному и тому же ресурсу (например, переменной) одновременно.

transient - это ключевое слово, которое используется в Java для указания, что поле класса не должно быть сериализовано 
при сохранении объекта класса на диск или передаче по сети. Например, если в классе есть поля, содержащие конфиденциальную
информацию, то их можно пометить как transient, чтобы они не были сохранены в открытом виде.

native - это ключевое слово в Java, которое используется для указания, что метод не реализован в Java, а написан на другом
языке программирования, таком как C или C++. Такой метод называется "нативным". Код нативного метода выполняется за 
пределами виртуальной машины Java и может использовать функции, недоступные на Java.

## В_чём_различия_между_volatile_и_Atomic_переменными

volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является 
ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, 
синхронизированы не будут!

## Что_значит_приоритет_потока

Приоритеты потоков - это числовые значения, которые указывают на относительную важность потока для планировщика потоков.
В Java есть 10 уровней приоритетов, пронумерованных от 1 до 10, где 1 - это самый низкий уровень приоритета, 
а 10 - самый высокий.

По умолчанию все потоки имеют средний приоритет (5). Однако при необходимости можно изменить приоритет потока с помощью
метода setPriority(int priority).
Приоритеты потоков используются планировщиком потоков для определения порядка выполнения потоков. Однако не следует 
полагаться на приоритеты потоков для точного управления временем выполнения потоков, так как они зависят от реализации
планировщика и могут быть различны на разных платформах.
При работе с приоритетами потоков необходимо учитывать, что потоки с более высоким приоритетом могут захватывать 
процессорное время чаще, чем потоки с более низким приоритетом, что может приводить к исключению из сети потоков с 
более низким приоритетом. Это может привести к deadlock'ам. Поэтому, при использовании приоритетов потоков, необходимо 
быть осторожным и учитывать возможные последствия.

## Что_такое_потоки_демоны

Поток-демон в Java - это специальный тип потока, который работает в фоновом режиме и не мешает завершению программы.
Если все оставшиеся потоки в программе являются демонами, то JVM автоматически завершит программу и выйдет.

Установка потока как демона происходит с помощью метода setDaemon(boolean on) класса Thread. Поток должен быть установлен
как демон до его запуска, иначе будет вызвано исключение IllegalThreadStateException.

Демоны используются для выполнения задач, которые могут быть прерваны в любой момент без последствий для целостности 
данных или состояния программы. Они могут использоваться для регулярного выполнения определенных задач (например, 
очистка временных файлов), отправки отчетов на серверы мониторинга или обновления кэшей.

Одним из примеров использования потоков-демонов может быть реализация сервера, который выполняет работу постоянно, 
но должен завершиться, когда все пользовательские потоки завершены. В этом случае основной поток приложения может 
быть установлен как недемонический, а все потоки-обработчики запросов должны быть установлены как демоны. Как только 
все пользовательские потоки завершены, JVM автоматически завершит приложение, завершив все демонические потоки.

## Чем_отличаются_два_интерфейса_Runnable_и_Callable



## Что_такое_FutureTask



## В_чем_заключаются_различия_между_CyclicBarrier_и_CountDownLatch



## Что_такое_race_condition

Race condition - это состояние в многопоточной среде, когда два или более потока пытаются изменить одно и то же общее 
состояние программы одновременно. Конечный результат зависит от того, какие потоки будут выполняться быстрее и в каком 
порядке. Такая ситуация может привести к непредсказуемому поведению программы, ошибкам и неожиданным результатам. Для 
избежания race condition необходимо использовать механизмы синхронизации, такие как блокировки, мьютексы и семафоры, 
которые гарантируют правильный порядок выполнения операций с общими данными.

Например, предположим, что имеется общий ресурс - переменная count, которая увеличивается на единицу при каждом обращении.
Если два потока одновременно выполняют инструкцию count++, то может произойти следующее:
- Первый поток читает текущее значение переменной count (например, 2).
- Второй поток также читает текущее значение переменной count (также 2).
- Первый поток увеличивает значение переменной count на единицу (3).
- Второй поток также увеличивает значение переменной count на единицу (3).

После этого значение переменной count будет равно 3, хотя должно было быть равно 4. Это происходит из-за того, что оба 
потока считали старое значение переменной до того, как она была обновлена первым потоком.

Чтобы избежать race conditions в многопоточных приложениях, можно использовать synchronized блоки или методы для 
предотвращения одновременного доступа к общим ресурсам. Также можно использовать другие механизмы синхронизации, 
такие как Lock или Semaphore, чтобы гарантировать правильный порядок выполнения операций в многопоточной среде.

## Что_такое_и_для_чего_нужны_Atomic_types

Atomic types - это классы в Java, которые обеспечивают атомарность операций чтения и записи для определенных типов данных.
Они предоставляют методы для выполнения операций над значениями типа, таких как целочисленные идентификаторы или счетчики,
без необходимости использовать блокировки или другие механизмы синхронизации.

В многопоточной среде, когда несколько потоков одновременно пытаются читать или записывать значение переменной, возникает
проблема "гонки данных" (data race), что может привести к непредсказуемому поведению программы. Использование атомарных
типов предотвращает эту проблему, поскольку все операции чтения и записи осуществляются атомарно, то есть состояние
переменной всегда находится в конкретном корректном состоянии, и каждый поток работает с актуальной версией переменной.

Например, при использовании обычного целочисленного типа int, если два потока одновременно пытаются увеличить его значение,
результат может быть непредсказуемым из-за гонки данных. Атомарный счетчик AtomicInteger решает эту проблему, предоставляя
методы для выполнения операции инкремента, которые выполняются атомарно.

В целом, использование атомарных типов позволяет улучшить производительность и надежность программы в многопоточной среде.

## Чем_отличается_ForkJoinPool_от_ScheduledThreadPoolExecutor_и_ThreadPoolExcutor

ForkJoinPool, ScheduledThreadPoolExecutor и ThreadPoolExecutor - это все реализации Executor Framework в Java, которые
используются для управления потоками и выполнения асинхронных задач. Каждый из них предназначен для определенного типа
задач и имеет свои особенности.

1. ForkJoinPool является специальной реализацией Executor Framework, который поддерживает параллельную обработку больших
   задач, которые могут быть разделены на более мелкие подзадачи. Он используется в основном для выполнения вычислительных
   и CPU-интенсивных задач. ForkJoinPool использует алгоритм "разделяй и властвуй", который позволяет распределять задачи
   на несколько потоков, чтобы достичь максимальной производительности. Это позволяет использовать все ядра процессора и
   эффективно использовать ресурсы системы.
2. ScheduledThreadPoolExecutor является реализацией Executor Framework, которая используется для выполнения периодических
   или отложенных задач в фиксированных временных интервалах. Он может использоваться для запуска задач по расписанию или
   с задержкой во времени, таких как отправка email-уведомлений или резервное копирование данных.
   ScheduledThreadPoolExecutor предоставляет возможность установить начальную задержку и интервал между выполнениями задач.
3. ThreadPoolExecutor является реализацией Executor Framework, которая используется для запуска нескольких асинхронных задач
   в одном или нескольких потоках. Он может использоваться для выполнения различных задач, таких как чтение и запись данных
   в файлы, выполнение сетевых операций и обработка запросов от клиентов. ThreadPoolExecutor предоставляет настраиваемое
   количество потоков и очередь задач, чтобы обеспечить максимальную производительность приложения.


## Что_такое_мьютекс

Мьютекс (mutex) - это механизм синхронизации, который используется для управления доступом к общим ресурсам в 
многопоточных приложениях. Мьютекс может быть использован для предотвращения состояний гонки и обеспечения безопасного 
доступа к общим ресурсам.

Мьютекс позволяет блокировать доступ к общему ресурсу одним потоком исполнения, чтобы другие потоки не могли изменять 
общий ресурс в то время, когда этим занимается первый поток. Когда первый поток завершает работу с общим ресурсом, он 
освобождает мьютекс, и другой поток может получить доступ к этому ресурсу.

## Существует_ли_способ_решения_проблемы_race_condition



## Что_происходит_когда_в_потоке_выбрасывается_исключение



## В_чем_разница_между_interrupted_и_isInterrupted

Метод interrupt() в Java используется для прерывания выполнения потока.
Когда вызывается метод interrupt() на потоке, этот поток получает сигнал о том, что он должен прекратить свое выполнение. 
Это не означает, что выполнение потока будет немедленно остановлено или что поток будет уничтожен - это зависит от способа
реализации самого потока.
При вызове метода interrupt() в условиях блокировки (например, когда поток ожидает на мониторе объекта с помощью метода 
wait()), выбрасывается исключение InterruptedException. Это позволяет потоку обнаружить, что он был прерван, и выполнить
какие-то действия перед прекращением работы

Методы isInterrupted() и interrupted() в Java используются для проверки статуса прерывания потока, но они имеют 
различное поведение.
Метод isInterrupted() является нестатическим методом класса Thread и возвращает значение флага прерывания для данного потока. 
Если флаг прерывания установлен, метод возвращает true, иначе - false.
С другой стороны, метод interrupted() также является нестатическим методом класса Thread, но он проверяет флаг прерывания 
для текущего потока. Если флаг прерывания установлен, метод возвращает true, а затем сбрасывает флаг прерывания до 
значения false. Если же флаг прерывания не был установлен, метод возвращает false.

## Что_такое_пул_потоков

1. NEW - новый поток. Это начальное состояние потока, когда он создается, но еще не был запущен методом start().
2. RUNNABLE - поток готов к выполнению. После вызова метода start() поток переходит в это состояние и ожидает выделения 
   процессорного времени для выполнения своей задачи.
3. BLOCKED - поток заблокирован. Если поток пытается получить доступ к заблокированному ресурсу или ждет уведомления от 
   другого потока с помощью метода wait(), он переходит в состояние блокировки.
4. WAITING - поток ожидает. Если поток вызывает метод wait(), join() или park(), он переходит в состояние ожидания и 
   прекращает выполнение до тех пор, пока не будет вызван метод notify(), interrupt() или unpark() на том же самом объекте.
5. TIMED_WAITING - поток ожидает (с тайм-аутом). Если поток вызывает метод sleep(), wait(timeout) или join(timeout), он 
   переходит в состояние ожидания с тайм-аутом и прекращает выполнение на заданное количество времени.
6. TERMINATED - поток завершен. Когда метод run() завершается, поток переходит в состояние завершения. Каждый поток может 
   находиться только в одном из этих состояний в любой момент времени. Потоки могут переходить между этими состояниями в 
   зависимости от своего текущего состояния и взаимодействия с другими потоками и ресурсами.

## Объясните_жизненный_цикл_потока



## Методы_Executors_для_создания_пулов



## Что_будет_если_очередь_пула_потоков_уже_заполнена_но_подаётся_новая_задача



## В_чём_заключается_различие_между_методами_submit_и_execute_у_пула_потоков



## Как_получить_дамп_потока



## Что_такое_ThreadLocal_переменная

ThreadLocal - это класс в Java, который предоставляет способ создания переменных, которые могут быть доступны только в 
контексте одного потока. Эти переменные хранятся внутри объекта ThreadLocal и не видны другим потокам.
ThreadLocal может быть полезен, когда необходимо создать переменную, которая должна быть локальной для каждого потока, 
например, когда нужно сохранять состояние при обработке запросов от разных клиентов в многопоточном сервере.
Основное преимущество ThreadLocal заключается в том, что он позволяет безопасно использовать изменяемые объекты в 
многопоточной среде, так как каждый поток имеет свой экземпляр объекта ThreadLocal и никакие другие потоки не могут 
получить доступ к этому экземпляру.
Также ThreadLocal можно использовать для улучшения производительности, поскольку это может избежать лишних блокировок 
при доступе к ресурсам, которые могут быть безопасно использованы локально внутри каждого потока.

`public class UserContext {
   private static final ThreadLocal<User> userThreadLocal = new ThreadLocal<>();

    public static void setUser(User user) {
        userThreadLocal.set(user);
    }

    public static User getUser() {
        return userThreadLocal.get();
    }
}`

## Назовите_различия_между_synchronized_и_ReentrantLock



## Что_такое_ReadWriteLock



## Что_такое_фреймворк_Fork_Join



## Что_такое_Semaphore



## Чем_полезны_неизменяемые_объекты



## Перечислите_принципы_которым_вы_следуете_в_многопоточном_программировании



## Что_такое_Happens_before_Каковы_особенности_использования_ключевого_слова_volatile



## Что_такое_deadlock_Какие_типы_есть_Нарисуйте_схематически_как_это_может_произойти



## Что_такое_optimistic_и_pessimistic_locking

Optimistic locking и pessimistic locking - это два подхода к управлению доступом к общим ресурсам в многопоточных 
приложениях. Они используются для предотвращения race condition и конфликтов при одновременном доступе к данным.

Pessimistic locking - это подход, при котором блокировка ресурса устанавливается на всё время, пока этот ресурс 
используется. То есть, если какой-либо поток получает доступ к ресурсу, то он блокирует его на все оставшееся время 
выполнения операции с этим ресурсом, пока не завершит свою работу. Это гарантирует, что другие потоки не смогут изменять 
данные во время выполнения операции. Недостатком является то, что этот подход может привести к задержкам и ухудшению 
производительности из-за большого количества блокировок.

Optimistic locking, наоборот, не блокирует ресурс, пока он доступен для работы другим потокам. Вместо этого каждый поток 
получает версию данных в начале операции. После того, как операция выполнена, данные сохраняются только в том случае, 
если версия данных не была изменена другим потоком за время выполнения операции. Если же версия данных была изменена 
другим потоком, то операция отменяется и повторяется с новой версией данных. Этот подход уменьшает количество блокировок, 
что улучшает производительность, но может привести к конфликтам, если несколько потоков попытаются изменять одни и те же 
данные одновременно.

## Что_означает_CAP_теорема

CAP-теорема - это теорема, которая утверждает, что в распределенных компьютерных системах невозможно одновременно 
обеспечить следующие три свойства (CAP): согласованность данных (Consistency), доступность системы (Availability) 
и устойчивость к разделению сети (Partition tolerance).

Согласованность данных (Consistency) - гарантирует, что при чтении или записи данных все узлы системы будут иметь 
одинаковую информацию. Для поддержания этого свойства система должна быть сконфигурирована таким образом, чтобы любая
операция чтения или записи была выполнена только после полной передачи изменений от других узлов. Доступность системы
(Availability) - гарантирует, что каждый запрос к системе будет получать ответ, даже если какой-то узел отказал или 
пропал из сети. Для обеспечения доступности системы, она должна быть спроектирована таким образом, чтобы запросы 
могли быть отправлены и обработаны любым доступным узлом. Устойчивость к разделению сети 
(Partition tolerance) - гарантирует, что система продолжит работу, даже если часть ее узлов станет недоступной или
изолированной от остальной части сети. Это достигается путем дублирования данных на разных узлах системы, чтобы каждый 
узел мог продолжать работу независимо от остальных.

По теореме CAP, распределенные системы могут обеспечить только два из трех свойств: согласованность и доступность (CA),
согласованность и устойчивость к разделению сети (CP) или доступность и устойчивость к разделению сети (AP). Требования 
к конкретной системе могут определяться необходимостью приложения и его способностью работать в условиях потенциальных 
сбоев, что может привести к выбору одного из двух возможных режимов работы, CA или AP.

## Что_такое_n_1_проблема

Проблема декартового произведения (или cartesian product проблема) возникает в SQL запросах, когда неявно выполняется 
соединение всех строк из двух или более таблиц без указания условий объединения. В результате получается огромное 
количество строк, что может привести к серьезным проблемам производительности и потреблению ресурсов.

Например, предположим, что у нас есть две таблицы: "Клиенты" и "Заказы", которые связаны между собой по полю "id_клиента".
Если мы хотим получить список клиентов и количество заказов для каждого клиента, то мы можем написать запрос, который 
будет выглядеть примерно так:

SELECT Клиенты.*, COUNT(Заказы.id_заказа) AS 'Количество заказов' FROM Клиенты, 
Заказы WHERE Клиенты.id_клиента = Заказы.id_клиента GROUP BY Клиенты.id_клиента

Однако, в данном случае мы неявно используем операцию декартова произведения между таблицами "Клиенты" и "Заказы", 
так как не указываем явно условие соединения. Это значит, что для каждой строки в таблице "Клиенты" будет выполнено 
соединение со всеми строками в таблице "Заказы", что может привести к огромному количеству строк в результате запроса 
и серьезным проблемам производительности.

Чтобы избежать проблемы декартова произведения, необходимо явно указывать условия соединения между таблицами. Для этого
можно использовать операторы JOIN или INNER JOIN, которые позволяют объединить строки из двух таблиц на основании 
совпадения значений в определенных столбцах.
