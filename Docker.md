<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />        
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />        
  </a>&nbsp;&nbsp;

Если вам интересно мое резюме: https://github.com/DEBAGanov

# Docker
- [Docker](#docker)
  - [Что такое Docker Hub?](#Что_такое_Docker_Hub)
  - [В чём разница между политиками перезапуска Docker «нет», «при сбое» и «всегда»?](#В_чём_разница_между_политиками_перезапуска_Docker_нет_при_сбое_и_всегда)
  - [Можете ли вы рассказать что-нибудь о пространстве имен Docker?](#Можете_ли_вы_рассказать_что_нибудь_о_пространстве_имен_Docker)
  - [Знаете ли вы о балансировке нагрузки между контейнерами и хостами? Как это работает?](#Знаете_ли_вы_о_балансировке_нагрузки_между_контейнерами_и_хостами_Как_это_работает)
  - [Что такое метки объектов Docker?](#Что_такое_метки_объектов_Docker)
  - [Какие факторы определяют максимальное количество контейнеров, которые можно запустить на хосте для приложения с микросервисами, если у вас есть сервер с 16 ГБ оперативной памяти и четырёхъядерным процессором?](#Какие_факторы_определяют_максимальное_количество_контейнеров_которые_можно_запустить_на_хосте_для_приложения_с_микросервисами)
  - [Кратко опишите жизненный цикл контейнера Docker?](#Кратко_опишите_жизненный_цикл_контейнера_Docker)
  - [Как создать контейнер Docker?](#Как_создать_контейнер_Docker)
  - [Является ли хорошей практикой запуск приложений с отслеживанием состояния в Docker?](#Является_ли_хорошей_практикой_запуск_приложений_с_отслеживанием_состояния_в_Docker)
  - [Могу ли я использовать JSON вместо YAML для моего файла Docker Compose?](#Могу_ли_я_использовать_JSON_вместо_YAML_для_моего_файла_Docker_Compose)
  - [Какой способ удаления контейнера предпочтительнее: использовать команду «docker stop», за которой следует команда «docker rm», или просто использовать команду «docker rm» самостоятельно?](#Какой_способ_удаления_контейнера_предпочтительнее_использовать_команду_docker_stop_за_которой_следует_команда_docker_rm)
  - [В чём заключаются основные различия между ведением журнала на уровне демона и ведением журнала на уровне контейнера в Docker?](#В_чём_заключаются_основные_различия_между_ведением_журнала_на_уровне_демона_и_ведением_журнала_на_уровне_контейнера_в_Docker)
  - [Как обновить контейнер Docker без потери данных?](#Как_обновить_контейнер_Docker_без_потери_данных)
  - [Можно ли удалить Приостановленный контейнер из Docker?](#Можно_ли_удалить_Приостановленный_контейнер_из_Docker)
  - [Можете ли вы определить разницу между Docker Image и Layer?](#Можете_ли_вы_определить_разницу_между_Docker_Image_и_Layer)
  - [Как Вы будете отслеживать работу Docker в рабочей среде?](#Как_Вы_будете_отслеживать_работу_Docker_в_рабочей_среде)
  - [Как вы обеспечите запуск контейнера 1 до запуска контейнера 2 при использовании docker-compose?](#Как_вы_обеспечите_запуск_контейнера_1_до_запуска_контейнера_2_при_использовании_docker_compose)
  - [Как запустить, остановить и уничтожить контейнер?](#Как_запустить_остановить_и_уничтожить_контейнер)
  - [Как Docker справляется с изоляцией и безопасностью контейнеров?](#Как_Docker_справляется_с_изоляцией_и_безопасностью_контейнеров)
  - [При каких обстоятельствах вы потеряете данные, хранящиеся в контейнере?](#При_каких_обстоятельствах_вы_потеряете_данные_хранящиеся_в_контейнере)
  - [Что такое Docker Registry?](#Что_такое_реестр_образов_Docker)
  - [Укажите несколько важных команд Docker?](#Укажите_несколько_важных_команд_Docker)
  - [Какова цель Docker Secrets?](#Какова_цель_Docker_Secrets)
  - [Как проверить версии клиента и сервера Docker?](#Как_проверить_версии_клиента_и_сервера_Docker)
  - [Какую команду можно использовать для экспорта образа Docker в виде архива?](#Какую_команду_можно_использовать_для_экспорта_образа_Docker_в_виде_архива)
  - [Можете ли вы объяснить разницу между образом Docker и слоем?](#Можете_ли_вы_объяснить_разницу_между_образом_Docker_и_слоем)
  - [Для чего используется Docker System Prune? Что он делает?](#Для_чего_используется_Docker_System_Prune_Что_он_делает)
  - [Может ли контейнер перезапуститься сам по себе?](#Может_ли_контейнер_перезапуститься_сам_по_себе)
  - [Как узнать количество запущенных, приостановленных и остановленных контейнеров?](#Как_узнать_количество_запущенных_приостановленных_и_остановленных_контейнеров)
  - [Как вы отлаживаете проблемы в контейнере Docker?](#Как_вы_отлаживаете_проблемы_в_контейнере_Docker)
  - [Назовите и объясните состояние контейнера Docker?](#Назовите_и_объясните_состояние_контейнера_Docker)
  - [Как просмотреть метаданные образа Docker?](#Как_просмотреть_метаданные_образа_Docker)
  - [Как создать многоэтапную сборку в Docker?](#Как_создать_многоэтапную_сборку_в_Docker)
  - [Как вы масштабируете контейнеры Docker по горизонтали?](#Как_вы_масштабируете_контейнеры_Docker_по_горизонтали)
  - [Как ограничить использование процессора и памяти в контейнере Docker?](#Как_ограничить_использование_процессора_и_памяти_в_контейнере_Docker)
  - [Как вы обмениваетесь данными между контейнерами в Docker?](#Как_вы_обмениваетесь_данными_между_контейнерами_в_Docker)
  - [Что вы можете сказать о Docker Compose?](#Что_вы_можете_сказать_о_Docker_Compose)
  - [В чём разница между командами up, run и start в Docker Compose?](#В_чём_разница_между_командами_up_run_и_start_в_Docker_Compose)
  - [В чем основное различие между Swarm и Kubernetes?](#В_чем_основное_различие_между_Swarm_и_Kubernetes)
  - [Каковы некоторые основные команды Docker?](#Каковы_некоторые_основные_команды_Docker)
  - [В чем разница между Docker run и Docker create?](#В_чем_разница_между_Docker_run_и_Docker_create)
  - [Каковы некоторые расширенные команды Docker?](#Каковы_некоторые_расширенные_команды_Docker)
  - [Что такое Docker Push?](#Что_такое_Docker_Push)
  - [Можете ли вы отличить CMD от ENTRYPOINT?](#Можете_ли_вы_отличить_CMD_от_ENTRYPOINT)
  - [Какая команда Docker выводит список состояния всех контейнеров?](#Какая_команда_Docker_выводит_список_состояния_всех_контейнеров)
  - [Что делает команда FROM](#Что_делает_команда_FROM)
  - [Что делает команда LABEL](#Что_делает_команда_LABEL)
  - [Что делает команда EXPOSE](#Что_делает_команда_EXPOSE)
  - [Каковы плюсы и минусы Docker?](#Каковы_плюсы_и_минусы_Docker)
  - [Назовите и объясните компоненты Docker?](#Назовите_и_объясните_компоненты_Docker)
  - [Какую команду можно выполнить для импорта предварительно экспортированного образа Docker на другой хост Docker?](#Какую_команду_можно_выполнить_для_импорта_предварительно_экспортированного_образа_Docker_на_другой_хост_Docker)
  - [Как выполнить миграцию контейнеров Docker между хостами в режиме реального времени?](#Как_выполнить_миграцию_контейнеров_Docker_между_хостами_в_режиме_реального_времени)
  - [Как обеспечить высокую доступность вашего контейнерного приложения?](#Как_обеспечить_высокую_доступность_вашего_контейнерного_приложения)
  - [Что такое Docker Swarm?](#Что_такое_Docker_Swarm)
  - [Что такое Dockerfile?](#Что_такое_Dockerfile)
  - [Перечислите наиболее часто используемые инструкции в DockerFile?](#Перечислите_наиболее_часто_используемые_инструкции_в_DockerFile)
  - [Чем Dockerfile отличается от Docker Compose?](#Чем_Dockerfile_отличается_от_Docker_Compose)
  - [Какова цель команды EXPOSE в Dockerfile?](#Какова_цель_команды_EXPOSE_в_Dockerfile)
  - [Чем инструкция ENTRYPOINT в Dockerfile отличается от инструкции RUN?](#Чем_инструкция_ENTRYPOINT_в_Dockerfile_отличается_от_инструкции_RUN)
  - [Где хранятся тома Docker?](#Где_хранятся_тома_Docker)
  - [Объясните контейнеризацию?](#Объясните_контейнеризацию)
  - [Что делает команда Docker Info?](#Что_делает_команда_Docker_Info)
  - [Что делает команда ENV](#Что_делает_команда_ENV)
  - [Что делает команда WORKDIR](#Что_делает_команда_WORKDIR)
  - [Что делает команда ARG](#Что_делает_команда_ARG)
  - [Что делает команда COPY](#Что_делает_команда_COPY)
  - [Что делает команда ADD](#Что_делает_команда_ADD)
  - [Что делает команда RUN](#Что_делает_команда_RUN)
  - [Что делает команда ENTRYPOINT](#Что_делает_команда_ENTRYPOINT)
  - [Что делает команда VOLUME](#Что_делает_команда_VOLUME)
  - [Что такое Docker?](#Что_такое_Docker)
  - [Как демон Docker и клиент Docker взаимодействуют друг с другом?](#Как_демон_Docker_и_клиент_Docker_взаимодействуют_друг_с_другом)
  - [В чем разница между командами COPY и ADD, используемыми в Dockerfile?](#В_чем_разница_между_командами_COPY_и_ADD_используемыми_в_Dockerfile)
  - [Каково назначение параметра volume в команде docker run?](#Каково_назначение_параметра_volume_в_команде_docker_run)
  - [Что такое CMD и ENTRYPOINT в Dockerfile?](#Что_такое_CMD_и_ENTRYPOINT_в_Dockerfile)
  - [Что означает CNM(Network model - сетевое взаимодействие) ? Каковы его компоненты?](#Что_означает_CNM_Каковы_его_компоненты)
  - [Предположим, у вас запущено 3 контейнера, и вы хотите получить доступ к одному из них. Как получить доступ к запущенному контейнеру?](#Предположим_у_вас_запущено_3_контейнера_и_вы_хотите_получить_доступ_к_одному_из_них)
  - [Расскажите мне немного о гипервизоре?](#Расскажите_мне_немного_о_гипервизоре)
  - [Для чего нужна команда «docker checkpoint»?](#Для_чего_нужна_команда_docker_checkpoint)
  - [Как Docker обрабатывает обнаружение служб в режиме Swarm?](#Как_Docker_обрабатывает_обнаружение_служб_в_режиме_Swarm)
  - [Как вы управляете сетевым подключением между контейнерами Docker и хост-машиной?](#Как_вы_управляете_сетевым_подключением_между_контейнерами_Docker_и_хост_машиной)
- 
  - [Расскажите мне что-нибудь о Docker machine?](#Расскажите_мне_что_нибудь_о_Docker_machine)
  - [В чем различие между виртуализацией и контейнеризацией?](#В_чем_различие_между_виртуализацией_и_контейнеризацией)
  - [Что делает команда CMD](#Что_делает_команда_CMD)

## Что_такое_Docker

Docker - платформа контейнеризации которая позволяет упаковывать код со всеми его зависимостями в один контейнер.
Docker container - это виртуальные машины которые могут одновременно запускаться на нескольких контейнерах.
Основные компоненты Docker:
1. Docker Image - шаблон создания контейнеров.
2. Docker container - запущенный экземпляр образа.
3. Dockerfile - текстовый файл с инструкциями для сборки образа.

Зачем Docker разработчику:
1. Изоляция зависимостей. Запуск приложения в контейнере исключает проблемы с версиями библиотек.
2. Быстрое развертывание. Контейнеры запускаются быстрее чем виртуальные машины
3. Микросервисы. Docker упрощает оркестрацию сервисов.

## Каковы_плюсы_и_минусы_Docker

Плюсы:
1. Переносимость - Контейнеры работают одинаково для любой ОС с Docker.
2. Изоляция зависимостей - каждое приложение работает в своем контейнере со своими зависимостями.
3. Нет конфликтов зависимостей.
4. Масштабируемость. Легко запускать несколько копий.
5. Интеграция с Kubernetes.
6. Готовые образы в Docker Hub.
Минусы:
1. Неполная безопасность. Контейнеры используют общее ядро хоста и уязвимости ядра влияют на все контейнеры.
2. Проблемы с хранением данных. Данные в контейнере временные.

## Назовите_и_объясните_компоненты_Docker

1. Docker Engine: Основной движок который создает и управляет контейнерами. (Запускает контейнеры на хостовой машине)
2. Docker Image: неизменяемый шаблон для создания контейнера. Создается через Dockerfile
3. Docker Container: запущенный экземпляр образа
4. Dockerfile: инструкция для сборки
FROM openjdk:17-jdk-slim
COPY target/app.jar /app
EXPOSE 8080
CMD ["java", "-jar", "/app/app.jar"]
5. Docker Compose: необходим для оркестрации нескольких сервисов. Пример файла
services:
  app:
    image: my-spring-app
    ports: [8080:8080]
  postgres:
    image: postgres:14
    volumes: [db-data:/var/lib/postgresql/data]
  volumes:
    db-data:
6. Docker Registry: репозиторий для хранения образов.
7. Docker Volume: Механизм для сохранения данных после остановки контейнера. Бывают типы: 1. Named Volume. 2. Bind Mount(маппинг папки
хоста в контейнер)

## Что_такое_реестр_образов_Docker

Docker registry - хранение образов в своем репозитории. 

## Укажите_несколько_важных_команд_Docker

1. docker system prune - очищает неиспользуемые образы
2. docker inspect <контейнер> - детальная информация о контейнере (IP, volumes, сеть)
3. docker stats - мониторинг ресурсов
4. docker save/load - экспорт\импорт образов в .tar
5. docker build -t <имя образа> - собирает образ из Dockerfile в текущий репозиторий
6. docker pull <имя образа> - скачивает образ из реестра
7. docker push <имя образа> - загружает образ в приватный\публичный репозиторий
8. docker image - показывает список локальных образов
9. docker run [опции] <имя образа> - запускает контейнер из образа.
  Опции:
   1. -d - запускает в фоне
   2. -p 8080:8080 - проброс портов
   3. -name my-container - задает имя контейнеру
   4. -v /data:/app/data - монтирует volume.
10. docker ps - список запущенных контейнеров
11. docker ps -a - показывает и остановленные контейнеры
12. docker stop/ docker start - останавливает\запускает контейнер
13. docker rm/docker rmi - удаляет контейнер\образ
14. docker logs - показывает логи контейнера
15. docker exec -it <контейнер> <команда> - запускает команду внутри работающего контейнера.
16. docker network ls - список сетей.
17. docker volume ls - список томов.

## Можете_ли_вы_рассказать_что_нибудь_о_пространстве_имен_Docker

Namespace - это механизм ядра Linux для изоляции процессов, сетей и других ресурсов. Docker использует их чтобы контейнере не влияли друг 
на друга.

## Как_проверить_версии_клиента_и_сервера_Docker

использовав команду `docker version`

## Что_такое_метки_объектов_Docker

Это пары Ключ-Значение которые добавляются к объектам (образам, контейнерам, томам).  Они помогают в автоматизации, мониторинге, 
управлении инфраструктурой. 
Метки добавляются:
1. Dockerfile - LABEL version="1.0"
2. При запуске контейнера docker run -d --label "log-level=verbose"
3. Docker-compose.yml - 
services:
  app:
    labels:
      -"com.exxample.enviroment=test"
Есть стандартные (maintainer, version) и кастомные(com.mycompany.qualiti=hight) метки.
Они применяются для фильтрации контейнеров, логировании и мониторинга, интеграции с оркестраторами.

## Какова_цель_Docker_Secrets

Секреты Docker используются в основном для безопасного хранения конфиденциальной информации, такой как пароли или ключи API в Docker Swarm.
`docker secret create db_password mysecretpassword`
Он решает проблему утечки данных которые раньше хранились в переменных окружениях или внутри контейнера в application.properties
В Kubernetes есть аналогичный механизм — Secrets.

## Какую_команду_можно_использовать_для_экспорта_образа_Docker_в_виде_архива

`docker save -o   <output_file_name>.tar    <image_name>`

## Какую_команду_можно_выполнить_для_импорта_предварительно_экспортированного_образа_Docker_на_другой_хост_Docker

`docker load -i <input_file_name>.tar`

## Можете_ли_вы_объяснить_разницу_между_образом_Docker_и_слоем

Образ докера это как снимок экземпляра приложения который в себе содержит все необходимое для запуска. (код приложения, библиотеки,
системные инструменты, переменные окружения). Они создаются на основе описания Dockerfile и состоят из слоев.
Ключевые свойства образа:
1. Неизменяемость - после создания образ нельзя изменить
2. Портативность - можно загрузить в реестр и развернуть на любом хосте 
3. Иерархичность - образы могут наследоваться от других
Слой - это изменение файловой системы, которое возникает при выполнении каждой инструкции в Dockerfile.
Каждая команда в Dockerfile создает новый слой(кроме LABEL)
Ключевые свойства слоёв:
1. Кешируемость: Docker кеширует слои, что ускоряет повторные сборки.
2. Иммутабельность: Слои нельзя изменить после создания.
3. Эффективность: При изменении только одного слоя (например, кода приложения) пересобираются только последующие.

## Для_чего_используется_Docker_System_Prune_Что_он_делает

Эта команда очищает неиспользуемые ресурсы Docker, чтобы освободить место на диске и поддерживать систему в порядке.
Команда: `docker system prune`
Она удаляет:
1. Остановленные контейнеры (например, те, что завершились с exit 0 или были остановлены вручную).
2. "Висячие" (dangling) образы — слои, не связанные ни с одним актуальным образом (например, промежуточные образы после пересборки).
3. Неиспользуемые сети (созданные Docker по умолчанию и не привязанные к контейнерам).
4. Кеш сборки (build cache) — если не указан флаг --volumes, данные томов не трогаются.

Что НЕ удаляет docker system prune?
1. Запущенные контейнеры (активные сервисы останутся нетронутыми).
2. Используемые образы (например, образ openjdk:17, от которого зависят ваши приложения).
3. Привязанные тома (если не указан --volumes).

## В_чём_разница_между_политиками_перезапуска_Docker_нет_при_сбое_и_всегда

Эти политики перезапуска обеспечат гибкость в управлении поведением контейнера в соответствии с конкретными требованиями.
1. Политика нет - Автоматический перезапуск не будет выполнен. Контейнер не будет автоматически перезапускаться в любом случае, 
независимо от состояния выхода.
2. При отказе - Контейнер будет перезапущен только в том случае, если он завершился с ненулевым статусом.
3. Всегда - Контейнер будет перезапускаться независимо от состояния выхода. Это будет полезно для критически важных служб которые
должны работать в любом случае

## Как_просмотреть_метаданные_образа_Docker

С помощью команды `docker inspect <имя_образа>`

## Как_демон_Docker_и_клиент_Docker_взаимодействуют_друг_с_другом

Docker Daemon (dockerd) — это фоновый процесс (демон), который управляет контейнерами, образами, сетями и томами.
Docker Client (docker) — это CLI-утилита (или GUI, например, Docker Desktop), через которую пользователь отправляет команды демону.
Демон и клиент общаются через REST API (обычно через Unix-сокет или TCP).

## Как_создать_многоэтапную_сборку_в_Docker

Multi-stage build — это механизм в Docker, позволяющий использовать несколько временных образов (FROM) в одном Dockerfile, чтобы:
1. Уменьшить итоговый размер образа (исключить ненужные зависимости).
2. Повысить безопасность (не включать в финальный образ инструменты сборки).
3. Оптимизировать процесс CI/CD (кеширование этапов).

Проблема без multi-stage:
`FROM openjdk:17-jdk
COPY . .
RUN mvn package  # Остаются: исходники, Maven, промежуточные файлы
CMD ["java", "-jar", "target/app.jar"]`
Итог: Образ весит 500+ MB (включая JDK, Maven, кеш).

Решение с multi-stage:
# Этап 1: Сборка (Builder)
FROM maven:3.8-openjdk-17 AS builder
COPY pom.xml .
RUN mvn dependency:go-offline  # Кешируем зависимости
COPY src/ ./src/
RUN mvn package  # Собираем JAR
# Этап 2: Финальный образ
FROM openjdk:17-jre
COPY --from=builder /target/app.jar /app.jar
CMD ["java", "-jar", "/app.jar"]
Итог: Образ весит ~150 MB (только JRE + JAR).

## Как_Вы_будете_отслеживать_работу_Docker_в_рабочей_среде

Ключевые аспекты, которые нужно отслеживать:
1. Работа контейнеров (статус, перезапуски)
2. Ресурсы (CPU, память, диски)
3. Логи (анализ ошибок)
4. Сеть (трафик, задержки)

Пример настройки для Java-приложения:
# Добавляем Prometheus метрики
FROM openjdk:17
COPY target/app.jar .
EXPOSE 8080 9090
CMD ["java", "-jar", "app.jar", "--management.endpoints.web.exposure.include=prometheus"]

## Что_означает_CNM_Каковы_его_компоненты

CNM (Container Network Model) — это стандартизированная модель сетевого взаимодействия контейнеров, разработанная Docker.
"CNM для контейнеров — как модель OSI для сетей: определяет правила, как контейнеры должны подключаться друг к другу и внешнему миру."Сетевое взаимодействие
Модель состоит из трёх ключевых компонентов:
1. Sandbox (Песочница) - Изолированное сетевое пространство контейнера (например, network namespace в Linux).
2. Endpoint (Конечная точка) - Виртуальный сетевой интерфейс, соединяющий Sandbox с Network.
3. Network (Сеть) - Виртуальная зона коммуникации между Endpoint’ами (аналог VLAN).

Отличие от CNI (Container Network Interface)
CNM — стандарт Docker (Sandbox/Endpoint/Network).
CNI — модель Kubernetes (более низкоуровневая, без понятия Sandbox).

Внутри Docker Desktop есть несколько DNS-серверов.
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов. Каждый раз когда приложение запускается, внутренние IP-адреса могут быть разными но контейнеры по прежнему
будут легко подключаться друг к другу по удобночитаемому имени благодаря внутреннему DNS серверу.

Остальные поисковые запросы отправляются в CoreDNS. Затем в зависимости от доменного имени запросы перенаправляются
на один из двух DNS-серверов на хосте. Домен docker.internal считает особенным и включает в себя DNS-имя
host.docker.internal, которое преобразуется в IP-адрес для текущего хоста. Хотя предпочтительнее когда все
контейнеризировано, иногда имеет смысл запускать часть приложения как обычный сервис хостинга. Имя host.docker.intrenal
позволяет контейнерам связываться с этими хост-серверами и не беспокоиться о хардкодинге IP-адресов.

При помощи команды docker network create <имя сети> мы можем создать общую сеть в которой контейнеры могут легко
обращаться. Внутри единой сети все контейнеры смогут общаться друг с другом и все IP адреса будут заданы автоматически.

Драйвера сети:
1. Bridge(по умолчанию) - контейнеры ищут друг друга по имени внутри одной сети
2. Host - нет изоляции между контейнером и системой (localhost становится сетью)
3. Overlay (устаревший) - несколько Docker могут работать друг с другом
4. Macvlan - задается кастомный MAC-адрес для контейнера который используется для связи с ним
5. Сторонние плагины - обеспечивают различные варианты взаимодействия
6. None - сети отключены

## Можете_ли_вы_определить_разницу_между_Docker_Image_и_Layer

Docker Image (Образ) - Это неизменяемый (immutable) шаблон, содержащий всё необходимое для запуска приложения: код, 
зависимости, конфигурации.
Ключевые свойства:
1. Создаётся из Dockerfile командой docker build.
2. Может быть сохранён в реестре (Docker Hub, GitLab Registry).
3. Запускается как контейнер командой docker run.

Docker Layer (Слой) - Это изменение файловой системы, возникающее при выполнении каждой инструкции в Dockerfile.
Как создаётся: Каждая строка в Dockerfile (кроме метаданных типа LABEL) генерирует слой
Ключевые свойства:
1. Кешируются: Docker переиспользует неизменённые слои при повторной сборке.
2. Иммутабельны: После создания слой нельзя изменить.
3. Оптимизируют размер: Многослойность позволяет уменьшить итоговый образ (например, удаляя временные файлы в том же слое)

1. "Как уменьшить количество слоёв?"
Ответ: "Объединять команды через && и \: `RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*`
2. "Почему COPY и ADD создают слои?"
Ответ: "Чтобы кешировать изменения файлов (Docker сравнивает хэши)."
3. "Как слои влияют на деплой в Kubernetes?"
Ответ: "Меньше слоёв → быстрее загрузка образа в кластер."

## Расскажите_мне_что_нибудь_о_Docker_machine

Docker Machine — это утилита для автоматического развертывания Docker-хостов на различных платформах.
Основные сценарии использования:
1. Создание удаленных Docker-хостов для разработки/тестирования
2. Управление несколькими Docker-окружениями
3. Развертывание Docker на legacy-системах (где невозможна прямая установка)
Что происходит под капотом:
1. Создается виртуальная машина с ОС Linux
2. Автоматически устанавливается Docker Engine
3. Настраиваются TLS-сертификаты для безопасного подключения

Раньше использовалось для:
1. Тестирования Java-приложений в изолированном окружении
2. Демонстрации работы приложения на разных версиях Docker
Сейчас заменяется на:
1. Docker Desktop (для локальной разработки)
2. Minikube/Kind (для Kubernetes)
3. Terraform+Ansible (для инфраструктуры)

"Чем отличается Docker Machine от Docker Context?"
Ответ: "Docker Context — это легковесная альтернатива для переключения между существующими окружениями"
"Как вы организуете окружения для тестирования Java-микросервисов?"
Ответ: "Использую Testcontainers для интеграционных тестов и Kubernetes Namespaces для staging"

## Кратко_опишите_жизненный_цикл_контейнера_Docker

1. Создание: при использовании docker build на основе Dockerfile.
   FROM maven AS builder  # Этап сборки
   COPY . .
   RUN mvn package
  FROM openjdk:17-jre    # Финальный образ
  COPY --from=builder /target/app.jar /app.jar
2. Запуск контейнера
   docker run -d -p 8080:8080 my-java-app
3. Работа приложения.
4. Остановка: при использовании команды `docker stop` контейнер корректно останавливается в этом состоянии.
5. Удаление: с помощью команды `docker rm`контейнер можно удалить.
6. Перезапуск: с помощью команды `docker restart` можно перезапустить контейнеры.

## При_каких_обстоятельствах_вы_потеряете_данные_хранящиеся_в_контейнере

1. Удаление контейнера без томов
   docker rm -f my_container  # Все данные внутри контейнера будут утеряны
Решение:
   Использовать volumes для критичных данных
   docker run -v /path/on/host:/path/in/container ...
2. Пересоздание образа
3. Остановка контейнера с --rm

"Как сохранить данные между деплоями?"
Ответ: "Использовать named volumes + backup стратегию"
"Как проверить, куда сохраняются данные?"
Ответ: "docker inspect + проверка Mounts"
"Какие данные Java-приложения чаще всего теряют?"
Ответ: "Кеш зависимостей, файловые сессии, временные файлы GC logs"

## Можно_ли_удалить_Приостановленный_контейнер_из_Docker

`docker rm <container_id>`

## Может_ли_контейнер_перезапуститься_сам_по_себе

Да может, есть команда при запуске контейнера docker run --restart

## Как_запустить_остановить_и_уничтожить_контейнер

Чтобы запустить контейнер docker, используйте эту команду: docker start < container_name >
Чтобы остановить контейнер docker, используйте эту команду: docker stop < container_name >
Чтобы уничтожить контейнер docker, используйте эту команду: docker kill < container_name >

## Как_вы_масштабируете_контейнеры_Docker_по_горизонтали

Это достигается за счет репликации сервисов на нескольких узлах. Это можно сделать при помощи Docker Compose или Docker Swarm
Например, с помощью команды `docker-compose up --scale web=3` сервис "web" реплицируется на три экземпляра, распределяя рабочую 
нагрузку между ними по горизонтали.
docker-compose up --scale web=3

"Как избежать race condition при масштабировании?"
Ответ: "Использовать distributed locks (Redis, Zookeeper)"
"Как синхронизировать кеш между нодами?"
Ответ: "Hazelcast или Redis с топологией cluster"
"Как дебажить распределенное приложение?"
Ответ: "Distributed tracing (Jaeger) + логгинг с correlation-id"

## В_чём_заключаются_основные_различия_между_ведением_журнала_на_уровне_демона_и_ведением_журнала_на_уровне_контейнера_в_Docker

1. Ведение журнала на уровне демона: Это связано с глобальной настройкой ведения журнала демона Docker. Это повлияет на все контейнеры, 
работающие на хосте. Настройки конфигурации будут применяться на уровне демона.
2. Ведение журнала на уровне контейнера: это будет связано с журналами, относящимися к конкретному контейнеру.

## Как_узнать_количество_запущенных_приостановленных_и_остановленных_контейнеров

Это можно сделать при помощи:
1. docker ps -q - для получения списка запущенных контейнеров
2. docker ps -q -f "status=paused" - для приостановленных.
Количество остановленных контейнеров можно узнать с помощью - docker ps -aq -f "status=exited"

## Как_ограничить_использование_процессора_и_памяти_в_контейнере_Docker

С помощью опции --cpus вы можете установить ограничения для ЦП, а с помощью опции -m вы можете установить ограничения для памяти.
docker run --cpus=3 -m  1024M   <image_name>

## Как_вы_обеспечите_запуск_контейнера_1_до_запуска_контейнера_2_при_использовании_docker_compose

Это происходит при помощи ключа `depends_on`

## Как_Docker_справляется_с_изоляцией_и_безопасностью_контейнеров

1. Уровни изоляции в Docker:
1.1. Пространства имен (Namespaces)
  1.1. PID namespace: Изоляция процессов (контейнер не видит процессы хоста)
  1.2. Network namespace: Собственная сетевая стека (интерфейсы, iptables)
  1.3. Mount namespace: Изолированная файловая система
  1.4. User namespace: Отдельные UID/GID (полезно для Java-приложений, работающих с файлами)
1.2. Cgroups (Control Groups)
  1.1. Ограничение ресурсов для JVM `docker run -m 1g --cpus=2 my-java-app `
2. Безопасность контейнеров
2.1. Защита на уровне ядра
2.2. Безопасность образов

"Как изолировать Java-приложение от хоста?"
Ответ:docker run --read-only --tmpfs /tmp --cap-drop=ALL ...
"Как защитить Docker socket?"
Ответ:
"Ограничить доступ через chmod 600 /var/run/docker.sock + TLS для удалённого API"
"Какие риски у Java в контейнерах?"
Ответ:
Неправильные лимиты памяти (JVM > cgroup)
Утечки через JMX/RMI
Поддельные артефакты в образах

## Как_вы_управляете_сетевым_подключением_между_контейнерами_Docker_и_хост_машиной

1. Мостовые сети - это сети по умолчанию, которые создаются при запуске демона Docker. Через эту сеть контейнеры в одной мостовой сети 
могут взаимодействовать друг с другом.
2. Хост-сети - в этом случае контейнеры будут совместно использовать сетевое пространство хоста. Таким образом, контейнеры смогут 
напрямую использовать сетевые интерфейсы хоста.
3. Пользовательские сети - пользовательские мостовые сети могут использоваться для создания изолированных контейнеров и управления 
их взаимодействием.
4. Наложенные сети - наложенные сети используются в режиме Docker Swarm для связи между сервисами, работающими на разных узлах. 
Они обеспечивают многоузловую сеть для управления контейнерами.

Сетевое взаимодействие
Внутри Docker Desktop есть несколько DNS-серверов.
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов. Каждый раз когда приложение запускается, внутренние IP-адреса могут быть разными но контейнеры по прежнему
будут легко подключаться друг к другу по удобночитаемому имени благодоря внутреннему DNS серверу.

Остальные поисковые запросы отправляются в CoreDNS. Затем в зависимости от доменного имени запросы перенаправляются
на один из двух DNS-серверов на хосте. Домен docker.internal считает особенным и включает в себя DNS-имя
host.docker.internal, которое преобразуется в IP-адрес для текущего хоста. Хотя предпочтительнее когда все
контейнеризировано, иногда имеет смысл запускать часть приложения как обычный сервис хостинга. Имя host.docker.intrenal
позволяет контейнерам связываться с этими хост-серверами и не беспокоиться о хардкодинге IP-адресов.

При помощи команды docker network create <имя сети> мы можем создать общую сеть в которой контейнеры могут легко
обращаться. Внутри единой сети все контейнеры смогут общаться друг с другом и все IP адреса будут заданы автоматически.


Драйвера сети:
1. Bridge(по умолчанию) - контейнеры ищут друг друга по имени внутри одной сети
2. Host - нет изоляции между контейнером и системой (localhost становится сетью)
3. Overlay (устаревший) - несколько Docker могут работать друг с другом
4. Macvlan - задается кастомный MAC-адрес для контейнера который используется для связи с ним
5. Сторонние плагины - обеспечивают различные варианты взаимодействия
6. None - сети отключены

## Как_обновить_контейнер_Docker_без_потери_данных

Ключевые данные, которые нужно сохранить:
1. Persistent данные (БД, файловые хранилища)
2. Сессии приложения (если не используются external хранилища вроде Redis)
3. Конфигурации (env-переменные, properties-файлы)

Чтобы не потерять данные необходимо:
1. Использование Docker Volumes (основной подход)

## Как_вы_отлаживаете_проблемы_в_контейнере_Docker

1. Журналы контейнера: При выполнении этой команды - docker logs
`docker logs <container_id>`
2. Интерактивная оболочка - помогает получить доступ к интерактивной оболочке внутри контейнера для получения подробной информации
`docker exec -it <container_id> /bin/bash`
3. Просмотр сведений о контейнере
`docker inspect <container_id>`
4. Использование ресурсов: Помогает контролировать использование процессора и памяти.
`docker stats <container_id>`

## Какой_способ_удаления_контейнера_предпочтительнее_использовать_команду_docker_stop_за_которой_следует_команда_docker_rm

Для удаления контейнера рекомендуется использовать комбинацию команд "docker stop" и "docker rm" , так как это обеспечивает 
безопасную остановку контейнера перед его удалением. Этот двухэтапный процесс поможет избежать потенциальных проблем, 
связанных с активными процессами внутри контейнера. Однако, если вы уверены, что контейнер не запущен, вы можете использовать 
только команду "docker rm" для его удаления.

## Предположим_у_вас_запущено_3_контейнера_и_вы_хотите_получить_доступ_к_одному_из_них

Чтобы получить доступ к работающему контейнеру, вы можете использовать команду "docker exec" 
`docker exec -it <container_id_or_name> /bin/bash`

## Какие_факторы_определяют_максимальное_количество_контейнеров_которые_можно_запустить_на_хосте_для_приложения_с_микросервисами

Максимальное количество контейнеров, которые может поддерживать хост, в основном зависит от доступных ресурсов, таких как 
оперативная память и ядра процессора. При 16 ГБ оперативной памяти, если предположить, что каждый контейнер эффективно использует 
512 МБ, вы потенциально можете запустить около 32 контейнеров. Однако для оптимального использования ресурсов и масштабирования 
важны тщательное распределение, инструменты мониторинга и оркестрация контейнеров.

## Знаете_ли_вы_о_балансировке_нагрузки_между_контейнерами_и_хостами_Как_это_работает

Основные подходы к балансировке:
1. Встроенные механизмы Docker
1.1. Docker Swarm Mode: `docker service create --name java-app --replicas 5 -p 8080:8080 my-java-image`
      Встроенный Ingress Load Balancing (L4)
      Распределение через DNS Round Robin
      Важно для Java: Spring Boot Actuator health checks для детекции живых нод
1.2. Kubernetes (L7 балансировка)
2. Реализация для Java-микросервисов
2.1. Client-side балансировка
2.2. Service Discovery
2.3. Circuit Breaker

"Как избежать перегрузки JVM при балансировке?"
Ответ:
"Настройка server.tomcat.max-threads + circuit breakers"
"Как балансировать gRPC-сервисы?"
Ответ:
"L7 балансировка (Traefik, Envoy) с поддержкой HTTP/2"
"Как тестировать балансировку локально?"
Ответ:
"Testcontainers + Docker Compose с несколькими replicas"

## Как_вы_обмениваетесь_данными_между_контейнерами_в_Docker

В Docker вы можете обмениваться данными между контейнерами при использовании томов или с помощью `--volumes-from` опция. 
Тома обеспечат постоянный механизм общего хранения, позволяющий нескольким контейнерам получать доступ к данным и изменять их.
В качестве альтернативы опция --volumes-from позволяет контейнеру получить доступ к томам другого контейнера. 
Это обеспечивает беспрепятственный обмен данными и совместную работу между контейнерами, упрощая коммуникацию и координацию 
в сложных многоконтейнерных системах.

## Как_выполнить_миграцию_контейнеров_Docker_между_хостами_в_режиме_реального_времени

Можно использовать инструменты оркестрации такие как Docker Swarm или Kubernetes

## Как_обеспечить_высокую_доступность_вашего_контейнерного_приложения

Ключевые механизмы:
1. Оркестрация контейнеров
Ключевые механизмы:
1.1. Автоматический рестарт при падении (restartPolicy: Always)
1.2. Распределение по разным нодам (podAntiAffinity)
1.3. Горизонтальное масштабирование (HPA на основе метрик JVM)
2. Java-специфичные настройки:
2.1. Распределенные кеши
2.2. Настройка пулов соединений

## Назовите_и_объясните_состояние_контейнера_Docker

1. Created (Контейнер создан, но не запущен)
2. Running (Контейнер работает и выполняет процесс)
3. Paused (Процессы "заморожены")
4. Restarting (Автоматический перезапуск (при --restart=always))
5. Exited (docker stop - Процесс завершен)

"Как отличить OOM от других ошибок?"
Ответ:
"Анализ Exit Code 137 + поиск java.lang.OutOfMemoryError в логах"
"Как debug-ить зависший контейнер?"
Ответ: `docker exec -it my-java-app jstack 1 > thread_dump.txt`
"Зачем нужен статус Paused?"
Ответ:
"Для временной остановки без освобождения ресурсов (дебаг, снапшоты)"

## Является_ли_хорошей_практикой_запуск_приложений_с_отслеживанием_состояния_в_Docker

Docker в первую очередь предназначен для приложений без сохранения состояния. При использовании томов Docker или постоянного 
хранилища приложения с сохранением состояния могут работать, но важно тщательно управлять сохранением данных и резервным копированием,
чтобы избежать их потери.
1. Проблемы Stateful-приложений в Docker
1.1. Ключевые ограничения:
1.1.1. Эфемерные файловые системы: Потеря данных при пересоздании контейнера
1.1.2. Сложность масштабирования: Проблемы с синхронизацией состояния между репликами
1.1.3. Оркестрация: Ограничения Kubernetes для StatefulSets

"Как мигрировать stateful-приложение в облако?"
Ответ:
"Вынести состояние в managed-сервисы (Amazon ElastiCache, Azure CosmosDB)"
"Как обрабатывать транзакции в распределенной системе?"
Ответ:
"Saga Pattern через Spring State Machine"
"Как тестировать stateful-сервисы?"
Ответ:
"Testcontainers + инициализация тестовых данных"

## Что_вы_можете_сказать_о_Docker_Compose

Это YAML-файл, состоящий из всех деталей, касающихся различных сервисов, сетей и томов, которые необходимы для настройки приложения 
на базе Docker. Docker Compose используется для создания нескольких контейнеров, их размещения и установления связи между ними. 
Для связи между контейнерами каждый из них открывает порты.
   version: '3.8'
   services:
     java-app:
       build: .
       ports:
        - "8080:8080"
       depends_on:
         - postgres
         - redis
     postgres:
       image: postgres:13
     environment:
       POSTGRES_PASSWORD: password
     redis:
       image: redis:6

"Как организовать разные окружения?"
Ответ:
"Через несколько файлов: docker-compose.prod.yml, docker-compose.test.yml"
"Как debug-ить Java-приложение?"
Ответ:
"Проброс портов для удаленной отладки + JAVA_TOOL_OPTIONS"
"Как интегрировать с CI/CD?"
Ответ:
"Запуск тестов через docker-compose -f docker-compose.test.yml up --abort-on-container-exit"

## Могу_ли_я_использовать_JSON_вместо_YAML_для_моего_файла_Docker_Compose

да можно

## Что_такое_Docker_Hub

Docker Hub - это реестр контейнеров, который служит централизованным хранилищем для образов Docker.

## Что_такое_Docker_Swarm

Docker Swarm — это встроенная в Docker система оркестрации контейнеров, позволяющая создавать и управлять кластером из нескольких хостов.
Она упрощает управление роем узлов Docker, обеспечивая плавное масштабирование приложений на нескольких узлах в сети.
Она обеспечивает встроенную балансировку нагрузки и гарантирует высокую доступность контейнерных приложений.
Это означает:
1. Возможность развертывания микросервисов в кластере
2. Встроенная отказоустойчивость и балансировка нагрузки
3. Альтернатива Kubernetes для менее сложных сценариев

"Как Swarm обрабатывает stateful Java-приложения?"
Ответ:
"Через Docker Volumes + ограничение реплик (--replicas=1)"
"Как интегрировать с CI/CD пайплайном?"
Ответ:
"docker stack deploy из GitLab CI с переменными окружения"
"Как debug-ить проблемы в кластере?"
Ответ:
"docker service logs + docker exec в конкретные контейнеры"

## Как_Docker_обрабатывает_обнаружение_служб_в_режиме_Swarm

В режиме Docker Swarm обнаружение сервисов автоматически выполняется с помощью внутреннего DNS-сервиса, который 
автоматически присваивает DNS-имена контейнерам, обеспечивая простое обнаружение сервисов внутри роя.
Сетевое взаимодействие
Внутри Docker Desktop есть несколько DNS-серверов.
DNS-запросы от контейнеров сначала обрабатываются сервером внутри docker, который распознает имена других контейнеров
в той же внутренней сети. Это позволяет контейнером легко взаимодействовать друг с другом даже без знания внутренних
IP-адресов. Каждый раз когда приложение запускается, внутренние IP-адреса могут быть разными но контейнеры по прежнему
будут легко подключаться друг к другу по удобночитаемому имени благодоря внутреннему DNS серверу.

Остальные поисковые запросы отправляются в CoreDNS. Затем в зависимости от доменного имени запросы перенаправляются
на один из двух DNS-серверов на хосте. Домен docker.internal считает особенным и включает в себя DNS-имя
host.docker.internal, которое преобразуется в IP-адрес для текущего хоста. Хотя предпочтительнее когда все
контейнеризировано, иногда имеет смысл запускать часть приложения как обычный сервис хостинга. Имя host.docker.intrenal
позволяет контейнерам связываться с этими хост-серверами и не беспокоиться о хардкодинге IP-адресов.

При помощи команды docker network create <имя сети> мы можем создать общую сеть в которой контейнеры могут легко
обращаться. Внутри единой сети все контейнеры смогут общаться друг с другом и все IP адреса будут заданы автоматически.

Драйвера сети:
1. Bridge(по умолчанию) - контейнеры ищут друг друга по имени внутри одной сети
2. Host - нет изоляции между контейнером и системой (localhost становится сетью)
3. Overlay (устаревший) - несколько Docker могут работать друг с другом
4. Macvlan - задается кастомный MAC-адрес для контейнера который используется для связи с ним
5. Сторонние плагины - обеспечивают различные варианты взаимодействия
6. None - сети отключены

## В_чем_основное_различие_между_Swarm_и_Kubernetes

Swarm — это 'Docker-способ' оркестрации, быстрый и простой
Kubernetes — это 'стандарт де-факто' для сложных сценариев
В 80% случаев для production выбираем K8s, но Swarm остается отличным инструментом для staging-окружений и небольших проектов."

1. Docker Swarm подходит если:
1.1. Небольшой кластер (<50 нод)
1.2. Простые deployment-стратегии
1.3. Минимум DevOps-ресурсов
1.4. Быстрый старт проекта
2. Kubernetes предпочтителен когда:
2.1. Enterprise-масштаб (сотни сервисов)
2.2. Требуется гибкое автомасштабирование
2.3. Необходимы canary-релизы
2.4. Используются stateful-сервисы (Kafka, Cassandra)

"Как бы вы выбрали между Swarm и K8s для нового проекта?"
Ответ:
"Оценил бы team expertise, scale требований и need для advanced features"
"Как организовать CI/CD для каждого?"
Ответ:
"Swarm: docker stack deploy, K8s: Helm + ArgoCD"
"Какие проблемы могут возникнуть при миграции?"
Ответ:
"Сетевые политики, storage-классы, service discovery"

## Что_такое_Dockerfile

Dockerfile — это текстовый файл с инструкциями для сборки Docker-образа. 
Для Java-разработчика это:
1. Рецепт создания воспроизводимой среды выполнения
2. Способ упаковки приложения со всеми зависимостями
3. Инструмент CI/CD для автоматизированных сборок

Пример минимального Dockerfile для Java:
FROM eclipse-temurin:17-jdk //Базовый образ с JDK
COPY target/my-app.jar /app.jar  //Добавление JAR-файла
CMD ["java", "-jar", "/app.jar"]  //Команда запуска

"Как debug-ить Dockerfile?"
Ответ:
"docker build --progress=plain + промежуточные образы"

"Как передавать аргументы сборки?"
Ответ:
Через ARG:
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar

"Как уменьшить размер образа?"
Ответ:
"Multi-stage + .dockerignore + slim-образы"

## Перечислите_наиболее_часто_используемые_инструкции_в_DockerFile

FROM	Базовый образ с JDK/JRE
WORKDIR	Рабочая директория для приложения
COPY Добавление JAR-файла
EXPOSE Декларация порта Spring Boot

"Почему COPY идет после RUN mvn dependency:go-offline?"
Ответ: "Чтобы кешировать зависимости отдельным слоем"

"Как уменьшить количество слоев?"
Ответ: "Объединять команды через && \ и очистку в одном RUN"

"Зачем USER 1000?"
Ответ: "Для запуска без root-прав (security best practice)"

## Чем_Dockerfile_отличается_от_Docker_Compose

Dockerfile — это 'сборка' (как Maven для образа)
Compose — это 'оркестрация' (как дирижер для контейнеров)

1. Когда использовать:
Dockerfile:
  - Создание оптимизированного образа приложения
  - Настройка среды выполнения JVM
  - CI/CD пайплайны сборки
Docker Compose:
  - Локальная разработка микросервисов
  - Тестирование взаимодействия сервисов
  - Эмуляция production-окружения
2. Управление зависимостями
  - Dockerfile: Только зависимости внутри образа (JDK, библиотеки)
  - Compose: Внешние сервисы (БД, кеш, очереди)
3. Отладка
  - Dockerfile: ENTRYPOINT для запуска приложения
  - Compose: Проброс debug-портов
4. Разделение обязанностей:
  - Dockerfile - для сборки "чистого" образа
  - Compose - для конфигурации окружения

"Можно ли обойтись без Compose?"
Ответ:
"Да, но ручное управление контейнерами (docker run --link) менее эффективно"

"Как передавать переменные между файлами?"
Ответ:
"Через .env-файл или environment в compose"

"Как debug-ить приложение в compose?"
Ответ:
"Проброс портов + JAVA_TOOL_OPTIONS для remote debug"

## Где_хранятся_тома_Docker

Тома Docker будут храниться на хост-компьютере в каталоге /var/lib/docker/volumes. Это обеспечивает сохранность данных даже 
при удалении контейнера.

## Объясните_контейнеризацию

Контейнеризация — это упаковка приложения со всеми зависимостями в изолированную среду выполнения, подобно тому как:
JAR-файл содержит все классы и ресурсы
Виртуальная машина Java (JVM) обеспечивает переносимость
Модули (JPMS) изолируют компоненты
Но в отличие от JVM, контейнеры изолируют целое окружение, а не только код.

"Как контейнеры влияют на работу GC?"
Ответ:
"Нужно настраивать -XX:+UseContainerSupport и -Xmx меньше лимита cgroup"

"Как debug-ить Java в контейнере?"
Ответ:
"Через -agentlib:jdwp + проброс порта 5005"

"В чем отличие от виртуальных машин?"
Ответ:
"Контейнеры разделяют ядро ОС, легче и быстрее (как JIT vs интерпретатор)"

## В_чем_различие_между_виртуализацией_и_контейнеризацией

Виртуализация — это абстрактная версия физической машины, а контейнеризация — это абстрактная версия приложения.

Виртуализация:
1. Позволяет разработчикам запускать и размещать несколько ОС на оборудовании одного физического сервера.
2. Работу виртуальных машин с гостевыми операционными системами обеспечивают гипервизоры.
3. Виртуальные машины создают абстракцию аппаратного обеспечения системы. Это означает, что каждая виртуальная машина на хосте действует 
как физическая машина.

Контейнеризация:
1. Помогает разработчикам развернуть несколько приложений с использованием одной и той же операционной системы на одной виртуальной машине 
или сервере.
2. Изолированное окружение/пространство пользователя для запуска приложений обеспечивают контейнеры. Любые изменения, сделанные внутри 
контейнера, не отражаются на хосте или других контейнерах того же хоста.
3. Контейнеры создают абстракцию слоя приложения. Это означает, что каждый контейнер представляет собой отдельное приложение.

## Расскажите_мне_немного_о_гипервизоре

Гипервизор - это программное обеспечение, которое создает и управляет виртуальными машинами (VM), позволяя нескольким ОС работать на одном 
физическом сервере.
Типы гипервизоров:
1. Type 1 (Bare-metal)
2. Type 2 (Hosted)

"Гипервизор для Java-разработчика — это инструмент для:
✅ Изоляции legacy-систем (Java 6/7/8)
✅ Тестирования на разных ОС
✅ Гарантированного выделения ресурсов

## Каковы_некоторые_основные_команды_Docker

1. docker run: используется для запуска образа Docker в качестве контейнера Docker.
2. docker ps: выведет список всех запущенных контейнеров в Docker.
3. docker exec: Это помогает выполнять команды в работающем контейнере.
4. docker stop: Это остановит контейнер, запущенный в Docker.

## Каковы_некоторые_расширенные_команды_Docker

docker build -t my-app .          # Сборка образа
docker run -d -p 8080:8080 my-app # Запуск контейнера в фоне
docker ps -a                      # Просмотр всех контейнеров
docker logs <container_id>        # Логи контейнера

Удаление всех остановленных контейнеров и неиспользуемых образов
docker system prune -a

Просмотр ресурсов (CPU, память, сеть)
docker stats

Инспектирование контейнера (JSON-метаданные)
docker inspect <container_id>

Запуск с ограничением памяти (важно для Java-приложений!)
docker run -m 512m my-java-app

Создание сети для связи контейнеров (например, Java-приложения и PostgreSQL)
docker network create my-network

Подключение контейнера к сети
docker run --network=my-network --name=my-app my-java-app

Работа с volumes (сохранение данных)
docker volume create db-data  
docker run -v db-data:/var/lib/postgresql postgres

Запуск нескольких сервисов (Java-приложение + БД + Redis)
docker-compose up -d

Просмотр логов конкретного сервиса
docker-compose logs -f java-app

Пересборка и перезапуск
docker-compose up -d --build

## Что_такое_Docker_Push

docker push — это команда для загрузки собранного Docker-образа в реестр образов

## Что_делает_команда_Docker_Info

Необходима для предоставления инфы о системе. При помощи ей можно узнать кол-во контейнеров, образов.

## Для_чего_нужна_команда_docker_checkpoint

Она необходима для создания снимков состояния работающего контейнера, включая его файловую систему и память.
docker checkpoint — это команда, позволяющая создать чекпоинт (снимок состояния) работающего контейнера, включая:
- Память процесса (RAM).
- CPU-состояние.
- Открытые файловые дескрипторы.
- Сетевые соединения.

Хотя эта команда реже используется в повседневной разработке, она может быть полезна для:
- Stateful-сервисов: Например, если контейнер с Java-приложением (например, Akka Cluster) хранит состояние в памяти.
- Тестирования сложных сценариев: Воспроизведение багов, связанных с состоянием JVM.
- High Availability: Быстрое восстановление сервиса после падения хоста.

Ограничения и нюансы
- Требует включенной поддержки CRIU (не все хосты поддерживают по умолчанию).
- Работает только на Linux (не поддерживается в Docker Desktop для Mac/Windows).
- Не сохраняет данные на диске (только состояние процесса — для данных нужны volumes).

Альтернативы
- Для статистических данных (БД, кеши) лучше использовать volumes.
- Для оркестрации (Kubernetes, Swarm) миграция обычно решается через рестарт контейнера.

## Какая_команда_Docker_выводит_список_состояния_всех_контейнеров

docker ps -a
docker ps – выводит список запущенных контейнеров.
-a (или --all) – показывает все контейнеры (включая остановленные).

Фильтрация по статусу (exited, running, created)
docker ps -a --filter "status=exited"

Фильтрация по имени или label (например, для Java-микросервисов)
docker ps -a --filter "name=user-service" --filter "label=env=prod"

Компактный вывод (только ID)
docker ps -a -q

Показать размеры контейнеров (актуально при утечках памяти в JVM)
docker ps -a --size

## Каково_назначение_параметра_volume_в_команде_docker_run

Параметр -v в команде docker run позволяет:
- Смонтировать директорию с хоста в контейнер (например, для разработки или конфигов).
- Создать или подключить Docker Volume (управляемое хранилище для данных).
- Обеспечить сохранность данных после удаления контейнера (актуально для БД, кешей, логов).

docker run -v /путь/на/хосте:/путь/в/контейнере ...

Типы Volume в Docker
a) Bind Mount (-v /host/path:/container/path)
Жёсткая привязка к папке на хосте.
Плюсы: Полный контроль, удобно для разработки.
Минусы: Зависит от файловой системы хоста.
b) Named Volume (-v volume_name:/container/path)
Управляемый Docker'ом том (хранится в /var/lib/docker/volumes/).
Плюсы: Автоматическое резервное копирование, миграция между контейнерами.
Минусы: Менее прозрачное управление файлами.
c) tmpfs Mount (--tmpfs /container/path)
Временное хранилище в RAM (исчезает после остановки контейнера).
Плюсы: Быстро, безопасно для временных данных.
Минусы: Не сохраняется.

## Как_создать_контейнер_Docker

1. Подготовка Dockerfile
   Для Java-приложения используем multi-stage сборку (оптимизация размера):
   # Этап сборки (build)
   FROM maven:3.8-openjdk-17 AS builder
   WORKDIR /app
   COPY pom.xml .
   RUN mvn dependency:go-offline  # Кешируем зависимости
   COPY src ./src
   RUN mvn package -DskipTests
   # Финальный образ (runtime)
   FROM openjdk:17-jre-slim
   WORKDIR /app
   COPY --from=builder /app/target/my-app.jar ./app.jar
   EXPOSE 8080
   ENTRYPOINT ["java", "-jar", "app.jar"]
2. Сборка образа
   docker build -t my-java-app:1.0 .
3. Запуск контейнера
   docker run -d \
   -p 8080:8080 \
   -e SPRING_PROFILES_ACTIVE=prod \
   --name java-service \
   my-java-app:1.0

"Почему multi-stage сборка?"
Ответ: "Уменьшает итоговый образ (не включаем Maven, исходники)"
"Как кешировать зависимости?"
Ответ: "Копировать pom.xml отдельным шагом перед mvn dependency:go-offline"
"Как debug-ить контейнер?"
docker exec -it java-service bash
jcmd 1 VM.flags  # Диагностика JVM

## В_чем_разница_между_Docker_run_и_Docker_create

docker run:
- Создает и сразу запускает контейнер
- Основная команда для запуска
- Переводит в Running
- Поддерживает все runtime-флаги

Запуск Spring Boot приложения с переменными окружения
docker run -d \
-p 8080:8080 \
-e "SPRING_PROFILES_ACTIVE=prod" \
-v /path/to/config:/config \
my-java-app:latest

docker create:
- Только создает контейнер (в состоянии Created)
- Подготовка контейнера перед запуском
- Оставляет в Created
- Принимает только флаги конфигурации

Создание контейнера с настройками для последующего запуска
docker create \
--name my-java-container \
-p 8080:8080 \
-e "JAVA_OPTS=-Xmx512m" \
my-java-app:latest

Запуск позже с дополнительными параметрами
docker start -a my-java-container

## В_чём_разница_между_командами_up_run_и_start_в_Docker_Compose

1. docker-compose up - Создает и запускает все сервисы из compose-файла
   Особенности:
   1.1. Собирает образы при необходимости (build: в compose-файле)
   1.2. Запускает все зависимости (depends_on)
   1.3. Прикрепляет логи (если не использовать -d)
2. docker-compose run - Запускает одноразовый контейнер для выполнения команды
   Ключевые отличия:
   2.1. Не использует ports: из compose-файла
   2.2. Позволяет переопределить command:
   2.3. Создает новый контейнер (не реиспользует существующий)
3. docker-compose start - Запускает уже созданные, но остановленные контейнеры
   Важные нюансы:
   3.1. Не пересоздает контейнеры
   3.2. Не перестраивает образы
   3.3. Не применяет изменения конфигурации

"Чем отличается up от run при работе с volumes?"
Ответ:
"run создает новые volumes (если не указать --use-aliases), up переиспользует"
"Как сделать cleanup после run?"
Ответ:
"Флаг --rm автоматически удаляет контейнер после выполнения

## Что_делает_команда_FROM

Задаёт базовый (родительский) образ.
Ключевое слово FROM сообщает Docker о том, чтобы при сборке образа использовался бы базовый образ, который соответствует 
предоставленному имени и тегу. Базовый образ, кроме того, ещё называют родительским образом.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## Что_делает_команда_LABEL

Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
В случае с рассматриваемым сейчас файлом, она включает в себя контактные сведения создателя образа. Объявление меток не замедляет 
процесс сборки образа и не увеличивает его размер. Они лишь содержат в себе полезную информацию об образе Docker, поэтому их 
рекомендуется включать в файл.

## Что_делает_команда_ENV

Создаёт переменную окружения
Инструкция ENV позволяет задавать постоянные переменные среды, которые будут доступны в контейнере во время его выполнения.
Инструкция ENV хорошо подходит для задания констант. Если вы используете некое значение в Dockerfile несколько раз, скажем, 
при описании команд, выполняющихся в контейнере, и подозреваете, что, возможно, вам когда-нибудь придётся сменить его на другое,
его имеет смысл записать в подобную константу.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## Что_делает_команда_WORKDIR

Устанавливает рабочую директорию для инструкции CMD и ENTRYPOINT
Инструкция WORKDIR позволяет изменить рабочую директорию контейнера. С этой директорией работают инструкции COPY, ADD, RUN, CMD 
и ENTRYPOINT, идущие за WORKDIR. Вот некоторые особенности, касающиеся этой инструкции:
- Лучше устанавливать с помощью WORKDIR абсолютные пути к папкам, а не перемещаться по файловой системе с помощью команд cd в Dockerfile.
- Инструкция WORKDIR автоматически создаёт директорию в том случае, если она не существует.
- Можно использовать несколько инструкций WORKDIR. Если таким инструкциям предоставляются относительные пути, то каждая из них меняет 
текущую рабочую директорию.

## Что_делает_команда_COPY

Копирует файл с основной системы в контейнер
Инструкция COPY представлена в нашем файле так: COPY . ./app. Она сообщает Docker о том, что нужно взять файлы и папки из локального 
контекста сборки и добавить их в текущую рабочую директорию образа. Если целевая директория не существует, эта инструкция её создаст.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## Что_делает_команда_ADD

Копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
Инструкция ADD позволяет решать те же задачи, что и COPY, но с ней связана ещё пара вариантов использования. Так, с помощью этой 
инструкции можно добавлять в контейнер файлы, загруженные из удалённых источников, а также распаковывать локальные .tar-файлы.

## Что_делает_команда_RUN

Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
Инструкция RUN позволяет создать слой во время сборки образа. После её выполнения в образ добавляется новый слой, 
его состояние фиксируется. Инструкция RUN часто используется для установки в образы дополнительных пакетов.
Инструкция RUN и схожие с ней инструкции — такие, как CMD и ENTRYPOINT, могут быть использованы либо в exec-форме, либо в shell-форме. 
Exec-форма использует синтаксис, напоминающий описание JSON-массива. Например, это может выглядеть так: 
RUN ["my_executable", "my_first_param1", "my_second_param2"].

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## Что_делает_команда_CMD

Выполняет эту команду каждый раз, при новом запуске контейнера. Описывает команду с аргументами, которую нужно выполнить 
когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать 
лишь одна инструкция CMD.
Инструкция CMD предоставляет Docker команду, которую нужно выполнить при запуске контейнера. Результаты выполнения этой команды не 
добавляются в образ во время его сборки. В нашем примере с помощью этой команды запускается скрипт my_script.py во время выполнения 
контейнера.
Вот ещё кое-что, что нужно знать об инструкции CMD:
- В одном файле Dockerfile может присутствовать лишь одна инструкция CMD. Если в файле есть несколько таких инструкций, система 
проигнорирует все кроме последней.
- Инструкция CMD может иметь exec-форму. Если в эту инструкцию не входит упоминание исполняемого файла, тогда в файле должна 
присутствовать инструкция ENTRYPOINT. В таком случае обе эти инструкции должны быть представлены в формате JSON.
- Аргументы командной строки, передаваемые docker run, переопределяют аргументы, предоставленные инструкции CMD в Dockerfile.

## Что_делает_команда_EXPOSE

Порт на ПК и внутри контейнера
Инструкция EXPOSE указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим 
контейнером. Эта инструкция не открывает порты. Она, скорее, играет роль документации к образу, средством общения того, кто собирает 
образ, и того, кто запускает контейнер.
Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду docker run с ключом -p. Если 
использовать ключ в виде -P (с заглавной буквой P), то открыты будут все порты, указанные в инструкции EXPOSE.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## Что_делает_команда_ARG

Определяет переменную для передачи Docker’у во время сборки
Инструкция ARG позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. 
Значение для переменной по умолчанию можно представить в Dockerfile. Например: ARG my_var=my_default_value.
В отличие от ENV-переменных, ARG-переменные недоступны во время выполнения контейнера. Однако ARG-переменные можно использовать 
для задания значений по умолчанию для ENV-переменных из командной строки в процессе сборки образа. А ENV-переменные уже будут доступны 
в контейнере во время его выполнения.

## Что_делает_команда_ENTRYPOINT

Предоставляет команды и аргументы для выполняющегося контейнера. Она похожа на CMD, но параметры ENTRYPOINT не переопределяются, 
если контейнер запущен с параметрами командной строки
Инструкция ENTRYPOINT позволяет задавать команду с аргументами, которая должна выполняться при запуске контейнера. 
Она похожа на команду CMD, но параметры, задаваемые в ENTRYPOINT, не перезаписываются в том случае, если контейнер запускают с 
параметрами командной строки.
В документации к Docker есть несколько рекомендаций, касающихся того, какую инструкцию, CMD или ENTRYPOINT, стоит выбрать в 
качестве инструмента для выполнения команд при запуске контейнера:

Если при каждом запуске контейнера нужно выполнять одну и ту же команду — используйте ENTRYPOINT.
Если контейнер будет использоваться в роли приложения — используйте ENTRYPOINT.
Если вы знаете, что при запуске контейнера вам понадобится передавать ему аргументы, которые могут перезаписывать аргументы, 
указанные в Dockerfile, используйте CMD.

## Что_делает_команда_VOLUME

Создаёт точку подключения директории для добавления и хранения постоянных данных
Инструкция VOLUME позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы 
с такими файлами.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
RUN apk add --update git
WORKDIR /usr/src/my_app_directory
ENV RUN_TIME=123
COPY . .
ADD log-event.sh /
ARG my_var=my_default_value
CMD ["/log-event.sh", "container started"]
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
EXPOSE 8000
VOLUME /my_volume

## В_чем_разница_между_командами_COPY_и_ADD_используемыми_в_Dockerfile

Обе команды имеют схожую функциональность, но COPY более предпочтительна из-за более высокого уровня прозрачности.
COPY обеспечивает только базовую поддержку копирования локальных файлов в контейнер, тогда как ADD предоставляет дополнительные 
возможности, такие как поддержка удаленных URL и извлечение tar.

Инструкция COPY представлена в нашем файле так: COPY . ./app. Она сообщает Docker о том, что нужно взять файлы и папки из
локального контекста сборки и добавить их в текущую рабочую директорию образа. Если целевая директория не существует,
эта инструкция её создаст.

Инструкция ADD позволяет решать те же задачи, что и COPY, но с ней связана ещё пара вариантов использования. Так, с помощью
этой инструкции можно добавлять в контейнер файлы, загруженные из удалённых источников, а также распаковывать локальные .tar-файлы.

Критерий	          COPY	                                                         ADD
Основная цель	    Простое копирование файлов	                         Копирование + дополнительные функции
Распаковка	      Нет поддержки	                                       Автоматическая распаковка архивов (tar, gzip)
URL-источники	    Не поддерживает	                                     Поддерживает загрузку из URL
Читаемость	      Рекомендуется для явного копирования	               Лучше использовать только для специфичных случаев

Преимущества COPY:
1. Прозрачность (явное копирование)
2. Предсказуемость поведения
3. Лучшая производительность

1. Всегда предпочитать COPY для:
- Артефактов сборки (JAR/WAR)
- Конфигурационных файлов
- Исходного кода
2. Использовать ADD только для:
- Локальных архивов, требующих распаковки
- Временных файлов при разработке

## Можете_ли_вы_отличить_CMD_от_ENTRYPOINT

Команда CMD предоставляет файлы, которые запускаются по умолчанию для исполняемого контейнера. В случае если исполняемый файл должен быть
опущен, необходимо использовать инструкцию ENTRYPOINT вместе с форматом массива JSON.

ENTRYPOINT указывает, что содержащаяся в ней команда всегда будет выполняться при запуске контейнера.
Эта команда предоставляет возможность настройки параметров и исполняемых файлов. Если в DockerFile нет этой команды, то она все равно 
будет унаследована от базового образа, указанного в инструкции FROM.

Наиболее часто используемый ENTRYPOINT для большинства базовых образов – /bin/sh или /bin/bash. Как правило, в каждом DockerFile 
должна присутствовать хотя бы одна из этих двух команд.
CMD используется для установки команд и аргументов по умолчанию, которые будут выполняться в начале работы контейнеров. 
Часто его переопределяют, предоставляя аргументы командной строки при запуске контейнера.
ENTRYPOINT настраивает контейнер для запуска в качестве исполняемого файла, определяя команду, которая должна быть выполнена при 
запуске контейнера. Это более строгий параметр, чем CMD, и он часто используется, когда контейнер должен вести себя как исполняемый файл.

## Что_такое_CMD_и_ENTRYPOINT_в_Dockerfile

ENTRYPOINT - Определяет исполняемую команду (аналог main())
ENTRYPOINT ["java", "-jar", "app.jar"]
Особенности:
- Запускается первой при старте контейнера
- Аргументы CMD передаются как параметры

CMD - Задает аргументы по умолчанию для ENTRYPOINT
CMD ["--spring.profiles.active=prod"]
Особенности:
- Может быть переопределен при запуске (docker run)
- Часто используется для передачи параметров JVM

"Можно ли использовать обе инструкции вместе?"
Ответ:
"Да, ENTRYPOINT как основная команда, CMD как аргументы по умолчанию"

"Как передать переменные окружения?"
Ответ:
"Через -e в docker run или ENV в Dockerfile"

## Какова_цель_команды_EXPOSE_в_Dockerfile

EXPOSE в Dockerfile выполняет две ключевые функции:
- Декларация намерений: Указывает, какие порты планируется использовать (документирование)
- Интеграция с инструментами: Помогает orchestration-системам (Docker Compose/Kubernetes) автоматически настраивать сеть

Например, для Spring Boot приложения явное указание EXPOSE 8080 помогает всей команде быстро понять, какой порт использовать для
health checks и подключений.
EXPOSE 8080  # Стандартный порт Tomcat/Spring Boot

## Чем_инструкция_ENTRYPOINT_в_Dockerfile_отличается_от_инструкции_RUN

RUN — это 'сборка' (аналог фазы Maven package),
ENTRYPOINT — это 'запуск' (аналог main-метода).

RUN лучше использовать для:
- Установка JDK/Maven/Gradle
- Загрузка зависимостей
- Запуск тестов при сборке

ENTRYPOINT лучше использовать для:
- Запуск JAR-файла
- Определение параметров JVM
- Graceful shutdown обработка

"Можно ли использовать RUN для запуска приложения?"
Ответ:
"Нет, RUN выполняется только при сборке. Для запуска нужен ENTRYPOINT/CMD"

"Как debug-ить проблемы в RUN?"
Ответ:
"Через docker build --progress=plain или временные образы"

"Почему exec-форма лучше для Java?"
Ответ:
"Корректно передает сигналы (SIGTERM) в JVM для graceful shutdown"
